)]}'
{"version":3,"file":"/packages/simple-schema.js","sources":["simple-schema/string.js","simple-schema/mongo-object.js","simple-schema/simple-schema.js","simple-schema/simple-schema-context.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,E;AACA,2E;AACA,E;;AAEA,c;AACA,e;;AAEA,wB;;AAEA,oB;;AAEA,iB;AACA,wC;AACA,gC;AACA,mB;AACA,U;AACA,8B;AACA,Y;AACA,qC;AACA,K;;AAEA,oF;;AAEA,wC;AACA,kC;AACA,oD;AACA,+B;AACA,U;AACA,c;AACA,+B;AACA,O;AACA,Y;AACA,uB;AACA,K;AACA,G;;AAEA,+B;AACA,4B;;AAEA,oC;AACA,qB;AACA,qC;AACA,oC;AACA,yC;AACA,qE;AACA,M;;AAEA,yE;AACA,0B;AACA,gF;AACA,0C;AACA,S;AACA,sB;AACA,M;;AAEA,4B;AACA,0F;AACA,M;;AAEA,6B;AACA,kC;AACA,M;;AAEA,iC;AACA,qB;AACA,oC;AACA,oC;AACA,yB;AACA,c;AACA,oB;AACA,O;AACA,M;;AAEA,kC;AACA,kC;AACA,uB;AACA,iD;AACA,wB;AACA,c;AACA,oB;AACA,O;AACA,M;;AAEA,oB;AACA,oC;AACA,0E;AACA,sB;AACA,M;;AAEA,4B;AACA,qC;AACA,M;;AAEA,yB;AACA,mB;AACA,kC;;AAEA,wB;AACA,kB;AACA,yC;AACA,O;;AAEA,kB;AACA,M;;AAEA,+D;AACA,2B;AACA,iH;AACA,sB;AACA,M;;AAEA,gG;AACA,qB;AACA,sD;AACA,yC;AACA,Q;AACA,6D;AACA,sD;AACA,Q;AACA,iD;AACA,qC;AACA,oE;AACA,Y;AACA,yC;AACA,6C;AACA,S;AACA,8C;AACA,wB;AACA,S;AACA,c;AACA,mB;AACA,S;AACA,Q;;AAEA,sB;AACA,M;;AAEA,gC;AACA,6C;AACA,uD;AACA,M;;AAEA,qD;AACA,0G;AACA,M;;AAEA,kC;AACA,qB;AACA,oC;AACA,oB;AACA,c;AACA,iC;AACA,O;AACA,M;;AAEA,mC;AACA,qB;AACA,mC;AACA,oB;AACA,c;AACA,iC;AACA,O;AACA,M;;AAEA,4D;AACA,kD;AACA,wB;AACA,yF;AACA,qB;AACA,M;;AAEA,yB;AACA,2D;AACA,M;;AAEA,gC;AACA,8D;AACA,M;;AAEA,yB;AACA,yF;AACA,M;;AAEA,yB;AACA,+D;AACA,M;;AAEA,2B;AACA,oC;AACA,M;;AAEA,yB;AACA,+D;AACA,M;;AAEA,uB;AACA,mB;AACA,oC;AACA,wB;AACA,c;AACA,8B;AACA,O;AACA,M;AACA,I;AACA,qG;AACA,yD;AACA,M;;AAEA,+D;AACA,qB;AACA,qD;AACA,gC;AACA,wD;AACA,0D;AACA,0C;AACA,M;;AAEA,mE;AACA,qB;AACA,qD;AACA,qE;AACA,M;;AAEA,oE;AACA,qB;AACA,qD;AACA,qE;AACA,M;;AAEA,mG;AACA,mC;AACA,6B;AACA,0C;AACA,wB;;AAEA,kG;AACA,oD;AACA,8D;;AAEA,qB;AACA,uB;;AAEA,uB;AACA,4B;AACA,0B;AACA,sB;AACA,sC;AACA,6E;AACA,qB;AACA,sC;AACA,oB;AACA,W;AACA,0C;AACA,yB;AACA,+B;AACA,kB;AACA,yB;AACA,qC;AACA,wC;AACA,kB;AACA,+C;AACA,qC;AACA,a;AACA,kB;AACA,6B;AACA,0B;AACA,0C;AACA,oB;AACA,2B;AACA,qD;AACA,sC;AACA,gC;AACA,2C;AACA,iB;AACA,a;AACA,kB;AACA,kB;AACA,wB;AACA,wC;AACA,kB;AACA,S;AACA,e;AACA,O;;AAEA,wC;AACA,iB;AACA,0B;AACA,oB;AACA,O;AACA,oB;AACA,M;;AAEA,iC;AACA,uD;AACA,sC;AACA,sB;AACA,M;;AAEA,wB;AACA,mB;AACA,oD;AACA,wB;AACA,c;AACA,6B;AACA,O;AACA,M;;AAEA,yB;AACA,oF;AACA,+B;AACA,0B;AACA,uB;AACA,M;;AAEA,kC;AACA,iD;AACA,M;;AAEA,kC;AACA,0E;AACA,0E;AACA,M;;AAEA,2C;AACA,qE;AACA,qC;AACA,kE;AACA,S;AACA,sB;AACA,M;;AAEA,kD;AACA,oB;AACA,+C;AACA,gD;AACA,0D;AACA,gC;AACA,qC;;AAEA,uC;AACA,iG;AACA,wB;AACA,4C;AACA,S;AACA,sB;AACA,M;;AAEA,wB;AACA,kD;AACA,M;;AAEA,2B;AACA,0C;AACA,qC;AACA,yD;AACA,Y;AACA,qD;AACA,M;;AAEA,kC;AACA,kC;AACA,oB;AACA,iD;AACA,U;AACA,kB;AACA,M;;AAEA,uC;AACA,+D;AACA,mF;AACA,M;;AAEA,sB;AACA,Y;AACA,6C;AACA,8C;AACA,W;AACA,yB;AACA,sB;AACA,M;;AAEA,0B;AACA,Y;AACA,yB;AACA,8B;AACA,U;AACA,0C;AACA,sB;AACA,M;;AAEA,2B;AACA,Y;AACA,0B;AACA,+B;AACA,U;AACA,uC;AACA,sB;AACA,M;;AAEA,2F;AACA,uB;;AAEA,wB;AACA,mC;;AAEA,kD;;AAEA,wF;AACA,6G;;AAEA,0D;AACA,mD;AACA,U;AACA,6E;;AAEA,kH;AACA,M;;AAEA,uB;AACA,2F;AACA,yB;;AAEA,2B;AACA,wC;AACA,O;;AAEA,6C;AACA,gD;AACA,gD;AACA,wD;AACA,uD;AACA,+C;AACA,mC;AACA,oD;AACA,6B;AACA,O;;AAEA,2C;AACA,iC;;AAEA,gC;AACA,yB;;AAEA,sC;AACA,+B;AACA,qB;AACA,kC;AACA,4C;AACA,qB;AACA,kC;AACA,gB;AACA,6C;AACA,O;;AAEA,mC;AACA,2B;AACA,kD;AACA,6C;AACA,4C;AACA,0C;AACA,Q;AACA,0B;AACA,sC;AACA,Q;AACA,kE;AACA,mE;AACA,8B;AACA,e;AACA,8B;;AAEA,0B;AACA,sC;AACA,Q;AACA,kB;AACA,kC;AACA,O;;AAEA,uB;AACA,uC;AACA,kD;AACA,yC;AACA,M;;AAEA,0B;AACA,oB;AACA,M;;AAEA,+D;AACA,4B;AACA,yG;AACA,gD;AACA,oB;AACA,O;AACA,sB;AACA,M;;AAEA,uD;AACA,8E;AACA,kB;;AAEA,wC;AACA,yC;AACA,mE;AACA,6D;AACA,0D;AACA,iD;AACA,gB;AACA,wB;AACA,S;AACA,U;AACA,M;;AAEA,yB;AACA,8B;AACA,K;;AAEA,G;;AAEA,wB;AACA,8B;AACA,4B;AACA,sB;AACA,8B;AACA,0C;AACA,kC;AACA,oC;AACA,sC;AACA,+C;AACA,W;AACA,S;AACA,e;AACA,K;AACA,G;;AAEA,+B;AACA,iD;AACA,+C;AACA,4B;AACA,G;;;AAGA,sC;AACA,6C;AACA,uC;;AAEA,qD;AACA,sC;AACA,qB;AACA,mC;AACA,4C;AACA,iC;AACA,0B;AACA,oD;AACA,qC;AACA,iC;AACA,8D;AACA,a;AACA,kB;AACA,oC;AACA,W;AACA,S;AACA,O;AACA,a;AACA,G;;;AAGA,sC;AACA,mB;AACA,uC;;AAEA,2B;AACA,+B;AACA,8B;AACA,+B;AACA,+F;;;AAGA,sC;AACA,oB;AACA,uC;;AAEA,wC;AACA,+C;AACA,oB;;AAEA,4C;AACA,0B;AACA,6B;AACA,W;AACA,uD;AACA,4B;AACA,oB;AACA,K;AACA,kB;AACA,G;;AAEA,2C;AACA,qB;AACA,qC;AACA,kD;AACA,oD;AACA,qD;AACA,qB;AACA,iF;AACA,2B;AACA,2B;AACA,wC;AACA,iC;;AAEA,wC;AACA,iC;;AAEA,kG;AACA,qC;AACA,2B;AACA,O;AACA,qB;AACA,K;AACA,G;;AAEA,wB;AACA,sB;AACA,I;;AAEA,qC;AACA,2C;AACA,6C;AACA,2B;AACA,0B;AACA,2B;AACA,6B;;;;AAIA,sC;AACA,U;AACA,uC;;AAEA,gF;AACA,4B;;AAEA,U;;AAEA,oD;AACA,6B;AACA,sB;AACA,S;AACA,Y;AACA,wB;AACA,K;AACA,G;;;AAGA,sC;AACA,8B;AACA,uC;;AAEA,iB;AACA,gC;AACA,uB;AACA,sC;AACA,2B;AACA,uC;AACA,K;AACA,kB;AACA,G;;AAEA,0B;AACA,qB;AACA,Y;AACA,Y;AACA,c;AACA,c;AACA,Y;AACA,I;;AAEA,0B;AACA,+B;AACA,6E;;AAEA,c;AACA,gB;AACA,e;AACA,e;AACA,kB;AACA,iB;AACA,kB;AACA,mB;AACA,kB;AACA,mB;AACA,kB;AACA,mB;AACA,iB;AACA,mB;AACA,gB;AACA,mB;AACA,kB;AACA,mB;AACA,iB;AACA,mB;AACA,kB;AACA,mB;AACA,iB;AACA,mB;AACA,mB;AACA,kB;AACA,mB;AACA,mB;AACA,mB;AACA,iB;AACA,kB;AACA,mB;AACA,kB;AACA,mB;AACA,iB;AACA,mB;AACA,mB;AACA,kB;AACA,kB;AACA,mB;AACA,kB;AACA,mB;AACA,iB;AACA,mB;AACA,mB;AACA,kB;AACA,mB;AACA,gB;AACA,iB;AACA,mB;AACA,kB;AACA,mB;AACA,iB;AACA,mB;AACA,mB;AACA,kB;AACA,mB;AACA,mB;AACA,mB;AACA,iB;AACA,kB;AACA,kB;AACA,mB;AACA,kB;AACA,mB;AACA,iB;AACA,mB;AACA,iB;AACA,iB;AACA,gB;AACA,iB;AACA,kB;AACA,iB;AACA,kB;AACA,mB;AACA,gB;AACA,mB;AACA,iB;AACA,gB;AACA,iB;AACA,kB;AACA,gB;AACA,gB;AACA,iB;AACA,gB;AACA,mB;AACA,iB;AACA,iB;AACA,iB;AACA,kB;AACA,kB;AACA,iB;AACA,mB;AACA,kB;AACA,iB;AACA,kB;AACA,mB;AACA,mB;AACA,mB;AACA,mB;AACA,kB;AACA,mB;AACA,mB;AACA,mB;AACA,oB;AACA,oB;AACA,kB;AACA,kB;AACA,kB;AACA,mB;AACA,mB;AACA,kB;AACA,mB;AACA,mB;AACA,qB;AACA,kB;AACA,iB;AACA,mB;AACA,kB;AACA,mB;AACA,oB;AACA,gB;AACA,gB;AACA,gB;AACA,qB;AACA,gB;AACA,iB;AACA,mB;AACA,iB;AACA,qB;AACA,iB;AACA,iB;AACA,iB;AACA,mB;AACA,mB;AACA,kB;AACA,mB;AACA,mB;AACA,qB;AACA,kB;AACA,iB;AACA,mB;AACA,kB;AACA,mB;AACA,oB;AACA,gB;AACA,gB;AACA,gB;AACA,qB;AACA,gB;AACA,iB;AACA,oB;AACA,mB;AACA,iB;AACA,qB;AACA,iB;AACA,iB;AACA,iB;AACA,mB;AACA,sB;AACA,mB;AACA,iB;AACA,mB;AACA,mB;AACA,qB;AACA,mB;AACA,kB;AACA,kB;AACA,kB;AACA,oB;AACA,oB;AACA,oB;AACA,oB;AACA,oB;AACA,oB;AACA,oB;AACA,oB;AACA,qB;AACA,qB;AACA,mB;AACA,qB;AACA,qB;AACA,oB;AACA,oB;AACA,qB;AACA,qB;AACA,oB;AACA,oB;AACA,mB;AACA,oB;AACA,qB;AACA,mB;AACA,oB;AACA,sB;AACA,mB;AACA,mB;AACA,mB;AACA,mB;AACA,mB;AACA,oB;AACA,mB;AACA,mB;AACA,mB;AACA,mB;AACA,mB;AACA,qB;AACA,mB;AACA,oB;AACA,oB;AACA,oB;AACA,mB;AACA,oB;AACA,iB;AACA,mB;AACA,kB;AACA,oB;AACA,qB;AACA,oB;AACA,mB;AACA,oB;AACA,kB;AACA,kB;AACA,iB;AACA,kB;AACA,kB;AACA,kB;AACA,qB;AACA,kB;AACA,mB;AACA,oB;AACA,iB;AACA,oB;AACA,iB;AACA,iB;AACA,kB;AACA,kB;AACA,mB;AACA,mB;AACA,mB;AACA,oB;AACA,qB;AACA,mB;AACA,mB;AACA,oB;AACA,oB;AACA,qB;AACA,qB;AACA,mB;AACA,mB;AACA,kB;AACA,qB;AACA,oB;AACA,qB;AACA,mB;AACA,G;;;AAGA,c;;;;;;;;;;;;;;;;;;;ACz6BA,E;AACA,e;AACA,gC;AACA,2F;AACA,uB;AACA,E;AACA,8E;AACA,4E;AACA,2E;AACA,uB;AACA,G;AACA,qD;AACA,kB;AACA,4B;AACA,0B;AACA,iC;AACA,6B;AACA,mC;AACA,6B;;AAEA,2F;;AAEA,gD;AACA,0E;AACA,6B;AACA,yB;AACA,K;;AAEA,sC;AACA,2B;AACA,sB;;AAEA,0D;AACA,2H;AACA,2B;AACA,sE;AACA,oE;AACA,oE;AACA,mD;AACA,0B;AACA,wD;AACA,gB;AACA,2C;AACA,S;AACA,wB;AACA,O;;AAEA,yB;AACA,oD;;AAEA,wE;AACA,2E;;AAEA,yE;AACA,4B;AACA,0D;AACA,wE;;AAEA,wF;AACA,2E;AACA,O;AACA,K;;AAEA,0B;AACA,4C;AACA,4B;AACA,wF;AACA,oD;AACA,O;;AAEA,a;AACA,kC;AACA,8H;AACA,S;AACA,K;;AAEA,wD;AACA,sD;AACA,0B;AACA,kF;AACA,+C;AACA,yF;AACA,oD;AACA,4E;AACA,oD;AACA,O;AACA,a;AACA,kC;AACA,2B;AACA,wB;AACA,oC;AACA,qJ;AACA,S;AACA,S;AACA,K;;AAEA,G;AACA,sB;;AAEA,yB;AACA,4B;AACA,mC;AACA,+B;AACA,qC;AACA,+B;AACA,wB;AACA,G;;AAEA,K;AACA,oC;AACA,2B;AACA,8B;AACA,gI;AACA,yB;AACA,I;AACA,mG;AACA,+B;AACA,+B;AACA,gD;AACA,uF;AACA,iF;AACA,K;AACA,8C;AACA,mC;AACA,yD;;AAEA,wB;AACA,yB;AACA,gB;;AAEA,2B;AACA,gE;AACA,+E;AACA,gC;AACA,iB;AACA,kD;AACA,sC;AACA,2B;AACA,yB;AACA,wD;AACA,uC;AACA,2C;AACA,U;AACA,4B;AACA,2C;AACA,S;AACA,S;AACA,O;;AAEA,kD;AACA,sD;AACA,iD;AACA,O;;AAEA,I;;AAEA,iD;AACA,mE;AACA,uD;AACA,0B;AACA,qD;AACA,qC;AACA,qC;AACA,O;AACA,gC;AACA,yE;AACA,e;AACA,O;AACA,K;AACA,mB;AACA,I;;AAEA,K;AACA,sD;AACA,6B;AACA,uB;AACA,yB;AACA,K;AACA,wD;AACA,8E;;AAEA,uD;AACA,0B;AACA,qD;AACA,qC;AACA,qC;AACA,O;AACA,0E;AACA,yB;AACA,yB;AACA,gC;AACA,oD;AACA,6B;AACA,iC;AACA,O;AACA,iE;AACA,Y;AACA,6E;AACA,iF;AACA,6D;AACA,6C;AACA,qC;AACA,8C;AACA,uD;AACA,S;;AAEA,sC;AACA,kC;;AAEA,6C;AACA,2E;AACA,iB;AACA,S;AACA,O;AACA,K;;AAEA,iB;AACA,I;;AAEA,K;AACA,yD;AACA,6B;AACA,yB;AACA,K;AACA,oD;AACA,+C;AACA,I;;AAEA,K;AACA,oD;AACA,6B;AACA,yB;AACA,K;AACA,+C;AACA,wC;AACA,I;;AAEA,K;AACA,2D;AACA,6B;AACA,yB;AACA,K;AACA,sD;AACA,+C;AACA,I;;AAEA,K;AACA,sC;AACA,0C;AACA,gC;AACA,I;AACA,qE;AACA,2C;AACA,K;AACA,sC;AACA,mB;AACA,+C;AACA,mB;AACA,c;AACA,kD;AACA,qC;AACA,Q;AACA,K;;AAEA,0E;AACA,gC;AACA,4E;AACA,2E;AACA,2B;AACA,qE;AACA,yD;AACA,uB;AACA,kG;AACA,c;AACA,gB;AACA,mB;AACA,gC;AACA,U;AACA,O;AACA,K;AACA,I;;AAEA,K;AACA,0C;AACA,0C;AACA,gD;AACA,I;AACA,iE;AACA,2C;AACA,2B;AACA,K;AACA,0C;AACA,mB;AACA,8C;AACA,wD;AACA,mD;AACA,wD;AACA,0D;AACA,+E;AACA,0B;AACA,S;AACA,O;AACA,K;;AAEA,qE;AACA,I;;AAEA,K;AACA,kD;AACA,sC;AACA,kD;AACA,I;AACA,2E;AACA,sC;AACA,6B;AACA,K;AACA,kD;AACA,mB;AACA,kB;AACA,qD;AACA,+D;AACA,0D;AACA,8B;AACA,S;AACA,O;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,kC;AACA,uC;AACA,0C;AACA,6B;AACA,I;AACA,uD;AACA,K;AACA,uC;AACA,+C;AACA,mB;AACA,gD;AACA,K;AACA,I;;AAEA,K;AACA,yC;AACA,qC;AACA,8C;AACA,6F;AACA,yB;AACA,I;AACA,0E;AACA,K;AACA,wC;AACA,+E;AACA,4C;AACA,I;;AAEA,K;AACA,oD;AACA,2B;AACA,yB;AACA,I;AACA,sE;AACA,K;AACA,2C;AACA,qD;AACA,+D;AACA,oE;AACA,gD;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,K;AACA,yC;AACA,wB;AACA,yB;AACA,I;AACA,4D;AACA,K;AACA,yC;AACA,qD;AACA,+D;AACA,0D;AACA,gD;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,K;AACA,kC;AACA,wB;AACA,yB;AACA,I;AACA,gE;AACA,K;AACA,kC;AACA,wE;AACA,sD;AACA,8C;AACA,wD;AACA,mD;AACA,gD;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,K;AACA,mC;AACA,2B;AACA,yB;AACA,I;AACA,0E;AACA,K;AACA,oC;AACA,oD;AACA,8B;AACA,K;AACA,I;;AAEA,K;AACA,0C;AACA,2C;AACA,yB;AACA,I;AACA,uD;AACA,iE;AACA,K;AACA,2C;AACA,gD;AACA,qD;AACA,+D;AACA,iD;AACA,2C;AACA,+B;AACA,gC;AACA,kC;AACA,W;AACA,S;AACA,O;AACA,K;;AAEA,wC;AACA,iC;AACA,O;AACA,I;;AAEA,K;AACA,uC;AACA,wB;AACA,qB;AACA,yB;AACA,I;AACA,8D;AACA,kC;AACA,K;AACA,4C;AACA,wE;AACA,6D;AACA,8C;AACA,wD;AACA,mD;AACA,kD;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,K;AACA,8C;AACA,wB;AACA,qB;AACA,yB;AACA,I;AACA,8D;AACA,8B;AACA,K;AACA,mD;AACA,wE;AACA,6D;AACA,qD;AACA,+D;AACA,0D;AACA,kD;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,K;AACA,kC;AACA,sB;AACA,I;AACA,8E;AACA,0B;AACA,K;AACA,+B;AACA,qB;AACA,I;;AAEA,K;AACA,sC;AACA,sB;AACA,I;AACA,0D;AACA,0E;AACA,yE;AACA,c;AACA,I;AACA,uE;AACA,wE;AACA,sE;AACA,uE;AACA,+D;AACA,uB;AACA,K;AACA,0C;AACA,4B;AACA,oB;AACA,gE;AACA,4C;AACA,8I;AACA,6E;AACA,W;AACA,iE;AACA,O;AACA,O;AACA,kB;AACA,I;;AAEA,K;AACA,mC;AACA,wB;AACA,sB;AACA,I;AACA,mE;AACA,K;AACA,mC;AACA,yC;AACA,I;;AAEA,K;AACA,0C;AACA,wB;AACA,sB;AACA,I;AACA,+D;AACA,K;AACA,0C;AACA,qD;AACA,+D;AACA,0D;AACA,sB;AACA,S;AACA,O;AACA,K;AACA,iB;AACA,I;;AAEA,K;AACA,kD;AACA,wB;AACA,sB;AACA,I;AACA,4E;AACA,K;AACA,kD;AACA,qD;AACA,+D;AACA,8D;;AAEA,8C;AACA,kC;AACA,sB;AACA,S;;AAEA,4E;AACA,wD;AACA,qE;AACA,sB;AACA,S;;AAEA,4E;AACA,mE;AACA,oC;AACA,mE;AACA,sB;AACA,S;AACA,O;AACA,K;AACA,iB;AACA,I;AACA,E;;AAEA,gE;AACA,0D;AACA,E;AACA,yC;AACA,mB;AACA,2B;AACA,gC;AACA,qC;AACA,G;;AAEA,gE;AACA,0D;AACA,E;AACA,yC;AACA,mB;AACA,2B;AACA,gC;AACA,qC;AACA,E;AACA,mB;AACA,sB;AACA,sB;AACA,uB;AACA,G;AACA,iD;AACA,iE;AACA,qD;AACA,wB;AACA,mC;AACA,mC;AACA,K;AACA,uB;AACA,+D;AACA,4B;AACA,gD;AACA,yB;AACA,+B;AACA,Y;AACA,yC;AACA,iC;AACA,0C;AACA,6B;AACA,qD;AACA,O;AACA,K;AACA,8B;AACA,G;AACA,E;;AAEA,mE;AACA,oB;AACA,8C;AACA,8B;AACA,wB;AACA,Y;AACA,oC;AACA,K;AACA,K;AACA,kB;AACA,E;;AAEA,G;AACA,qC;AACA,2B;AACA,0E;AACA,E;AACA,yE;AACA,uE;AACA,yC;AACA,G;AACA,+D;AACA,qD;AACA,sB;AACA,iC;AACA,+D;AACA,6C;AACA,c;AACA,a;AACA,E;;AAEA,wB;;AAEA,8B;AACA,6B;AACA,E;;AAEA,0B;AACA,kD;AACA,yC;AACA,8C;AACA,8B;AACA,M;AACA,U;AACA,8C;AACA,4D;AACA,0C;AACA,M;AACA,G;AACA,C;;AAEA,iD;AACA,sC;AACA,E;AACA,mB;AACA,qB;AACA,G;AACA,mC;AACA,0E;AACA,E;;AAEA,6D;AACA,gE;AACA,mC;AACA,E;AACA,qB;AACA,wB;AACA,G;AACA,8C;AACA,+B;AACA,gB;AACA,uE;AACA,E;;AAEA,sE;AACA,wB;AACA,uB;AACA,U;AACA,yD;AACA,G;AACA,E;;AAEA,4D;AACA,8C;AACA,oE;AACA,kF;AACA,E;;;;;;;;;;;;;;;;;;AC9tBA,sB;AACA,4B;AACA,C;AACA,sB;AACA,e;AACA,C;;AAEA,wB;AACA,kB;AACA,uD;AACA,oC;AACA,2D;AACA,2D;AACA,mC;AACA,mC;AACA,6C;AACA,qF;AACA,mC;AACA,uD;AACA,mC;AACA,oC;AACA,sC;AACA,yC;AACA,E;;AAEA,U;AACA,2C;AACA,kB;AACA,gC;AACA,iE;AACA,6E;AACA,6D;AACA,oB;AACA,0B;AACA,0B;;AAEA,4B;AACA,wB;AACA,G;;AAEA,sD;AACA,uC;;AAEA,yD;AACA,wB;;AAEA,qC;AACA,wB;;AAEA,2E;AACA,0B;;AAEA,yD;AACA,wB;;AAEA,2D;AACA,sB;;AAEA,2C;AACA,wB;;AAEA,4B;AACA,wD;AACA,oC;AACA,oD;AACA,yE;AACA,K;;AAEA,4C;;AAEA,qC;;AAEA,4E;AACA,iB;AACA,uC;AACA,sC;AACA,oI;AACA,c;AACA,2C;AACA,oG;AACA,S;AACA,oE;AACA,6B;AACA,wD;AACA,uB;AACA,a;AACA,Y;AACA,oC;AACA,O;AACA,K;;AAEA,oC;AACA,yC;AACA,+F;AACA,O;AACA,yD;AACA,K;;AAEA,sD;;AAEA,uC;AACA,yC;AACA,K;;AAEA,2D;AACA,+C;AACA,iC;AACA,yD;AACA,O;;AAEA,sC;AACA,+D;AACA,O;;AAEA,8B;AACA,uD;AACA,O;AACA,K;;AAEA,+B;AACA,yC;AACA,K;;AAEA,oC;AACA,+C;AACA,K;;AAEA,4B;AACA,uC;AACA,K;;AAEA,0D;AACA,sE;AACA,6D;AACA,iB;AACA,uD;AACA,0D;AACA,0F;AACA,+D;AACA,+E;AACA,+C;AACA,kD;AACA,gD;AACA,wG;AACA,qD;AACA,6F;AACA,W;AACA,W;AACA,O;AACA,K;;AAEA,K;AACA,E;AACA,0B;AACA,kC;;AAEA,sB;AACA,oD;AACA,Y;AACA,gD;AACA,oE;AACA,6E;AACA,kB;AACA,4D;AACA,gF;AACA,yF;AACA,U;AACA,4C;AACA,gE;AACA,yE;;AAEA,iD;AACA,gC;AACA,E;;AAEA,2D;AACA,yC;AACA,gD;AACA,sC;AACA,E;;AAEA,4C;AACA,8D;AACA,uD;AACA,4F;AACA,iE;AACA,iF;AACA,0E;AACA,mE;AACA,gF;AACA,0E;AACA,2C;AACA,qE;AACA,uD;AACA,qE;AACA,oE;AACA,gE;AACA,+E;AACA,8E;AACA,2D;AACA,8E;;AAEA,sB;AACA,gE;AACA,yE;AACA,E;AACA,4C;AACA,qD;AACA,E;AACA,0D;AACA,wC;AACA,wC;AACA,0D;AACA,2C;AACA,2e;AACA,6D;AACA,sG;AACA,sG;AACA,uE;AACA,E;;AAEA,4C;AACA,+B;AACA,gB;;AAEA,uE;AACA,E;;AAEA,uD;;AAEA,mD;AACA,iC;;AAEA,2B;AACA,sF;AACA,6B;AACA,2C;;AAEA,qF;AACA,2E;AACA,kD;AACA,kB;;AAEA,uC;AACA,gC;AACA,kC;AACA,sC;AACA,wB;AACA,Y;AACA,2B;AACA,K;AACA,K;;AAEA,kC;AACA,2F;;AAEA,kG;AACA,6E;;AAEA,c;AACA,E;;AAEA,kD;AACA,6B;AACA,6B;AACA,+B;AACA,oG;AACA,O;AACA,O;AACA,K;AACA,C;;AAEA,sD;AACA,kB;AACA,iC;AACA,qB;AACA,G;AACA,wC;AACA,6E;;AAEA,uE;AACA,gD;AACA,mC;AACA,uE;AACA,S;AACA,K;AACA,G;AACA,wC;AACA,E;;AAEA,2B;AACA,8B;AACA,4C;AACA,sC;AACA,E;;AAEA,6B;AACA,4C;AACA,yF;AACA,8B;AACA,E;;AAEA,G;AACA,uC;AACA,oG;AACA,4B;AACA,yD;AACA,8E;AACA,gI;AACA,uF;AACA,0E;AACA,6H;AACA,sC;AACA,G;AACA,+E;AACA,oF;AACA,gC;AACA,G;AACA,uD;AACA,kB;;AAEA,uD;AACA,sB;AACA,iB;AACA,sB;AACA,6B;AACA,wB;AACA,sB;AACA,8B;AACA,oB;;AAEA,sD;AACA,0B;AACA,+F;AACA,gC;AACA,qC;AACA,gD;AACA,4D;AACA,qE;AACA,4D;AACA,O;AACA,0B;AACA,K;AACA,G;;AAEA,sD;;AAEA,2D;AACA,6B;AACA,iE;AACA,6C;AACA,yC;AACA,mJ;AACA,K;AACA,mB;AACA,K;;AAEA,oD;AACA,sF;AACA,0B;AACA,8C;AACA,2B;AACA,kC;AACA,qC;AACA,kC;AACA,kD;AACA,oD;AACA,8K;AACA,qC;AACA,oC;AACA,mC;AACA,6I;AACA,4B;AACA,a;AACA,W;AACA,S;AACA,+B;AACA,wJ;AACA,wB;AACA,S;AACA,O;AACA,K;AACA,6B;;AAEA,yB;AACA,8G;;AAEA,a;AACA,E;;AAEA,sE;AACA,iB;AACA,+C;AACA,kB;AACA,6C;AACA,oB;AACA,wD;AACA,U;AACA,wB;AACA,G;AACA,E;;AAEA,+C;AACA,kD;AACA,kB;AACA,6C;AACA,mD;AACA,a;;AAEA,qC;AACA,a;;AAEA,0C;AACA,yE;AACA,K;AACA,E;;AAEA,iD;AACA,8C;AACA,iB;AACA,uC;AACA,6B;AACA,gD;AACA,oB;AACA,oB;AACA,0C;AACA,gD;AACA,O;AACA,kB;AACA,sC;AACA,2B;AACA,4D;AACA,0B;AACA,kF;AACA,U;AACA,gB;AACA,G;AACA,E;;AAEA,kB;;AAEA,gC;AACA,kC;AACA,yD;AACA,sD;AACA,8C;AACA,2C;AACA,gD;AACA,2C;AACA,0D;AACA,6D;AACA,0C;AACA,gD;AACA,6C;AACA,6C;AACA,+C;AACA,4C;AACA,8C;AACA,kD;AACA,wD;AACA,wD;AACA,E;;AAEA,4C;AACA,mD;AACA,6C;AACA,E;;AAEA,2B;;AAEA,sD;AACA,kB;AACA,qC;AACA,+B;AACA,E;;AAEA,sE;AACA,yE;AACA,0E;AACA,kB;;AAEA,iF;AACA,qC;AACA,kD;AACA,+C;AACA,0C;AACA,c;AACA,qB;AACA,wB;AACA,+B;AACA,iD;AACA,yC;AACA,mD;AACA,G;;AAEA,mE;AACA,4C;AACA,8B;AACA,0D;;AAEA,wE;AACA,gC;AACA,K;AACA,oE;AACA,mE;AACA,sD;AACA,sG;AACA,mE;AACA,kE;AACA,qD;AACA,4B;AACA,6G;AACA,G;AACA,2D;AACA,0D;AACA,6C;AACA,iB;AACA,8I;AACA,G;AACA,2D;AACA,0D;AACA,6C;AACA,4B;AACA,uJ;AACA,G;AACA,iB;AACA,sC;AACA,G;;AAEA,wE;AACA,sC;AACA,wD;AACA,4C;AACA,0D;AACA,G;AACA,4C;AACA,0D;AACA,G;AACA,2C;AACA,2D;AACA,G;AACA,oB;AACA,oB;AACA,kC;AACA,gB;AACA,G;AACA,kC;AACA,gB;AACA,G;AACA,iD;AACA,qC;AACA,gE;AACA,K;AACA,qC;AACA,gE;AACA,K;AACA,U;AACA,qC;AACA,8C;AACA,K;AACA,qC;AACA,8C;AACA,K;AACA,G;AACA,qC;AACA,uD;AACA,G;;AAEA,2B;AACA,iB;AACA,E;;AAEA,qE;AACA,oC;AACA,wE;AACA,kD;AACA,kB;;AAEA,wC;AACA,sD;;AAEA,uD;AACA,4B;AACA,kB;AACA,K;AACA,I;AACA,yB;AACA,mD;AACA,gC;AACA,0C;AACA,2C;;AAEA,mE;AACA,oE;AACA,8C;AACA,wC;AACA,qB;;AAEA,kB;AACA,uC;AACA,oB;AACA,K;;AAEA,iB;AACA,K;AACA,E;;AAEA,gD;AACA,iD;AACA,E;;AAEA,iE;AACA,kB;AACA,mB;AACA,8C;AACA,G;AACA,yD;AACA,E;;AAEA,wD;AACA,kC;AACA,E;;AAEA,0D;AACA,oC;AACA,E;;AAEA,uE;AACA,kB;AACA,mB;AACA,oD;AACA,G;AACA,+D;AACA,E;;AAEA,8D;AACA,wC;AACA,E;;AAEA,+D;AACA,kB;AACA,mB;AACA,4C;AACA,G;AACA,uD;AACA,E;;AAEA,sD;AACA,gC;AACA,E;;AAEA,mB;AACA,yC;AACA,0E;AACA,iE;AACA,wB;AACA,sF;AACA,8B;AACA,K;AACA,iB;AACA,G;AACA,wB;AACA,2D;AACA,iD;AACA,oC;AACA,8B;AACA,yB;AACA,c;AACA,0D;AACA,O;AACA,K;AACA,iB;AACA,G;AACA,e;AACA,E;;AAEA,gF;AACA,mC;AACA,4E;AACA,E;;AAEA,mC;AACA,wB;AACA,iE;AACA,kB;AACA,K;AACA,G;AACA,e;AACA,E;;AAEA,uC;AACA,mC;AACA,e;AACA,gB;AACA,G;AACA,4B;AACA,e;AACA,gB;AACA,G;AACA,mD;AACA,E;;AAEA,sC;;AAEA,2C;AACA,6D;AACA,+D;AACA,wB;AACA,oC;;AAEA,iE;AACA,0D;AACA,2C;AACA,8B;AACA,Y;AACA,qD;AACA,K;;AAEA,oD;AACA,wD;AACA,8B;AACA,yC;AACA,sD;AACA,yC;AACA,O;;AAEA,K;;AAEA,0D;AACA,0D;AACA,0B;AACA,oD;;AAEA,sB;AACA,E;;AAEA,qC;AACA,mD;AACA,qC;AACA,kB;AACA,a;AACA,a;AACA,6C;AACA,gB;AACA,sB;AACA,wB;AACA,sD;AACA,kB;AACA,yB;AACA,0B;AACA,Y;AACA,a;AACA,K;AACA,mD;AACA,mD;AACA,sC;AACA,8B;AACA,gC;AACA,O;AACA,K;AACA,gB;AACA,E;;AAEA,0C;AACA,6C;AACA,oD;AACA,mD;AACA,uC;AACA,iC;AACA,6B;AACA,O;AACA,gC;AACA,2C;AACA,O;AACA,sB;AACA,0C;AACA,O;AACA,sC;AACA,2C;AACA,sC;AACA,O;AACA,2C;AACA,sC;AACA,O;AACA,qD;AACA,0D;AACA,O;AACA,sD;AACA,4D;AACA,O;AACA,+C;AACA,8C;AACA,O;AACA,6C;AACA,0C;AACA,O;AACA,8C;AACA,uB;AACA,iG;AACA,gC;AACA,S;AACA,K;AACA,K;AACA,E;;AAEA,G;AACA,qB;AACA,yE;AACA,0E;AACA,yB;AACA,oC;AACA,G;AACA,wC;AACA,6D;;AAEA,qB;AACA,6C;AACA,uC;AACA,wB;AACA,6C;;AAEA,2C;AACA,yD;AACA,iB;AACA,O;AACA,yF;AACA,+D;AACA,+F;AACA,0F;AACA,O;AACA,6E;AACA,Y;AACA,gG;AACA,iE;AACA,O;AACA,K;AACA,K;;AAEA,4D;AACA,4B;AACA,2B;AACA,qD;AACA,K;AACA,G;;AAEA,6D;AACA,6B;AACA,2B;AACA,mD;AACA,K;AACA,G;;AAEA,oB;AACA,4B;;AAEA,gB;AACA,E;;AAEA,kD;AACA,0B;AACA,qD;AACA,sD;AACA,kD;AACA,qC;AACA,c;AACA,kC;AACA,Y;AACA,a;AACA,K;;AAEA,mB;AACA,gD;AACA,gD;AACA,+D;AACA,gD;AACA,wC;AACA,S;AACA,O;AACA,O;AACA,iC;AACA,K;AACA,e;AACA,E;;AAEA,gE;AACA,0C;AACA,6D;AACA,0B;AACA,4C;AACA,wB;AACA,qC;AACA,kC;AACA,K;AACA,G;AACA,sB;AACA,gB;AACA,+B;AACA,E;;AAEA,0C;AACA,mB;AACA,oB;AACA,G;AACA,E;;AAEA,G;AACA,wB;AACA,Y;AACA,4B;AACA,8D;AACA,6H;AACA,uB;AACA,G;AACA,wE;AACA,qE;AACA,G;AACA,oE;AACA,kB;AACA,oB;;AAEA,4E;AACA,sE;AACA,iF;AACA,G;AACA,E;AACA,wB;AACA,+B;AACA,8C;AACA,0C;AACA,a;AACA,+C;AACA,kF;AACA,wB;AACA,wC;AACA,qC;AACA,yB;AACA,uB;AACA,Q;AACA,wB;AACA,8B;AACA,8B;AACA,sD;AACA,gB;AACA,4C;AACA,+B;AACA,4C;AACA,U;AACA,Q;AACA,qC;AACA,wE;AACA,gB;AACA,4C;AACA,+B;AACA,4C;AACA,U;AACA,O;AACA,0D;;AAEA,4D;AACA,+B;;AAEA,+B;AACA,oB;AACA,mD;AACA,O;AACA,a;AACA,K;;AAEA,0E;AACA,+B;AACA,qB;AACA,gC;AACA,kC;AACA,2E;AACA,mB;AACA,oC;AACA,gB;AACA,S;AACA,O;AACA,K;;AAEA,oD;AACA,iE;AACA,kB;AACA,2B;AACA,K;;AAEA,0B;AACA,a;AACA,iD;AACA,uE;AACA,Y;AACA,yD;AACA,K;AACA,G;;AAEA,sD;AACA,kD;AACA,I;AACA,uE;AACA,kE;AACA,wC;AACA,yE;AACA,wD;AACA,mE;AACA,kC;AACA,4D;AACA,Y;AACA,M;AACA,uD;AACA,4D;AACA,M;AACA,gE;AACA,6B;AACA,wB;AACA,uB;AACA,4B;AACA,O;AACA,M;AACA,oE;AACA,Y;AACA,wB;AACA,uB;AACA,4B;AACA,yB;AACA,kD;AACA,gB;AACA,8D;AACA,S;AACA,O;AACA,I;AACA,K;;AAEA,0C;AACA,kB;AACA,uE;AACA,mE;AACA,sC;AACA,2C;AACA,e;AACA,O;AACA,K;AACA,C;;AAEA,4D;AACA,8C;AACA,oE;AACA,kF;AACA,E;;;;;;;;;;;;;;;;;;;ACxhCA,E;AACA,a;AACA,G;;AAEA,8C;AACA,kB;AACA,0B;AACA,6B;AACA,0C;AACA,yB;AACA,kC;AACA,kB;AACA,sC;AACA,2C;AACA,2C;AACA,K;AACA,E;;AAEA,2F;AACA,2E;AACA,kB;AACA,sB;AACA,oB;AACA,kB;AACA,6B;AACA,oB;;AAEA,4E;AACA,2E;AACA,sF;AACA,G;;AAEA,iI;;AAEA,iD;;AAEA,uE;AACA,gF;AACA,uD;;AAEA,U;AACA,kC;;AAEA,yC;AACA,qD;;AAEA,oC;AACA,oD;AACA,qC;;AAEA,yD;AACA,wC;AACA,E;;AAEA,2F;AACA,uF;AACA,kB;AACA,sB;AACA,oB;AACA,kB;AACA,6B;AACA,oB;;AAEA,4E;AACA,2E;AACA,sF;AACA,G;;AAEA,oI;;AAEA,iD;;AAEA,8D;AACA,0B;AACA,kE;AACA,6B;AACA,6B;AACA,6B;AACA,K;AACA,G;AACA,qC;;AAEA,4C;AACA,4D;AACA,uB;AACA,8B;AACA,G;;AAEA,oG;AACA,mC;;AAEA,yD;AACA,sC;AACA,E;;AAEA,6B;AACA,sE;AACA,kB;AACA,uD;AACA,yB;AACA,qC;AACA,E;;AAEA,8D;AACA,kB;AACA,yB;AACA,mC;AACA,E;;AAEA,kE;AACA,kB;AACA,yB;AACA,2B;AACA,E;;AAEA,2E;AACA,kB;;AAEA,gC;AACA,W;;AAEA,uB;AACA,yC;AACA,uC;AACA,wC;AACA,K;;AAEA,qC;AACA,E;;AAEA,2E;AACA,kB;;AAEA,4B;AACA,W;;AAEA,+B;AACA,sD;AACA,oC;AACA,wC;AACA,K;AACA,K;AACA,0B;AACA,E;;AAEA,qF;AACA,kB;AACA,+D;AACA,yE;AACA,kH;AACA,+C;AACA,E;;AAEA,uE;AACA,iE;AACA,mC;AACA,+C;AACA,E;;AAEA,0E;AACA,iE;AACA,8B;AACA,mC;AACA,E;AACA,8D;AACA,kB;AACA,mE;AACA,oB;AACA,gB;AACA,K;AACA,G;;AAEA,mC;AACA,a;AACA,c;AACA,G;AACA,E;AACA,+E;AACA,E;;AAEA,E;AACA,U;AACA,G;;AAEA,kG;AACA,mB;;AAEA,4E;AACA,yB;AACA,2F;AACA,G;;AAEA,mB;AACA,yB;AACA,6G;AACA,Y;AACA,6D;AACA,2C;AACA,S;AACA,iC;AACA,0G;AACA,O;;AAEA,gF;AACA,8F;AACA,K;AACA,sC;AACA,qH;AACA,G;;AAEA,iE;AACA,sE;AACA,mD;AACA,8B;AACA,mB;AACA,gC;AACA,sD;AACA,K;AACA,4B;AACA,G;;AAEA,uB;AACA,uD;;AAEA,qD;AACA,4G;;AAEA,uE;AACA,e;AACA,iF;AACA,a;AACA,K;;AAEA,oE;AACA,+E;AACA,6D;AACA,uE;AACA,6D;AACA,4D;AACA,8C;AACA,U;AACA,0B;AACA,2B;AACA,uG;AACA,kC;AACA,W;AACA,8E;AACA,e;AACA,O;AACA,K;;AAEA,wE;AACA,4E;AACA,2E;AACA,a;AACA,K;;AAEA,0D;AACA,gD;AACA,a;AACA,K;;AAEA,kE;AACA,qB;;AAEA,gD;AACA,iD;AACA,sB;AACA,4E;AACA,e;AACA,O;;AAEA,gD;AACA,qE;AACA,+E;AACA,e;AACA,O;;AAEA,K;;AAEA,4D;AACA,kE;AACA,0F;AACA,6E;AACA,a;AACA,K;;AAEA,gC;AACA,+C;AACA,kF;AACA,oD;AACA,oF;AACA,6C;AACA,+C;AACA,yB;AACA,uC;AACA,wB;AACA,gC;AACA,mB;AACA,qB;AACA,gC;AACA,uG;AACA,wD;AACA,kB;AACA,8C;AACA,iC;AACA,sC;AACA,Y;AACA,U;AACA,uC;AACA,uG;AACA,0E;AACA,kB;AACA,8C;AACA,iC;AACA,sC;AACA,Y;AACA,S;AACA,iI;AACA,0C;AACA,4E;AACA,qB;AACA,O;AACA,kB;AACA,O;AACA,G;;AAEA,2B;AACA,mG;AACA,0D;;AAEA,gD;AACA,0E;AACA,6B;AACA,yB;AACA,K;;AAEA,sB;;AAEA,uC;AACA,4E;AACA,2B;AACA,sE;AACA,oE;AACA,oE;AACA,mD;AACA,0B;AACA,gB;AACA,2C;AACA,S;AACA,2C;AACA,O;;AAEA,iE;AACA,wC;AACA,kE;AACA,0C;;AAEA,iE;AACA,+D;AACA,iB;AACA,qD;;AAEA,6E;AACA,Y;AACA,gD;AACA,+B;AACA,oF;AACA,wC;AACA,W;AACA,yC;;AAEA,oC;AACA,qB;AACA,gB;AACA,wF;AACA,S;AACA,O;;AAEA,wC;AACA,oG;AACA,8G;AACA,O;AACA,K;;AAEA,2D;AACA,2D;AACA,wC;AACA,+F;AACA,e;AACA,K;;AAEA,0B;AACA,yB;AACA,kC;AACA,+D;AACA,S;AACA,K;;AAEA,+B;AACA,6D;AACA,oE;;AAEA,iC;AACA,gC;;AAEA,mE;;AAEA,8E;AACA,wD;AACA,iE;;AAEA,qF;AACA,sE;AACA,uE;AACA,6E;AACA,6D;AACA,O;;AAEA,wB;AACA,6G;;AAEA,kE;AACA,2C;AACA,8F;;AAEA,0C;AACA,yC;AACA,+B;AACA,uE;AACA,0E;AACA,sC;AACA,4D;AACA,+D;AACA,a;AACA,8H;AACA,S;AACA,S;AACA,K;;AAEA,G;;AAEA,4B;AACA,gB;;AAEA,oD;AACA,2B;AACA,wD;AACA,oD;AACA,wC;AACA,kB;AACA,K;AACA,iB;AACA,K;;AAEA,qB;AACA,E;;AAEA,gD;AACA,8B;;AAEA,wC;AACA,oB;AACA,oB;AACA,kC;AACA,gB;AACA,G;AACA,kC;AACA,gB;AACA,G;;AAEA,kB;AACA,gC;AACA,uC;AACA,8B;AACA,uD;AACA,yB;AACA,uD;AACA,yB;AACA,0E;AACA,qB;AACA,sC;AACA,qB;AACA,0C;AACA,iC;AACA,oC;AACA,uB;AACA,S;AACA,oB;AACA,S;AACA,qB;AACA,0B;AACA,K;AACA,G;;AAEA,kB;AACA,qC;AACA,0D;AACA,8B;AACA,iE;AACA,yB;AACA,iE;AACA,yB;AACA,uE;AACA,yB;AACA,K;AACA,G;;AAEA,mB;AACA,sC;AACA,wC;AACA,+B;AACA,K;AACA,G;;AAEA,kB;AACA,qC;AACA,mC;AACA,8B;AACA,K;AACA,G;;AAEA,iB;AACA,oC;AACA,+B;AACA,6B;AACA,yE;AACA,wB;AACA,yE;AACA,wB;AACA,K;AACA,G;;AAEA,gC;AACA,4E;;AAEA,iC;AACA,8C;AACA,mC;AACA,K;;AAEA,kB;AACA,qC;AACA,gE;AACA,yB;AACA,uE;AACA,yB;AACA,O;AACA,K;AACA,G;;AAEA,E;;AAEA,E;AACA,U;AACA,G;;AAEA,oD;AACA,wB;AACA,uB;AACA,U;AACA,yD;AACA,G;AACA,E;;AAEA,iC;AACA,2B;AACA,oE;AACA,G;AACA,mE;AACA,E;;AAEA,6B;AACA,gC;AACA,iB;AACA,G;AACA,6B;AACA,E;;AAEA,4C;AACA,0D;AACA,E;;AAEA,mC;AACA,wC;AACA,E;;AAEA,mE;AACA,iF;AACA,+E;AACA,2H;AACA,E;;AAEA,iF;AACA,mC;AACA,4E;AACA,E;;AAEA,2E;AACA,yB;AACA,mC;AACA,mE;AACA,yE;AACA,yE;AACA,sF;AACA,E;;AAEA,2B;AACA,wC;AACA,E","sourcesContent":["/*\nstring.js - Copyright (C) 2012-2013, JP Richardson <jprichardson@gmail.com>\n*/\n\n!(function() {\n  \"use strict\";\n\n  var VERSION = '1.5.0';\n\n  var ENTITIES = {};\n\n  function S(s) {\n    if (s !== null && s !== undefined) {\n      if (typeof s === 'string')\n        this.s = s;\n      else\n        this.s = s.toString();\n    } else {\n      this.s = s; //null or undefined\n    }\n\n    this.orig = s; //original object, currently only used by toCSV() and toBoolean()\n\n    if (s !== null && s !== undefined) {\n      if (this.__defineGetter__) {\n        this.__defineGetter__('length', function() {\n          return this.s.length;\n        })\n      } else {\n        this.length = s.length;\n      }\n    } else {\n      this.length = -1;\n    }\n  }\n\n  var __nsp = String.prototype;\n  var __sp = S.prototype = {\n\n    between: function(left, right) {\n      var s = this.s;\n      var startPos = s.indexOf(left);\n      var endPos = s.indexOf(right);\n      var start = startPos + left.length;\n      return new S(endPos > startPos ?  s.slice(start, endPos) : \"\");\n    },\n\n    //# modified slightly from https://github.com/epeli/underscore.string\n    camelize: function() {\n      var s = this.trim().s.replace(/(\\-|_|\\s)+(.)?/g, function(mathc, sep, c) {\n        return (c ? c.toUpperCase() : '');\n      });\n      return new S(s);\n    },\n\n    capitalize: function() {\n      return new S(this.s.substr(0, 1).toUpperCase() + this.s.substring(1).toLowerCase());\n    },\n\n    charAt: function(index) {\n      return this.s.charAt(index);\n    },\n\n    chompLeft: function(prefix) {\n      var s = this.s;\n      if (s.indexOf(prefix) === 0) {\n         s = s.slice(prefix.length);\n         return new S(s);\n      } else {\n        return this;\n      }\n    },\n\n    chompRight: function(suffix) {\n      if (this.endsWith(suffix)) {\n        var s = this.s;\n        s = s.slice(0, s.length - suffix.length);\n        return new S(s);\n      } else {\n        return this;\n      }\n    },\n\n    //#thanks Google\n    collapseWhitespace: function() {\n      var s = this.s.replace(/[\\s\\xa0]+/g, ' ').replace(/^\\s+|\\s+$/g, '');\n      return new S(s);\n    },\n\n    contains: function(ss) {\n      return this.s.indexOf(ss) >= 0;\n    },\n\n    count: function(ss) {\n      var count = 0\n        , pos = this.s.indexOf(ss)\n\n      while (pos >= 0) {\n        count += 1\n        pos = this.s.indexOf(ss, pos + 1)\n      }\n\n      return count\n    },\n\n    //#modified from https://github.com/epeli/underscore.string\n    dasherize: function() {\n      var s = this.trim().s.replace(/[_\\s]+/g, '-').replace(/([A-Z])/g, '-$1').replace(/-+/g, '-').toLowerCase();\n      return new S(s);\n    },\n\n    decodeHtmlEntities: function() { //https://github.com/substack/node-ent/blob/master/index.js\n      var s = this.s;\n      s = s.replace(/&#(\\d+);?/g, function (_, code) {\n        return String.fromCharCode(code);\n      })\n      .replace(/&#[xX]([A-Fa-f0-9]+);?/g, function (_, hex) {\n        return String.fromCharCode(parseInt(hex, 16));\n      })\n      .replace(/&([^;\\W]+;?)/g, function (m, e) {\n        var ee = e.replace(/;$/, '');\n        var target = ENTITIES[e] || (e.match(/;$/) && ENTITIES[ee]);\n            \n        if (typeof target === 'number') {\n          return String.fromCharCode(target);\n        }\n        else if (typeof target === 'string') {\n          return target;\n        }\n        else {\n          return m;\n        }\n      })\n\n      return new S(s);\n    },\n\n    endsWith: function(suffix) {\n      var l  = this.s.length - suffix.length;\n      return l >= 0 && this.s.indexOf(suffix, l) === l;\n    },\n\n    escapeHTML: function() { //from underscore.string\n      return new S(this.s.replace(/[&<>\"']/g, function(m){ return '&' + reversedEscapeChars[m] + ';'; }));\n    },\n\n    ensureLeft: function(prefix) {\n      var s = this.s;\n      if (s.indexOf(prefix) === 0) {\n        return this;\n      } else {\n        return new S(prefix + s);\n      }\n    },\n\n    ensureRight: function(suffix) {\n      var s = this.s;\n      if (this.endsWith(suffix))  {\n        return this;\n      } else {\n        return new S(s + suffix);\n      }\n    },\n\n    humanize: function() { //modified from underscore.string\n      if (this.s === null || this.s === undefined)\n        return new S('')\n      var s = this.underscore().replace(/_id$/,'').replace(/_/g, ' ').trim().capitalize()\n      return new S(s)\n    },\n\n    isAlpha: function() {\n      return !/[^a-z\\xC0-\\xFF]/.test(this.s.toLowerCase());\n    },\n\n    isAlphaNumeric: function() {\n      return !/[^0-9a-z\\xC0-\\xFF]/.test(this.s.toLowerCase());\n    },\n\n    isEmpty: function() {\n      return this.s === null || this.s === undefined ? true : /^[\\s\\xa0]*$/.test(this.s);\n    },\n\n    isLower: function() {\n      return this.isAlpha() && this.s.toLowerCase() === this.s;\n    },\n\n    isNumeric: function() {\n      return !/[^0-9]/.test(this.s);\n    },\n\n    isUpper: function() {\n      return this.isAlpha() && this.s.toUpperCase() === this.s;\n    },\n\n    left: function(N) {\n      if (N >= 0) {\n        var s = this.s.substr(0, N);\n        return new S(s);\n      } else {\n        return this.right(-N);\n      }\n    },\n    \n    lines: function() { //convert windows newlines to unix newlines then convert to an Array of lines\n      return this.replaceAll('\\r\\n', '\\n').s.split('\\n');\n    },\n\n    pad: function(len, ch) { //https://github.com/component/pad\n      ch = ch || ' ';\n      if (this.s.length >= len) return new S(this.s);\n      len = len - this.s.length;\n      var left = Array(Math.ceil(len / 2) + 1).join(ch);\n      var right = Array(Math.floor(len / 2) + 1).join(ch);\n      return new S(left + this.s + right);\n    },\n\n    padLeft: function(len, ch) { //https://github.com/component/pad\n      ch = ch || ' ';\n      if (this.s.length >= len) return new S(this.s);\n      return new S(Array(len - this.s.length + 1).join(ch) + this.s);\n    },\n\n    padRight: function(len, ch) { //https://github.com/component/pad\n      ch = ch || ' ';\n      if (this.s.length >= len) return new S(this.s);\n      return new S(this.s + Array(len - this.s.length + 1).join(ch));\n    },\n\n    parseCSV: function(delimiter, qualifier, escape, lineDelimiter) { //try to parse no matter what\n      delimiter = delimiter || ',';\n      escape = escape || '\\\\'\n      if (typeof qualifier == 'undefined')\n        qualifier = '\"';\n\n      var i = 0, fieldBuffer = [], fields = [], len = this.s.length, inField = false, self = this;\n      var ca = function(i){return self.s.charAt(i)};\n      if (typeof lineDelimiter !== 'undefined') var rows = [];\n\n      if (!qualifier)\n        inField = true;\n\n      while (i < len) {\n        var current = ca(i);\n        switch (current) {\n          case escape:\n          //fix for issues #32 and #35\n          if (inField && ((escape !== qualifier) || ca(i+1) === qualifier)) {\n              i += 1;\n              fieldBuffer.push(ca(i));\n              break;\n          }\n          if (escape !== qualifier) break;\n          case qualifier:\n            inField = !inField;\n            break;\n          case delimiter:\n            if (inField && qualifier)\n              fieldBuffer.push(current);\n            else {\n              fields.push(fieldBuffer.join(''))\n              fieldBuffer.length = 0;\n            }\n            break;\n          case lineDelimiter:\n            if (inField) {\n                fieldBuffer.push(current);\n            } else {\n                if (rows) {\n                    fields.push(fieldBuffer.join(''))\n                    rows.push(fields);\n                    fields = [];\n                    fieldBuffer.length = 0;\n                }\n            }\n            break;\n          default:\n            if (inField)\n              fieldBuffer.push(current);\n            break;\n        }\n        i += 1;\n      }\n\n      fields.push(fieldBuffer.join(''));\n      if (rows) {\n        rows.push(fields);\n        return rows;\n      }\n      return fields;\n    },\n\n    replaceAll: function(ss, r) {\n      //var s = this.s.replace(new RegExp(ss, 'g'), r);\n      var s = this.s.split(ss).join(r)\n      return new S(s);\n    },\n\n    right: function(N) {\n      if (N >= 0) {\n        var s = this.s.substr(this.s.length - N, N);\n        return new S(s);\n      } else {\n        return this.left(-N);\n      }\n    },\n\n    slugify: function() {\n      var sl = (new S(this.s.replace(/[^\\w\\s-]/g, '').toLowerCase())).dasherize().s;\n      if (sl.charAt(0) === '-')\n        sl = sl.substr(1);\n      return new S(sl);\n    },\n\n    startsWith: function(prefix) {\n      return this.s.lastIndexOf(prefix, 0) === 0;\n    },\n\n    stripPunctuation: function() {\n      //return new S(this.s.replace(/[\\.,-\\/#!$%\\^&\\*;:{}=\\-_`~()]/g,\"\"));\n      return new S(this.s.replace(/[^\\w\\s]|_/g, \"\").replace(/\\s+/g, \" \"));\n    },\n\n    stripTags: function() { //from sugar.js\n      var s = this.s, args = arguments.length > 0 ? arguments : [''];\n      multiArgs(args, function(tag) {\n        s = s.replace(RegExp('<\\/?' + tag + '[^<>]*>', 'gi'), '');\n      });\n      return new S(s);\n    },\n\n    template: function(values, opening, closing) {\n      var s = this.s\n      var opening = opening || Export.TMPL_OPEN\n      var closing = closing || Export.TMPL_CLOSE\n      var r = new RegExp(opening + '(.+?)' + closing, 'g')\n        //, r = /\\{\\{(.+?)\\}\\}/g\n      var matches = s.match(r) || [];\n\n      matches.forEach(function(match) {\n        var key = match.substring(opening.length, match.length - closing.length);//chop {{ and }}\n        if (values[key])\n          s = s.replace(match, values[key]);\n      });\n      return new S(s);\n    },\n\n    times: function(n) {\n      return new S(new Array(n + 1).join(this.s));\n    },\n\n    toBoolean: function() {\n      if (typeof this.orig === 'string') {\n        var s = this.s.toLowerCase();\n        return s === 'true' || s === 'yes' || s === 'on';\n      } else\n        return this.orig === true || this.orig === 1;\n    },\n\n    toFloat: function(precision) {\n      var num = parseFloat(this.s)\n      if (precision)\n        return parseFloat(num.toFixed(precision))\n      else\n        return num\n    },\n\n    toInt: function() { //thanks Google\n      // If the string starts with '0x' or '-0x', parse as hex.\n      return /^\\s*-?0x/i.test(this.s) ? parseInt(this.s, 16) : parseInt(this.s, 10)\n    },\n\n    trim: function() {\n      var s;\n      if (typeof __nsp.trim === 'undefined') \n        s = this.s.replace(/(^\\s*|\\s*$)/g, '')\n      else \n        s = this.s.trim()\n      return new S(s);\n    },\n\n    trimLeft: function() {\n      var s;\n      if (__nsp.trimLeft)\n        s = this.s.trimLeft();\n      else\n        s = this.s.replace(/(^\\s*)/g, '');\n      return new S(s);\n    },\n\n    trimRight: function() {\n      var s;\n      if (__nsp.trimRight)\n        s = this.s.trimRight();\n      else\n        s = this.s.replace(/\\s+$/, '');\n      return new S(s);\n    },\n\n    truncate: function(length, pruneStr) { //from underscore.string, author: github.com/rwz\n      var str = this.s;\n\n      length = ~~length;\n      pruneStr = pruneStr || '...';\n\n      if (str.length <= length) return new S(str);\n\n      var tmpl = function(c){ return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' '; },\n        template = str.slice(0, length+1).replace(/.(?=\\W*\\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'\n\n      if (template.slice(template.length-2).match(/\\w\\w/))\n        template = template.replace(/\\s*\\S+$/, '');\n      else\n        template = new S(template.slice(0, template.length-1)).trimRight().s;\n\n      return (template+pruneStr).length > str.length ? new S(str) : new S(str.slice(0, template.length)+pruneStr);\n    },\n\n    toCSV: function() {\n      var delim = ',', qualifier = '\"', escape = '\\\\', encloseNumbers = true, keys = false;\n      var dataArray = [];\n\n      function hasVal(it) {\n        return it !== null && it !== '';\n      }\n\n      if (typeof arguments[0] === 'object') {\n        delim = arguments[0].delimiter || delim;\n        delim = arguments[0].separator || delim;\n        qualifier = arguments[0].qualifier || qualifier;\n        encloseNumbers = !!arguments[0].encloseNumbers;\n        escape = arguments[0].escape || escape;\n        keys = !!arguments[0].keys;\n      } else if (typeof arguments[0] === 'string') {\n        delim = arguments[0];\n      }\n\n      if (typeof arguments[1] === 'string')\n        qualifier = arguments[1];\n\n      if (arguments[1] === null)\n        qualifier = null;\n\n       if (this.orig instanceof Array)\n        dataArray  = this.orig;\n      else { //object\n        for (var key in this.orig)\n          if (this.orig.hasOwnProperty(key))\n            if (keys)\n              dataArray.push(key);\n            else\n              dataArray.push(this.orig[key]);\n      }\n\n      var rep = escape + qualifier;\n      var buildString = [];\n      for (var i = 0; i < dataArray.length; ++i) {\n        var shouldQualify = hasVal(qualifier)\n        if (typeof dataArray[i] == 'number')\n          shouldQualify &= encloseNumbers;\n        \n        if (shouldQualify)\n          buildString.push(qualifier);\n        \n        if (dataArray[i] !== null && dataArray[i] !== undefined) {\n          var d = new S(dataArray[i]).replaceAll(qualifier, rep).s;\n          buildString.push(d);\n        } else \n          buildString.push('')\n\n        if (shouldQualify)\n          buildString.push(qualifier);\n        \n        if (delim)\n          buildString.push(delim);\n      }\n\n      //chop last delim\n      //console.log(buildString.length)\n      buildString.length = buildString.length - 1;\n      return new S(buildString.join(''));\n    },\n\n    toString: function() {\n      return this.s;\n    },\n\n    //#modified from https://github.com/epeli/underscore.string\n    underscore: function() {\n      var s = this.trim().s.replace(/([a-z\\d])([A-Z]+)/g, '$1_$2').replace(/[-\\s]+/g, '_').toLowerCase();\n      if ((new S(this.s.charAt(0))).isUpper()) {\n        s = '_' + s;\n      }\n      return new S(s);\n    },\n\n    unescapeHTML: function() { //from underscore.string\n      return new S(this.s.replace(/\\&([^;]+);/g, function(entity, entityCode){\n        var match;\n\n        if (entityCode in escapeChars) {\n          return escapeChars[entityCode];\n        } else if (match = entityCode.match(/^#x([\\da-fA-F]+)$/)) {\n          return String.fromCharCode(parseInt(match[1], 16));\n        } else if (match = entityCode.match(/^#(\\d+)$/)) {\n          return String.fromCharCode(~~match[1]);\n        } else {\n          return entity;\n        }\n      }));\n    },\n\n    valueOf: function() {\n      return this.s.valueOf();\n    }\n\n  }\n\n  var methodsAdded = [];\n  function extendPrototype() {\n    for (var name in __sp) {\n      (function(name){\n        var func = __sp[name];\n        if (!__nsp.hasOwnProperty(name)) {\n          methodsAdded.push(name);\n          __nsp[name] = function() {\n            String.prototype.s = this;\n            return func.apply(this, arguments);\n          }\n        }\n      })(name);\n    }\n  }\n\n  function restorePrototype() {\n    for (var i = 0; i < methodsAdded.length; ++i)\n      delete String.prototype[methodsAdded[i]];\n    methodsAdded.length = 0;\n  }\n\n\n/*************************************\n/* Attach Native JavaScript String Properties\n/*************************************/\n\n  var nativeProperties = getNativeStringProperties();\n  for (var name in nativeProperties) {\n    (function(name) {\n      var stringProp = __nsp[name];\n      if (typeof stringProp == 'function') {\n        //console.log(stringProp)\n        if (!__sp[name]) {\n          if (nativeProperties[name] === 'string') {\n            __sp[name] = function() {\n              //console.log(name)\n              return new S(stringProp.apply(this, arguments));\n            }\n          } else {\n            __sp[name] = stringProp;\n          }\n        }\n      }\n    })(name);\n  }\n\n\n/*************************************\n/* Function Aliases\n/*************************************/\n\n  __sp.repeat = __sp.times;\n  __sp.include = __sp.contains;\n  __sp.toInteger = __sp.toInt;\n  __sp.toBool = __sp.toBoolean;\n  __sp.decodeHTMLEntities = __sp.decodeHtmlEntities //ensure consistent casing scheme of 'HTML'\n\n\n/*************************************\n/* Private Functions\n/*************************************/\n\n  function getNativeStringProperties() {\n    var names = getNativeStringPropertyNames();\n    var retObj = {};\n\n    for (var i = 0; i < names.length; ++i) {\n      var name = names[i];\n      var func = __nsp[name];\n      try {\n        var type = typeof func.apply('teststring', []);\n        retObj[name] = type;\n      } catch (e) {}\n    }\n    return retObj;\n  }\n\n  function getNativeStringPropertyNames() {\n    var results = [];\n    if (Object.getOwnPropertyNames) {\n      results = Object.getOwnPropertyNames(__nsp);\n      results.splice(results.indexOf('valueOf'), 1);\n      results.splice(results.indexOf('toString'), 1);\n      return results;\n    } else { //meant for legacy cruft, this could probably be made more efficient\n      var stringNames = {};\n      var objectNames = [];\n      for (var name in String.prototype)\n        stringNames[name] = name;\n\n      for (var name in Object.prototype)\n        delete stringNames[name];\n\n      //stringNames['toString'] = 'toString'; //this was deleted with the rest of the object names\n      for (var name in stringNames) {\n        results.push(name);\n      }\n      return results;\n    }\n  }\n\n  function Export(str) {\n    return new S(str);\n  };\n\n  //attach exports to StringJSWrapper\n  Export.extendPrototype = extendPrototype;\n  Export.restorePrototype = restorePrototype;\n  Export.VERSION = VERSION;\n  Export.TMPL_OPEN = '{{';\n  Export.TMPL_CLOSE = '}}';\n  Export.ENTITIES = ENTITIES;\n\n\n\n/*************************************\n/* Exports\n/*************************************/\n\n  if (typeof module !== 'undefined'  && typeof module.exports !== 'undefined') {\n    module.exports = Export;\n\n  } else {\n\n    if(typeof define === \"function\" && define.amd) {\n      define([], function() {\n        return Export;\n      });\n    } else {\n      window.S = Export;\n    }\n  }\n\n\n/*************************************\n/* 3rd Party Private Functions\n/*************************************/\n\n  //from sugar.js\n  function multiArgs(args, fn) {\n    var result = [], i;\n    for(i = 0; i < args.length; i++) {\n      result.push(args[i]);\n      if(fn) fn.call(args, args[i], i);\n    }\n    return result;\n  }\n\n  //from underscore.string\n  var escapeChars = {\n    lt: '<',\n    gt: '>',\n    quot: '\"',\n    apos: \"'\",\n    amp: '&'\n  };\n\n  //from underscore.string\n  var reversedEscapeChars = {};\n  for(var key in escapeChars){ reversedEscapeChars[escapeChars[key]] = key; }\n\n  ENTITIES = {\n    \"amp\" : \"&\",\n    \"gt\" : \">\",\n    \"lt\" : \"<\",\n    \"quot\" : \"\\\"\",\n    \"apos\" : \"'\",\n    \"AElig\" : 198,\n    \"Aacute\" : 193,\n    \"Acirc\" : 194,\n    \"Agrave\" : 192,\n    \"Aring\" : 197,\n    \"Atilde\" : 195,\n    \"Auml\" : 196,\n    \"Ccedil\" : 199,\n    \"ETH\" : 208,\n    \"Eacute\" : 201,\n    \"Ecirc\" : 202,\n    \"Egrave\" : 200,\n    \"Euml\" : 203,\n    \"Iacute\" : 205,\n    \"Icirc\" : 206,\n    \"Igrave\" : 204,\n    \"Iuml\" : 207,\n    \"Ntilde\" : 209,\n    \"Oacute\" : 211,\n    \"Ocirc\" : 212,\n    \"Ograve\" : 210,\n    \"Oslash\" : 216,\n    \"Otilde\" : 213,\n    \"Ouml\" : 214,\n    \"THORN\" : 222,\n    \"Uacute\" : 218,\n    \"Ucirc\" : 219,\n    \"Ugrave\" : 217,\n    \"Uuml\" : 220,\n    \"Yacute\" : 221,\n    \"aacute\" : 225,\n    \"acirc\" : 226,\n    \"aelig\" : 230,\n    \"agrave\" : 224,\n    \"aring\" : 229,\n    \"atilde\" : 227,\n    \"auml\" : 228,\n    \"ccedil\" : 231,\n    \"eacute\" : 233,\n    \"ecirc\" : 234,\n    \"egrave\" : 232,\n    \"eth\" : 240,\n    \"euml\" : 235,\n    \"iacute\" : 237,\n    \"icirc\" : 238,\n    \"igrave\" : 236,\n    \"iuml\" : 239,\n    \"ntilde\" : 241,\n    \"oacute\" : 243,\n    \"ocirc\" : 244,\n    \"ograve\" : 242,\n    \"oslash\" : 248,\n    \"otilde\" : 245,\n    \"ouml\" : 246,\n    \"szlig\" : 223,\n    \"thorn\" : 254,\n    \"uacute\" : 250,\n    \"ucirc\" : 251,\n    \"ugrave\" : 249,\n    \"uuml\" : 252,\n    \"yacute\" : 253,\n    \"yuml\" : 255,\n    \"copy\" : 169,\n    \"reg\" : 174,\n    \"nbsp\" : 160,\n    \"iexcl\" : 161,\n    \"cent\" : 162,\n    \"pound\" : 163,\n    \"curren\" : 164,\n    \"yen\" : 165,\n    \"brvbar\" : 166,\n    \"sect\" : 167,\n    \"uml\" : 168,\n    \"ordf\" : 170,\n    \"laquo\" : 171,\n    \"not\" : 172,\n    \"shy\" : 173,\n    \"macr\" : 175,\n    \"deg\" : 176,\n    \"plusmn\" : 177,\n    \"sup1\" : 185,\n    \"sup2\" : 178,\n    \"sup3\" : 179,\n    \"acute\" : 180,\n    \"micro\" : 181,\n    \"para\" : 182,\n    \"middot\" : 183,\n    \"cedil\" : 184,\n    \"ordm\" : 186,\n    \"raquo\" : 187,\n    \"frac14\" : 188,\n    \"frac12\" : 189,\n    \"frac34\" : 190,\n    \"iquest\" : 191,\n    \"times\" : 215,\n    \"divide\" : 247,\n    \"OElig;\" : 338,\n    \"oelig;\" : 339,\n    \"Scaron;\" : 352,\n    \"scaron;\" : 353,\n    \"Yuml;\" : 376,\n    \"fnof;\" : 402,\n    \"circ;\" : 710,\n    \"tilde;\" : 732,\n    \"Alpha;\" : 913,\n    \"Beta;\" : 914,\n    \"Gamma;\" : 915,\n    \"Delta;\" : 916,\n    \"Epsilon;\" : 917,\n    \"Zeta;\" : 918,\n    \"Eta;\" : 919,\n    \"Theta;\" : 920,\n    \"Iota;\" : 921,\n    \"Kappa;\" : 922,\n    \"Lambda;\" : 923,\n    \"Mu;\" : 924,\n    \"Nu;\" : 925,\n    \"Xi;\" : 926,\n    \"Omicron;\" : 927,\n    \"Pi;\" : 928,\n    \"Rho;\" : 929,\n    \"Sigma;\" : 931,\n    \"Tau;\" : 932,\n    \"Upsilon;\" : 933,\n    \"Phi;\" : 934,\n    \"Chi;\" : 935,\n    \"Psi;\" : 936,\n    \"Omega;\" : 937,\n    \"alpha;\" : 945,\n    \"beta;\" : 946,\n    \"gamma;\" : 947,\n    \"delta;\" : 948,\n    \"epsilon;\" : 949,\n    \"zeta;\" : 950,\n    \"eta;\" : 951,\n    \"theta;\" : 952,\n    \"iota;\" : 953,\n    \"kappa;\" : 954,\n    \"lambda;\" : 955,\n    \"mu;\" : 956,\n    \"nu;\" : 957,\n    \"xi;\" : 958,\n    \"omicron;\" : 959,\n    \"pi;\" : 960,\n    \"rho;\" : 961,\n    \"sigmaf;\" : 962,\n    \"sigma;\" : 963,\n    \"tau;\" : 964,\n    \"upsilon;\" : 965,\n    \"phi;\" : 966,\n    \"chi;\" : 967,\n    \"psi;\" : 968,\n    \"omega;\" : 969,\n    \"thetasym;\" : 977,\n    \"upsih;\" : 978,\n    \"piv;\" : 982,\n    \"ensp;\" : 8194,\n    \"emsp;\" : 8195,\n    \"thinsp;\" : 8201,\n    \"zwnj;\" : 8204,\n    \"zwj;\" : 8205,\n    \"lrm;\" : 8206,\n    \"rlm;\" : 8207,\n    \"ndash;\" : 8211,\n    \"mdash;\" : 8212,\n    \"lsquo;\" : 8216,\n    \"rsquo;\" : 8217,\n    \"sbquo;\" : 8218,\n    \"ldquo;\" : 8220,\n    \"rdquo;\" : 8221,\n    \"bdquo;\" : 8222,\n    \"dagger;\" : 8224,\n    \"Dagger;\" : 8225,\n    \"bull;\" : 8226,\n    \"hellip;\" : 8230,\n    \"permil;\" : 8240,\n    \"prime;\" : 8242,\n    \"Prime;\" : 8243,\n    \"lsaquo;\" : 8249,\n    \"rsaquo;\" : 8250,\n    \"oline;\" : 8254,\n    \"frasl;\" : 8260,\n    \"euro;\" : 8364,\n    \"image;\" : 8465,\n    \"weierp;\" : 8472,\n    \"real;\" : 8476,\n    \"trade;\" : 8482,\n    \"alefsym;\" : 8501,\n    \"larr;\" : 8592,\n    \"uarr;\" : 8593,\n    \"rarr;\" : 8594,\n    \"darr;\" : 8595,\n    \"harr;\" : 8596,\n    \"crarr;\" : 8629,\n    \"lArr;\" : 8656,\n    \"uArr;\" : 8657,\n    \"rArr;\" : 8658,\n    \"dArr;\" : 8659,\n    \"hArr;\" : 8660,\n    \"forall;\" : 8704,\n    \"part;\" : 8706,\n    \"exist;\" : 8707,\n    \"empty;\" : 8709,\n    \"nabla;\" : 8711,\n    \"isin;\" : 8712,\n    \"notin;\" : 8713,\n    \"ni;\" : 8715,\n    \"prod;\" : 8719,\n    \"sum;\" : 8721,\n    \"minus;\" : 8722,\n    \"lowast;\" : 8727,\n    \"radic;\" : 8730,\n    \"prop;\" : 8733,\n    \"infin;\" : 8734,\n    \"ang;\" : 8736,\n    \"and;\" : 8743,\n    \"or;\" : 8744,\n    \"cap;\" : 8745,\n    \"cup;\" : 8746,\n    \"int;\" : 8747,\n    \"there4;\" : 8756,\n    \"sim;\" : 8764,\n    \"cong;\" : 8773,\n    \"asymp;\" : 8776,\n    \"ne;\" : 8800,\n    \"equiv;\" : 8801,\n    \"le;\" : 8804,\n    \"ge;\" : 8805,\n    \"sub;\" : 8834,\n    \"sup;\" : 8835,\n    \"nsub;\" : 8836,\n    \"sube;\" : 8838,\n    \"supe;\" : 8839,\n    \"oplus;\" : 8853,\n    \"otimes;\" : 8855,\n    \"perp;\" : 8869,\n    \"sdot;\" : 8901,\n    \"lceil;\" : 8968,\n    \"rceil;\" : 8969,\n    \"lfloor;\" : 8970,\n    \"rfloor;\" : 8971,\n    \"lang;\" : 9001,\n    \"rang;\" : 9002,\n    \"loz;\" : 9674,\n    \"spades;\" : 9824,\n    \"clubs;\" : 9827,\n    \"hearts;\" : 9829,\n    \"diams;\" : 9830\n  }\n\n\n}).call(this);\n","/*\n * @constructor\n * @param {Object} objOrModifier\n * @param {string[]} blackBoxKeys - A list of the names of keys that shouldn't be traversed\n * @returns {undefined}\n *\n * Creates a new MongoObject instance. The object passed as the first argument\n * will be modified in place by calls to instance methods. Also, immediately\n * upon creation of the instance, the object will have any `undefined` keys\n * removed recursively.\n */\nMongoObject = function(objOrModifier, blackBoxKeys) {\n  var self = this;\n  self._obj = objOrModifier;\n  self._affectedKeys = {};\n  self._genericAffectedKeys = {};\n  self._parentPositions = [];\n  self._positionsInsideArrays = [];\n  self._objectPositions = [];\n\n  function parseObj(val, currentPosition, affectedKey, operator, adjusted, isWithinArray) {\n\n    // Adjust for first-level modifier operators\n    if (!operator && affectedKey && affectedKey.substring(0, 1) === \"$\") {\n      operator = affectedKey;\n      affectedKey = null;\n    }\n\n    var affectedKeyIsBlackBox = false;\n    var affectedKeyGeneric;\n    if (affectedKey) {\n\n      // Adjust for $push and $addToSet and $pull and $pop\n      if (!adjusted && (operator === \"$push\" || operator === \"$addToSet\" || operator === \"$pull\" || operator === \"$pop\")) {\n        // Adjust for $each\n        // We can simply jump forward and pretend like the $each array\n        // is the array for the field. This has the added benefit of\n        // skipping past any $slice, which we also don't care about.\n        if (isBasicObject(val) && \"$each\" in val) {\n          val = val.$each;\n          currentPosition = currentPosition + \"[$each]\";\n        } else {\n          affectedKey = affectedKey + \".0\";\n        }\n        adjusted = true;\n      }\n\n      // Make generic key\n      affectedKeyGeneric = makeGeneric(affectedKey);\n\n      // Determine whether affected key should be treated as a black box\n      affectedKeyIsBlackBox = _.contains(blackBoxKeys, affectedKeyGeneric);\n\n      // Mark that this position affects this generic and non-generic key\n      if (currentPosition) {\n        self._affectedKeys[currentPosition] = affectedKey;\n        self._genericAffectedKeys[currentPosition] = affectedKeyGeneric;\n\n        // If we're within an array, mark this position so we can omit it from flat docs\n        isWithinArray && self._positionsInsideArrays.push(currentPosition);\n      }\n    }\n\n    // Loop through arrays\n    if (_.isArray(val) && !_.isEmpty(val)) {\n      if (currentPosition) {\n        // Mark positions with arrays that should be ignored when we want endpoints only\n        self._parentPositions.push(currentPosition);\n      }\n\n      // Loop\n      _.each(val, function(v, i) {\n        parseObj(v, (currentPosition ? currentPosition + \"[\" + i + \"]\" : i), affectedKey + '.' + i, operator, adjusted, true);\n      });\n    }\n\n    // Loop through object keys, only for basic objects,\n    // but always for the passed-in object, even if it\n    // is a custom object.\n    else if ((isBasicObject(val) && !affectedKeyIsBlackBox) || !currentPosition) {\n      if (currentPosition && !_.isEmpty(val)) {\n        // Mark positions with objects that should be ignored when we want endpoints only\n        self._parentPositions.push(currentPosition);\n        // Mark positions with objects that should be left out of flat docs.\n        self._objectPositions.push(currentPosition);\n      }\n      // Loop\n      _.each(val, function(v, k) {\n        if (v === void 0) {\n          delete val[k];\n        } else if (k !== \"$slice\") {\n          parseObj(v, (currentPosition ? currentPosition + \"[\" + k + \"]\" : k), appendAffectedKey(affectedKey, k), operator, adjusted, isWithinArray);\n        }\n      });\n    }\n\n  }\n  parseObj(self._obj);\n\n  function reParseObj() {\n    self._affectedKeys = {};\n    self._genericAffectedKeys = {};\n    self._parentPositions = [];\n    self._positionsInsideArrays = [];\n    self._objectPositions = [];\n    parseObj(self._obj);\n  }\n\n  /**\n   * @method MongoObject.forEachNode\n   * @param {Function} func\n   * @param {Object} [options]\n   * @param {Boolean} [options.endPointsOnly=true] - Only call function for endpoints and not for nodes that contain other nodes\n   * @returns {undefined}\n   *\n   * Runs a function for each endpoint node in the object tree, including all items in every array.\n   * The function arguments are\n   * (1) the value at this node\n   * (2) a string representing the node position\n   * (3) the representation of what would be changed in mongo, using mongo dot notation\n   * (4) the generic equivalent of argument 3, with \"$\" instead of numeric pieces\n   */\n  self.forEachNode = function(func, options) {\n    if (typeof func !== \"function\")\n      throw new Error(\"filter requires a loop function\");\n\n    options = _.extend({\n      endPointsOnly: true\n    }, options);\n\n    var updatedValues = {};\n    _.each(self._affectedKeys, function(affectedKey, position) {\n      if (options.endPointsOnly && _.contains(self._parentPositions, position))\n        return; //only endpoints\n      func.call({\n        value: self.getValueForPosition(position),\n        operator: extractOp(position),\n        position: position,\n        key: affectedKey,\n        genericKey: self._genericAffectedKeys[position],\n        updateValue: function(newVal) {\n          updatedValues[position] = newVal;\n        },\n        remove: function() {\n          updatedValues[position] = void 0;\n        }\n      });\n    });\n\n    // Actually update/remove values as instructed\n    _.each(updatedValues, function(newVal, position) {\n      self.setValueForPosition(position, newVal);\n    });\n\n  };\n\n  self.getValueForPosition = function(position) {\n    var subkey, subkeys = position.split(\"[\"), current = self._obj;\n    for (var i = 0, ln = subkeys.length; i < ln; i++) {\n      subkey = subkeys[i];\n      // If the subkey ends in \"]\", remove the ending\n      if (subkey.slice(-1) === \"]\") {\n        subkey = subkey.slice(0, -1);\n      }\n      current = current[subkey];\n      if (!_.isArray(current) && !isBasicObject(current) && i < ln - 1) {\n        return;\n      }\n    }\n    return current;\n  };\n\n  /**\n   * @method MongoObject.prototype.setValueForPosition\n   * @param {String} position\n   * @param {Any} value\n   * @returns {undefined}\n   */\n  self.setValueForPosition = function(position, value) {\n    var nextPiece, subkey, subkeys = position.split(\"[\"), current = self._obj;\n\n    for (var i = 0, ln = subkeys.length; i < ln; i++) {\n      subkey = subkeys[i];\n      // If the subkey ends in \"]\", remove the ending\n      if (subkey.slice(-1) === \"]\") {\n        subkey = subkey.slice(0, -1);\n      }\n      // If we've reached the key in the object tree that needs setting or\n      // deleting, do it.\n      if (i === ln - 1) {\n        current[subkey] = value;\n        //if value is undefined, delete the property\n        if (value === void 0)\n          delete current[subkey];\n      }\n      // Otherwise attempt to keep moving deeper into the object.\n      else {\n        // If we're setting (as opposed to deleting) a key and we hit a place\n        // in the ancestor chain where the keys are not yet created, create them.\n        if (current[subkey] === void 0 && value !== void 0) {\n          //see if the next piece is a number\n          nextPiece = subkeys[i + 1];\n          nextPiece = parseInt(nextPiece, 10);\n          current[subkey] = isNaN(nextPiece) ? {} : [];\n        }\n\n        // Move deeper into the object\n        current = current[subkey];\n\n        // If we can go no further, then quit\n        if (!_.isArray(current) && !isBasicObject(current) && i < ln - 1) {\n          return;\n        }\n      }\n    }\n\n    reParseObj();\n  };\n\n  /**\n   * @method MongoObject.prototype.removeValueForPosition\n   * @param {String} position\n   * @returns {undefined}\n   */\n  self.removeValueForPosition = function(position) {\n    self.setValueForPosition(position, void 0);\n  };\n\n  /**\n   * @method MongoObject.prototype.getKeyForPosition\n   * @param {String} position\n   * @returns {undefined}\n   */\n  self.getKeyForPosition = function(position) {\n    return self._affectedKeys[position];\n  };\n\n  /**\n   * @method MongoObject.prototype.getGenericKeyForPosition\n   * @param {String} position\n   * @returns {undefined}\n   */\n  self.getGenericKeyForPosition = function(position) {\n    return self._genericAffectedKeys[position];\n  };\n\n  /**\n   * @method MongoObject.getInfoForKey\n   * @param {String} key - Non-generic key\n   * @returns {undefined|Object}\n   *\n   * Returns the value and operator of the requested non-generic key.\n   * Example: {value: 1, operator: \"$pull\"}\n   */\n  self.getInfoForKey = function(key) {\n    // Get the info\n    var position = self.getPositionForKey(key);\n    if (position) {\n      return {\n        value: self.getValueForPosition(position),\n        operator: extractOp(position)\n      };\n    }\n\n    // If we haven't returned yet, check to see if there is an array value\n    // corresponding to this key\n    // We find the first item within the array, strip the last piece off the\n    // position string, and then return whatever is at that new position in\n    // the original object.\n    var positions = self.getPositionsForGenericKey(key + \".$\"), p, v;\n    for (var i = 0, ln = positions.length; i < ln; i++) {\n      p = positions[i];\n      v = self.getValueForPosition(p) || self.getValueForPosition(p.slice(0, p.lastIndexOf(\"[\")));\n      if (v) {\n        return {\n          value: v,\n          operator: extractOp(p)\n        };\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.getPositionForKey\n   * @param {String} key - Non-generic key\n   * @returns {undefined|String} Position string\n   *\n   * Returns the position string for the place in the object that\n   * affects the requested non-generic key.\n   * Example: 'foo[bar][0]'\n   */\n  self.getPositionForKey = function(key) {\n    // Get the info\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          // We return the first one we find. While it's\n          // possible that multiple update operators could\n          // affect the same non-generic key, we'll assume that's not the case.\n          return position;\n        }\n      }\n    }\n\n    // If we haven't returned yet, we need to check for affected keys\n  };\n\n  /**\n   * @method MongoObject.getPositionsForGenericKey\n   * @param {String} key - Generic key\n   * @returns {String[]} Array of position strings\n   *\n   * Returns an array of position strings for the places in the object that\n   * affect the requested generic key.\n   * Example: ['foo[bar][0]']\n   */\n  self.getPositionsForGenericKey = function(key) {\n    // Get the info\n    var list = [];\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          list.push(position);\n        }\n      }\n    }\n\n    return list;\n  };\n\n  /**\n   * @deprecated Use getInfoForKey\n   * @method MongoObject.getValueForKey\n   * @param {String} key - Non-generic key\n   * @returns {undefined|Any}\n   *\n   * Returns the value of the requested non-generic key\n   */\n  self.getValueForKey = function(key) {\n    var position = self.getPositionForKey(key);\n    if (position) {\n      return self.getValueForPosition(position);\n    }\n  };\n\n  /**\n   * @method MongoObject.prototype.addKey\n   * @param {String} key - Key to set\n   * @param {Any} val - Value to give this key\n   * @param {String} op - Operator under which to set it, or `null` for a non-modifier object\n   * @returns {undefined}\n   *\n   * Adds `key` with value `val` under operator `op` to the source object.\n   */\n  self.addKey = function(key, val, op) {\n    var position = op ? op + \"[\" + key + \"]\" : MongoObject._keyToPosition(key);\n    self.setValueForPosition(position, val);\n  };\n\n  /**\n   * @method MongoObject.prototype.removeGenericKeys\n   * @param {String[]} keys\n   * @returns {undefined}\n   *\n   * Removes anything that affects any of the generic keys in the list\n   */\n  self.removeGenericKeys = function(keys) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (_.contains(keys, self._genericAffectedKeys[position])) {\n          self.removeValueForPosition(position);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.removeGenericKey\n   * @param {String} key\n   * @returns {undefined}\n   *\n   * Removes anything that affects the requested generic key\n   */\n  self.removeGenericKey = function(key) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          self.removeValueForPosition(position);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.removeKey\n   * @param {String} key\n   * @returns {undefined}\n   *\n   * Removes anything that affects the requested non-generic key\n   */\n  self.removeKey = function(key) {\n    // We don't use getPositionForKey here because we want to be sure to\n    // remove for all positions if there are multiple.\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          self.removeValueForPosition(position);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.removeKeys\n   * @param {String[]} keys\n   * @returns {undefined}\n   *\n   * Removes anything that affects any of the non-generic keys in the list\n   */\n  self.removeKeys = function(keys) {\n    for (var i = 0, ln = keys.length; i < ln; i++) {\n      self.removeKey(keys[i]);\n    }\n  };\n\n  /**\n   * @method MongoObject.filterGenericKeys\n   * @param {Function} test - Test function\n   * @returns {undefined}\n   *\n   * Passes all affected keys to a test function, which\n   * should return false to remove whatever is affecting that key\n   */\n  self.filterGenericKeys = function(test) {\n    var gk, checkedKeys = [], keysToRemove = [];\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        gk = self._genericAffectedKeys[position];\n        if (!_.contains(checkedKeys, gk)) {\n          checkedKeys.push(gk);\n          if (gk && !test(gk)) {\n            keysToRemove.push(gk);\n          }\n        }\n      }\n    }\n\n    _.each(keysToRemove, function(key) {\n      self.removeGenericKey(key);\n    });\n  };\n\n  /**\n   * @method MongoObject.setValueForKey\n   * @param {String} key\n   * @param {Any} val\n   * @returns {undefined}\n   *\n   * Sets the value for every place in the object that affects\n   * the requested non-generic key\n   */\n  self.setValueForKey = function(key, val) {\n    // We don't use getPositionForKey here because we want to be sure to\n    // set the value for all positions if there are multiple.\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          self.setValueForPosition(position, val);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.setValueForGenericKey\n   * @param {String} key\n   * @param {Any} val\n   * @returns {undefined}\n   *\n   * Sets the value for every place in the object that affects\n   * the requested generic key\n   */\n  self.setValueForGenericKey = function(key, val) {\n    // We don't use getPositionForKey here because we want to be sure to\n    // set the value for all positions if there are multiple.\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          self.setValueForPosition(position, val);\n        }\n      }\n    }\n  };\n\n  /**\n   * @method MongoObject.getObject\n   * @returns {Object}\n   *\n   * Get the source object, potentially modified by other method calls on this\n   * MongoObject instance.\n   */\n  self.getObject = function() {\n    return self._obj;\n  };\n\n  /**\n   * @method MongoObject.getFlatObject\n   * @returns {Object}\n   *\n   * Gets a flat object based on the MongoObject instance.\n   * In a flat object, the key is the name of the non-generic affectedKey,\n   * with mongo dot notation if necessary, and the value is the value for\n   * that key.\n   *\n   * With `keepArrays: true`, we don't flatten within arrays. Currently\n   * MongoDB does not see a key such as `a.0.b` and automatically assume\n   * an array. Instead it would create an object with key \"0\" if there\n   * wasn't already an array saved as the value of `a`, which is rarely\n   * if ever what we actually want. To avoid this confusion, we\n   * set entire arrays.\n   */\n  self.getFlatObject = function(options) {\n    options = options || {};\n    var newObj = {};\n    _.each(self._affectedKeys, function(affectedKey, position) {\n      if (typeof affectedKey === \"string\" &&\n        (options.keepArrays === true && !_.contains(self._positionsInsideArrays, position) && !_.contains(self._objectPositions, position)) ||\n        (!options.keepArrays && !_.contains(self._parentPositions, position))\n        ) {\n        newObj[affectedKey] = self.getValueForPosition(position);\n      }\n    });\n    return newObj;\n  };\n\n  /**\n   * @method MongoObject.affectsKey\n   * @param {String} key\n   * @returns {Object}\n   *\n   * Returns true if the non-generic key is affected by this object\n   */\n  self.affectsKey = function(key) {\n    return !!self.getPositionForKey(key);\n  };\n\n  /**\n   * @method MongoObject.affectsGenericKey\n   * @param {String} key\n   * @returns {Object}\n   *\n   * Returns true if the generic key is affected by this object\n   */\n  self.affectsGenericKey = function(key) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * @method MongoObject.affectsGenericKeyImplicit\n   * @param {String} key\n   * @returns {Object}\n   *\n   * Like affectsGenericKey, but will return true if a child key is affected\n   */\n  self.affectsGenericKeyImplicit = function(key) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        var affectedKey = self._genericAffectedKeys[position];\n\n        // If the affected key is the test key\n        if (affectedKey === key) {\n          return true;\n        }\n\n        // If the affected key implies the test key because the affected key\n        // starts with the test key followed by a period\n        if (affectedKey.substring(0, key.length + 1) === key + \".\") {\n          return true;\n        }\n\n        // If the affected key implies the test key because the affected key\n        // starts with the test key and the test key ends with \".$\"\n        var lastTwo = key.slice(-2);\n        if (lastTwo === \".$\" && key.slice(0, -2) === affectedKey) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n};\n\n/** Takes a string representation of an object key and its value\n *  and updates \"obj\" to contain that key with that value.\n *\n *  Example keys and results if val is 1:\n *    \"a\" -> {a: 1}\n *    \"a[b]\" -> {a: {b: 1}}\n *    \"a[b][0]\" -> {a: {b: [1]}}\n *    \"a[b.0.c]\" -> {a: {'b.0.c': 1}}\n */\n\n/** Takes a string representation of an object key and its value\n *  and updates \"obj\" to contain that key with that value.\n *\n *  Example keys and results if val is 1:\n *    \"a\" -> {a: 1}\n *    \"a[b]\" -> {a: {b: 1}}\n *    \"a[b][0]\" -> {a: {b: [1]}}\n *    \"a[b.0.c]\" -> {a: {'b.0.c': 1}}\n *\n * @param {any} val\n * @param {String} key\n * @param {Object} obj\n * @returns {undefined}\n */\nMongoObject.expandKey = function(val, key, obj) {\n  var nextPiece, subkey, subkeys = key.split(\"[\"), current = obj;\n  for (var i = 0, ln = subkeys.length; i < ln; i++) {\n    subkey = subkeys[i];\n    if (subkey.slice(-1) === \"]\") {\n      subkey = subkey.slice(0, -1);\n    }\n    if (i === ln - 1) {\n      //last iteration; time to set the value; always overwrite\n      current[subkey] = val;\n      //if val is undefined, delete the property\n      if (val === void 0)\n        delete current[subkey];\n    } else {\n      //see if the next piece is a number\n      nextPiece = subkeys[i + 1];\n      nextPiece = parseInt(nextPiece, 10);\n      if (!current[subkey]) {\n        current[subkey] = isNaN(nextPiece) ? {} : [];\n      }\n    }\n    current = current[subkey];\n  }\n};\n\nMongoObject._keyToPosition = function keyToPosition(key, wrapAll) {\n  var position = '';\n  _.each(key.split(\".\"), function (piece, i) {\n    if (i === 0 && !wrapAll) {\n      position += piece;\n    } else {\n      position += \"[\" + piece + \"]\";\n    }\n  });\n  return position;\n};\n\n/**\n * @method MongoObject._positionToKey\n * @param {String} position\n * @returns {String} The key that this position in an object would affect.\n *\n * This is different from MongoObject.prototype.getKeyForPosition in that\n * this method does not depend on the requested position actually being\n * present in any particular MongoObject.\n */\nMongoObject._positionToKey = function positionToKey(position) {\n  //XXX Probably a better way to do this, but this is\n  //foolproof for now.\n  var mDoc = new MongoObject({});\n  mDoc.setValueForPosition(position, 1); //value doesn't matter\n  var key = mDoc.getKeyForPosition(position);\n  mDoc = null;\n  return key;\n};\n\nvar isArray = _.isArray;\n\nvar isObject = function(obj) {\n  return obj === Object(obj);\n};\n\n// getPrototypeOf polyfill\nif (typeof Object.getPrototypeOf !== \"function\") {\n  if (typeof \"\".__proto__ === \"object\") {\n    Object.getPrototypeOf = function(object) {\n      return object.__proto__;\n    };\n  } else {\n    Object.getPrototypeOf = function(object) {\n      // May break if the constructor has been tampered with\n      return object.constructor.prototype;\n    };\n  }\n}\n\n/* Tests whether \"obj\" is an Object as opposed to\n * something that inherits from Object\n *\n * @param {any} obj\n * @returns {Boolean}\n */\nvar isBasicObject = function(obj) {\n  return isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};\n\n/* Takes a specific string that uses mongo-style dot notation\n * and returns a generic string equivalent. Replaces all numeric\n * \"pieces\" with a dollar sign ($).\n *\n * @param {type} name\n * @returns {unresolved}\n */\nvar makeGeneric = function makeGeneric(name) {\n  if (typeof name !== \"string\")\n    return null;\n  return name.replace(/\\.[0-9]+\\./g, '.$.').replace(/\\.[0-9]+/g, '.$');\n};\n\nvar appendAffectedKey = function appendAffectedKey(affectedKey, key) {\n  if (key === \"$each\") {\n    return affectedKey;\n  } else {\n    return (affectedKey ? affectedKey + \".\" + key : key);\n  }\n};\n\n// Extracts operator piece, if present, from position string\nvar extractOp = function extractOp(position) {\n  var firstPositionPiece = position.slice(0, position.indexOf(\"[\"));\n  return (firstPositionPiece.substring(0, 1) === \"$\") ? firstPositionPiece : null;\n};","if (Meteor.isServer) {\n  S = Npm.require(\"string\");\n}\nif (Meteor.isClient) {\n  S = window.S;\n}\n\nvar schemaDefinition = {\n  type: Match.Any,\n  label: Match.Optional(Match.OneOf(String, Function)),\n  optional: Match.Optional(Boolean),\n  min: Match.Optional(Match.OneOf(Number, Date, Function)),\n  max: Match.Optional(Match.OneOf(Number, Date, Function)),\n  minCount: Match.Optional(Number),\n  maxCount: Match.Optional(Number),\n  allowedValues: Match.Optional([Match.Any]),\n  valueIsAllowed: Match.Optional(Function), //TODO deprecate this in favor of custom?\n  decimal: Match.Optional(Boolean),\n  regEx: Match.Optional(Match.OneOf(RegExp, [RegExp])),\n  custom: Match.Optional(Function),\n  blackbox: Match.Optional(Boolean),\n  autoValue: Match.Optional(Function),\n  defaultValue: Match.Optional(Match.Any)\n};\n\n//exported\nSimpleSchema = function(schemas, options) {\n  var self = this;\n  var firstLevelSchemaKeys = [];\n  var requiredSchemaKeys = [], firstLevelRequiredSchemaKeys = [];\n  var valueIsAllowedSchemaKeys = [], firstLevelValueIsAllowedSchemaKeys = [];\n  var customSchemaKeys = [], firstLevelCustomSchemaKeys = [];\n  var fieldNameRoot;\n  options = options || {};\n  schemas = schemas || {};\n\n  if (!_.isArray(schemas)) {\n    schemas = [schemas];\n  }\n\n  // adjust and store a copy of the schema definitions\n  self._schema = mergeSchemas(schemas);\n\n  // store the list of defined keys for speedier checking\n  self._schemaKeys = [];\n\n  // store autoValue functions by key\n  self._autoValues = {};\n\n  // store the list of blackbox keys for passing to MongoObject constructor\n  self._blackboxKeys = [];\n\n  // a place to store custom validators for this instance\n  self._validators = [];\n\n  // a place to store custom error messages for this schema\n  self._messages = {};\n\n  self._depsMessages = new Deps.Dependency;\n  self._depsLabels = {};\n\n  var overrideMessages = {};\n  _.each(self._schema, function(definition, fieldName) {\n    // Validate the field definition\n    if (!Match.test(definition, schemaDefinition)) {\n      throw new Error('Invalid definition for ' + fieldName + ' field.');\n    }\n\n    fieldNameRoot = fieldName.split(\".\")[0];\n\n    self._schemaKeys.push(fieldName);\n\n    // We support defaultValue shortcut by converting it immediately into an\n    // autoValue.\n    if ('defaultValue' in definition) {\n      if ('autoValue' in definition) {\n        console.warn('SimpleSchema: Found both autoValue and defaultValue options for \"' + fieldName + '\". Ignoring defaultValue.');\n      } else {\n        if (fieldName.slice(-2) === \".$\") {\n          throw new Error('An array item field (one that ends with \".$\") cannot have defaultValue.')\n        }\n        self._autoValues[fieldName] = (function defineAutoValue(v) {\n          return function() {\n            if (this.operator === null && !this.isSet) {\n              return v;\n            }\n          };\n        })(definition.defaultValue);\n      }\n    }\n\n    if ('autoValue' in definition) {\n      if (fieldName.slice(-2) === \".$\") {\n        throw new Error('An array item field (one that ends with \".$\") cannot have autoValue.')\n      }\n      self._autoValues[fieldName] = definition.autoValue;\n    }\n\n    self._depsLabels[fieldName] = new Deps.Dependency;\n\n    if (definition.blackbox === true) {\n      self._blackboxKeys.push(fieldName);\n    }\n\n    if (!_.contains(firstLevelSchemaKeys, fieldNameRoot)) {\n      firstLevelSchemaKeys.push(fieldNameRoot);\n      if (!definition.optional) {\n        firstLevelRequiredSchemaKeys.push(fieldNameRoot);\n      }\n\n      if (definition.valueIsAllowed) {\n        firstLevelValueIsAllowedSchemaKeys.push(fieldNameRoot);\n      }\n\n      if (definition.custom) {\n        firstLevelCustomSchemaKeys.push(fieldNameRoot);\n      }\n    }\n\n    if (!definition.optional) {\n      requiredSchemaKeys.push(fieldName);\n    }\n\n    if (definition.valueIsAllowed) {\n      valueIsAllowedSchemaKeys.push(fieldName);\n    }\n\n    if (definition.custom) {\n      customSchemaKeys.push(fieldName);\n    }\n\n    // Set up nicer error messages for the built-in regEx.\n    // Users will need to override these at the schema-specific level,\n    // which could be undesirable, so we provide an option to\n    // skip this.\n    if (options.defineBuiltInRegExMessages !== false) {\n      if (definition.regEx === SimpleSchema.RegEx.Email) {\n        overrideMessages['regEx ' + fieldName] = \"[label] must be a valid e-mail address\";\n      } else if (definition.regEx === SimpleSchema.RegEx.Url) {\n        overrideMessages['regEx ' + fieldName] = \"[label] must be a valid URL\";\n      } else if (_.isArray(definition.regEx)) {\n        _.each(definition.regEx, function(re, i) {\n          if (re === SimpleSchema.RegEx.Email) {\n            overrideMessages['regEx.' + i + ' ' + fieldName] = \"[label] must be a valid e-mail address\";\n          } else if (re === SimpleSchema.RegEx.Url) {\n            overrideMessages['regEx.' + i + ' ' + fieldName] = \"[label] must be a valid URL\";\n          }\n        });\n      }\n    }\n\n  });\n  \n  // Set override messages\n  self.messages(overrideMessages);\n\n  // Cache these lists\n  self._firstLevelSchemaKeys = firstLevelSchemaKeys;\n  //required\n  self._requiredSchemaKeys = requiredSchemaKeys;\n  self._firstLevelRequiredSchemaKeys = firstLevelRequiredSchemaKeys;\n  self._requiredObjectKeys = getObjectKeys(self._schema, requiredSchemaKeys);\n  //valueIsAllowed\n  self._valueIsAllowedSchemaKeys = valueIsAllowedSchemaKeys;\n  self._firstLevelValueIsAllowedSchemaKeys = firstLevelValueIsAllowedSchemaKeys;\n  self._valueIsAllowedObjectKeys = getObjectKeys(self._schema, valueIsAllowedSchemaKeys);\n  //custom\n  self._customSchemaKeys = customSchemaKeys;\n  self._firstLevelCustomSchemaKeys = firstLevelCustomSchemaKeys;\n  self._customObjectKeys = getObjectKeys(self._schema, customSchemaKeys);\n\n  // We will store named validation contexts here\n  self._validationContexts = {};\n};\n\n// This allows other packages or users to extend the schema\n// definition options that are supported.\nSimpleSchema.extendOptions = function(options) {\n  _.extend(schemaDefinition, options);\n};\n\n// regex for email validation after RFC 5322\n// the obsolete double quotes and square brackets are left out\n// read: http://www.regular-expressions.info/email.html\nvar RX_MAIL_NAME = '[a-z0-9!#$%&\\'*+\\\\/=?^_`{|}~-]+(?:\\\\.[a-z0-9!#$%&\\'*+\\\\/=?^_`{|}~-]+)*';\n// this domain regex matches all domains that have at least one .\n// sadly IPv4 Adresses will be caught too but technically those are valid domains\n// this expression is extracted from the original RFC 5322 mail expression\n// a modification enforces that the tld consists only of characters\nvar RX_DOMAIN = '(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)+[a-z](?:[a-z-]*[a-z])?';\n// this domain regex matches everythign that could be a domain in intranet\n// that means \"localhost\" is a valid domain\nvar RX_NAME_DOMAIN = '(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?(?:\\\\.|$))+';\n// strict IPv4 expression which allows 0-255 per oktett\nvar RX_IPv4 = '(?:(?:[0-1]?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])(?:\\\\.|$)){4}';\n// strict IPv6 expression which allows (and validates) all shortcuts\nvar RX_IPv6 = '(?:(?:[\\\\dA-Fa-f]{1,4}(?::|$)){8}' // full adress\n  + '|(?=(?:[^:\\\\s]|:[^:\\\\s])*::(?:[^:\\\\s]|:[^:\\\\s])*$)' // or min/max one '::'\n  + '[\\\\dA-Fa-f]{0,4}(?:::?(?:[\\\\dA-Fa-f]{1,4}|$)){1,6})'; // and short adress\n// this allows domains (also localhost etc) and ip adresses\nvar RX_WEAK_DOMAIN = '(?:' + [RX_NAME_DOMAIN,RX_IPv4,RX_IPv6].join('|') + ')';\n\nSimpleSchema.RegEx = {\n  Email: new RegExp('^' + RX_MAIL_NAME + '@' + RX_DOMAIN + '$'),\n  WeakEmail: new RegExp('^' + RX_MAIL_NAME + '@' + RX_WEAK_DOMAIN + '$'),\n  \n  Domain: new RegExp('^' + RX_DOMAIN + '$'),\n  WeakDomain: new RegExp('^' + RX_WEAK_DOMAIN + '$'),\n  \n  IP: new RegExp('^(?:' + RX_IPv4 + '|' + RX_IPv6 + ')$'),\n  IPv4: new RegExp('^' + RX_IPv4 + '$'),\n  IPv6: new RegExp('^' + RX_IPv6 + '$'),\n  // URL RegEx from https://gist.github.com/dperini/729294\n  // http://mathiasbynens.be/demo/url-regex\n  Url: /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/i,\n  // unique id from the random package also used by minimongo\n  // character list: https://github.com/meteor/meteor/blob/release/0.8.0/packages/random/random.js#L88\n  // string length: https://github.com/meteor/meteor/blob/release/0.8.0/packages/random/random.js#L143\n  Id: /^[23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz]{17}$/\n};\n\nSimpleSchema._makeGeneric = function(name) {\n  if (typeof name !== \"string\")\n    return null;\n\n  return name.replace(/\\.[0-9]+\\./g, '.$.').replace(/\\.[0-9]+/g, '.$');\n};\n\nSimpleSchema._depsGlobalMessages = new Deps.Dependency;\n\n// exported for backwards compatibility, deprecated\nSchemaRegEx = SimpleSchema.RegEx;\n\n// Inherit from Match.Where\n// This allow SimpleSchema instance to be recognized as a Match.Where instance as well\n// as a SimpleSchema instance\nSimpleSchema.prototype = new Match.Where();\n\n// If an object is an instance of Match.Where, Meteor built-in check API will look at\n// the function named `condition` and will pass it the document to validate\nSimpleSchema.prototype.condition = function(obj) {\n  var self = this;\n\n  //determine whether obj is a modifier\n  var isModifier, isNotModifier;\n  _.each(obj, function(val, key) {\n    if (key.substring(0, 1) === \"$\") {\n      isModifier = true;\n    } else {\n      isNotModifier = true;\n    }\n  });\n\n  if (isModifier && isNotModifier)\n    throw new Match.Error(\"Object cannot contain modifier operators alongside other keys\");\n\n  if (!self.newContext().validate(obj, {modifier: isModifier, filter: false, autoConvert: false}))\n    throw new Match.Error(\"One or more properties do not match the schema.\");\n\n  return true;\n};\n\nfunction logInvalidKeysForContext(context, name) {\n  Meteor.startup(function() {\n    Deps.autorun(function() {\n      if (!context.isValid()) {\n        console.log('SimpleSchema invalid keys for \"' + name + '\" context:', context.invalidKeys());\n      }\n    });\n  });\n}\n\nSimpleSchema.prototype.namedContext = function(name) {\n  var self = this;\n  if (typeof name !== \"string\") {\n    name = \"default\";\n  }\n  if (!self._validationContexts[name]) {\n    self._validationContexts[name] = new SimpleSchemaValidationContext(self);\n\n    // In debug mode, log all invalid key errors to the browser console\n    if (SimpleSchema.debug && Meteor.isClient) {\n      Deps.nonreactive(function() {\n        logInvalidKeysForContext(self._validationContexts[name], name);\n      });\n    }\n  }\n  return self._validationContexts[name];\n};\n\n// Global custom validators\nSimpleSchema._validators = [];\nSimpleSchema.addValidator = function(func) {\n  SimpleSchema._validators.push(func);\n};\n\n// Instance custom validators\n// validator is deprecated; use addValidator\nSimpleSchema.prototype.addValidator = SimpleSchema.prototype.validator = function(func) {\n  this._validators.push(func);\n};\n\n/**\n * @method SimpleSchema.prototype.clean\n * @param {Object} doc - Document or modifier to clean. Referenced object will be modified in place.\n * @param {Object} [options]\n * @param {Boolean} [options.filter=true] - Do filtering?\n * @param {Boolean} [options.autoConvert=true] - Do automatic type converting?\n * @param {Boolean} [options.removeEmptyStrings=true] - Remove keys in normal object or $set where the value is an empty string?\n * @param {Boolean} [options.getAutoValues=true] - Inject automatic and default values?\n * @param {Boolean} [options.isModifier=false] - Is doc a modifier object?\n * @param {Object} [options.extendAutoValueContext] - This object will be added to the `this` context of autoValue functions.\n * @returns {Object} The modified doc.\n * \n * Cleans a document or modifier object. By default, will filter, automatically\n * type convert where possible, and inject automatic/default values. Use the options\n * to skip one or more of these.\n */\nSimpleSchema.prototype.clean = function(doc, options) {\n  var self = this;\n\n  // By default, doc will be filtered and autoconverted\n  options = _.extend({\n    filter: true,\n    autoConvert: true,\n    removeEmptyStrings: true,\n    getAutoValues: true,\n    isModifier: false,\n    extendAutoValueContext: {}\n  }, options || {});\n\n  // Convert $pushAll (deprecated) to $push with $each\n  if (\"$pushAll\" in doc) {\n    console.warn(\"SimpleSchema.clean: $pushAll is deprecated; converting to $push with $each\");\n    doc.$push = doc.$push || {};\n    for (var field in doc.$pushAll) {\n      doc.$push[field] = doc.$push[field] || {};\n      doc.$push[field].$each = doc.$push[field].$each || [];\n      for (var i = 0, ln = doc.$pushAll[field].length; i < ln; i++) {\n        doc.$push[field].$each.push(doc.$pushAll[field][i]);\n      }\n      delete doc.$pushAll;\n    }\n  }\n\n  var mDoc = new MongoObject(doc, self._blackboxKeys);\n\n  // Filter out anything that would affect keys not defined\n  // or implied by the schema\n  options.filter && mDoc.filterGenericKeys(function(genericKey) {\n    var allowed = self.allowsKey(genericKey);\n    if (!allowed && SimpleSchema.debug) {\n      console.info('SimpleSchema.clean: filtered out value that would have affected key \"' + genericKey + '\", which is not allowed by the schema');\n    }\n    return allowed;\n  });\n\n  // Autoconvert values if requested and if possible\n  (options.autoConvert || options.removeEmptyStrings) && mDoc.forEachNode(function() {\n    if (this.genericKey) {\n      var def = self._schema[this.genericKey];\n      var val = this.value;\n      if (def && val !== void 0) {\n        var wasAutoConverted = false;\n        if (options.autoConvert) {\n          var newVal = typeconvert(val, def.type);\n          if (newVal !== void 0 && newVal !== val) {\n            SimpleSchema.debug && console.info('SimpleSchema.clean: autoconverted value ' + val + ' from ' + typeof val + ' to ' + typeof newVal + ' for ' + this.genericKey);\n            this.updateValue(newVal);\n            wasAutoConverted = true;\n            // remove empty strings\n            if (options.removeEmptyStrings && (!this.operator || this.operator === \"$set\") && typeof newVal === \"string\" && !newVal.length) {\n              this.remove();\n            }\n          }\n        }\n        // remove empty strings\n        if (options.removeEmptyStrings && !wasAutoConverted && (!this.operator || this.operator === \"$set\") && typeof val === \"string\" && !val.length) {\n          this.remove();\n        }\n      }\n    }\n  }, {endPointsOnly: false});\n\n  // Set automatic values\n  options.getAutoValues && getAutoValues.call(self, mDoc, options.isModifier, options.extendAutoValueContext);\n\n  return doc;\n};\n\n// Returns the entire schema object or just the definition for one key\n// in the schema.\nSimpleSchema.prototype.schema = function(key) {\n  var self = this;\n  // if not null or undefined (more specific)\n  if (key != null) {\n    return self._schema[SimpleSchema._makeGeneric(key)];\n  } else {\n    return self._schema;\n  }\n};\n\n// Use to dynamically change the schema labels.\nSimpleSchema.prototype.labels = function(labels) {\n  var self = this;\n  _.each(labels, function(label, fieldName) {\n    if (!_.isString(label) && !_.isFunction(label))\n      return;\n\n    if (!(fieldName in self._schema))\n      return;\n\n    self._schema[fieldName].label = label;\n    self._depsLabels[fieldName] && self._depsLabels[fieldName].changed();\n  });\n};\n\n// should be used to safely get a label as string\nSimpleSchema.prototype.label = function(key) {\n  var self = this\n  key = SimpleSchema._makeGeneric(key);\n  var def = self.schema(key);\n  // if there is no field defined use all fields\n  if (key == null) {\n    var result = {};\n    _.each(def, function(def, fieldName) {\n      result[fieldName] = self.label(fieldName);\n    });\n    return result;\n    // if a field was defined get that\n  } else if (def != null) {\n    self._depsLabels[key] && self._depsLabels[key].depend();\n    var label = def.label;\n    return _.isFunction(label) ? label.call(def) : (label || inflectedLabel(key));\n  } else {\n    return null;\n  }\n};\n\n// Global messages\n\nSimpleSchema._globalMessages = {\n  required: \"[label] is required\",\n  minString: \"[label] must be at least [min] characters\",\n  maxString: \"[label] cannot exceed [max] characters\",\n  minNumber: \"[label] must be at least [min]\",\n  maxNumber: \"[label] cannot exceed [max]\",\n  minDate: \"[label] must be on or before [min]\",\n  maxDate: \"[label] cannot be after [max]\",\n  minCount: \"You must specify at least [minCount] values\",\n  maxCount: \"You cannot specify more than [maxCount] values\",\n  noDecimal: \"[label] must be an integer\",\n  notAllowed: \"[value] is not an allowed value\",\n  expectedString: \"[label] must be a string\",\n  expectedNumber: \"[label] must be a number\",\n  expectedBoolean: \"[label] must be a boolean\",\n  expectedArray: \"[label] must be an array\",\n  expectedObject: \"[label] must be an object\",\n  expectedConstructor: \"[label] must be a [type]\",\n  regEx: \"[label] failed regular expression validation\",\n  keyNotInSchema: \"[label] is not allowed by the schema\"\n};\n\nSimpleSchema.messages = function(messages) {\n  _.extend(SimpleSchema._globalMessages, messages);\n  SimpleSchema._depsGlobalMessages.changed();\n};\n\n// Schema-specific messages\n\nSimpleSchema.prototype.messages = function(messages) {\n  var self = this;\n  _.extend(self._messages, messages);\n  self._depsMessages.changed();\n};\n\n// Returns a string message for the given error type and key. Uses the\n// def and value arguments to fill in placeholders in the error messages.\nSimpleSchema.prototype.messageForError = function(type, key, def, value) {\n  var self = this;\n\n  // Prep some strings to be used when finding the correct message for this error\n  var typePlusKey = type + \" \" + key;\n  var genericKey = SimpleSchema._makeGeneric(key);\n  var typePlusGenKey = type + \" \" + genericKey;\n  var firstTypePeriod = type.indexOf(\".\");\n  var genType;\n  var genTypePlusKey;\n  var genTypePlusGenKey;\n  if (firstTypePeriod !== -1) {\n    genType = type.substring(0, firstTypePeriod);\n    genTypePlusKey = genType + \" \" + key;\n    genTypePlusGenKey = genType + \" \" + genericKey;\n  }\n\n  // reactively update when message templates or labels are changed\n  SimpleSchema._depsGlobalMessages.depend();\n  self._depsMessages.depend();\n  self._depsLabels[key] && self._depsLabels[key].depend();\n\n  // Try finding the correct message to use at various levels, from most\n  // specific to least specific.\n  // \n  // (1) Use schema-specific message for specific key, specific type\n  // (2) Use schema-specific message for generic key, specific type\n  // (3) Use schema-specific message for specific type\n  var message = self._messages[typePlusKey] || self._messages[typePlusGenKey] || self._messages[type];\n  // (4) Use schema-specific message for specific key, general type\n  // (5) Use schema-specific message for generic key, general type\n  // (6) Use schema-specific message for general type\n  if (!message && genType) {\n    message = self._messages[genTypePlusKey] || self._messages[genTypePlusGenKey] || self._messages[genType];\n  }\n  // (7) Use global message for specific key, specific type\n  // (8) Use global message for generic key, specific type\n  // (9) Use global message for specific type\n  if (!message) {\n    message = SimpleSchema._globalMessages[typePlusKey] || SimpleSchema._globalMessages[typePlusGenKey] || SimpleSchema._globalMessages[type];\n  }\n  // (10) Use global message for specific key, general type\n  // (11) Use global message for generic key, general type\n  // (12) Use global message for general type\n  if (!message && genType) {\n    message = SimpleSchema._globalMessages[genTypePlusKey] || SimpleSchema._globalMessages[genTypePlusGenKey] || SimpleSchema._globalMessages[genType];\n  }\n  if (!message) {\n    return \"Unknown validation error\";\n  }\n\n  // Now replace all placeholders in the message with the correct values\n  def = def || self.schema(key) || {};\n  message = message.replace(\"[label]\", self.label(key));\n  if (typeof def.minCount !== \"undefined\") {\n    message = message.replace(\"[minCount]\", def.minCount);\n  }\n  if (typeof def.maxCount !== \"undefined\") {\n    message = message.replace(\"[maxCount]\", def.maxCount);\n  }\n  if (value !== void 0 && value !== null) {\n    message = message.replace(\"[value]\", value.toString());\n  }\n  var min = def.min;\n  var max = def.max;\n  if (typeof min === \"function\") {\n    min = min();\n  }\n  if (typeof max === \"function\") {\n    max = max();\n  }\n  if (def.type === Date || def.type === [Date]) {\n    if (typeof min !== \"undefined\") {\n      message = message.replace(\"[min]\", dateToDateString(min));\n    }\n    if (typeof max !== \"undefined\") {\n      message = message.replace(\"[max]\", dateToDateString(max));\n    }\n  } else {\n    if (typeof min !== \"undefined\") {\n      message = message.replace(\"[min]\", min);\n    }\n    if (typeof max !== \"undefined\") {\n      message = message.replace(\"[max]\", max);\n    }\n  }\n  if (def.type instanceof Function) {\n    message = message.replace(\"[type]\", def.type.name);\n  }\n\n  // Now return the message\n  return message;\n};\n\n// Returns true if key is explicitly allowed by the schema or implied\n// by other explicitly allowed keys.\n// The key string should have $ in place of any numeric array positions.\nSimpleSchema.prototype.allowsKey = function(key) {\n  var self = this;\n\n  // Loop through all keys in the schema\n  return _.any(self._schemaKeys, function(schemaKey) {\n\n    // If the schema key is the test key, it's allowed.\n    if (schemaKey === key) {\n      return true;\n    }\n    \n    // Black box handling\n    if (self.schema(schemaKey).blackbox === true) {\n      var kl = schemaKey.length;\n      var compare1 = key.slice(0, kl + 2);\n      var compare2 = compare1.slice(0, -1);\n\n      // If the test key is the black box key + \".$\", then the test\n      // key is NOT allowed because black box keys are by definition\n      // only for objects, and not for arrays.\n      if (compare1 === schemaKey + '.$')\n        return false;\n\n      // Otherwise\n      if (compare2 === schemaKey + '.')\n        return true;\n    }\n\n    return false;\n  });\n};\n\nSimpleSchema.prototype.newContext = function() {\n  return new SimpleSchemaValidationContext(this);\n};\n\nSimpleSchema.prototype.requiredObjectKeys = function(keyPrefix) {\n  var self = this;\n  if (!keyPrefix) {\n    return self._firstLevelRequiredSchemaKeys;\n  }\n  return self._requiredObjectKeys[keyPrefix + \".\"] || [];\n};\n\nSimpleSchema.prototype.requiredSchemaKeys = function() {\n  return this._requiredSchemaKeys;\n};\n\nSimpleSchema.prototype.firstLevelSchemaKeys = function() {\n  return this._firstLevelSchemaKeys;\n};\n\nSimpleSchema.prototype.valueIsAllowedObjectKeys = function(keyPrefix) {\n  var self = this;\n  if (!keyPrefix) {\n    return self._firstLevelValueIsAllowedSchemaKeys;\n  }\n  return self._valueIsAllowedObjectKeys[keyPrefix + \".\"] || [];\n};\n\nSimpleSchema.prototype.valueIsAllowedSchemaKeys = function() {\n  return this._valueIsAllowedSchemaKeys;\n};\n\nSimpleSchema.prototype.customObjectKeys = function(keyPrefix) {\n  var self = this;\n  if (!keyPrefix) {\n    return self._firstLevelCustomSchemaKeys;\n  }\n  return self._customObjectKeys[keyPrefix + \".\"] || [];\n};\n\nSimpleSchema.prototype.customSchemaKeys = function() {\n  return this._customSchemaKeys;\n};\n\n//called by clean()\nvar typeconvert = function(value, type) {\n  if (_.isArray(value) || (_.isObject(value) && !(value instanceof Date)))\n    return value; //can't and shouldn't convert arrays or objects\n  if (type === String) {\n    if (typeof value !== \"undefined\" && value !== null && typeof value !== \"string\") {\n      return value.toString();\n    }\n    return value;\n  }\n  if (type === Number) {\n    if (typeof value === \"string\" && !S(value).isEmpty()) {\n      //try to convert numeric strings to numbers\n      var numberVal = Number(value);\n      if (!isNaN(numberVal)) {\n        return numberVal;\n      } else {\n        return value; //leave string; will fail validation\n      }\n    }\n    return value;\n  }\n  return value;\n};\n\n//tests whether it's an Object as opposed to something that inherits from Object\nvar isBasicObject = function(obj) {\n  return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};\n\nlooksLikeModifier = function(obj) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && key.substring(0, 1) === \"$\") {\n      return true;\n    }\n  }\n  return false;\n};\n\nvar dateToDateString = function(date) {\n  var m = (date.getUTCMonth() + 1);\n  if (m < 10) {\n    m = \"0\" + m;\n  }\n  var d = date.getUTCDate();\n  if (d < 10) {\n    d = \"0\" + d;\n  }\n  return date.getUTCFullYear() + '-' + m + '-' + d;\n};\n\nvar mergeSchemas = function(schemas) {\n\n  // Merge all provided schema definitions.\n  // This is effectively a shallow clone of each object, too,\n  // which is what we want since we are going to manipulate it.\n  var mergedSchema = {};\n  _.each(schemas, function(schema) {\n\n    // Create a temporary SS instance so that the internal object\n    // we use for merging/extending will be fully expanded\n    if (Match.test(schema, SimpleSchema)) {\n      schema = schema._schema;\n    } else {\n      schema = addImplicitKeys(expandSchema(schema));\n    }\n\n    // Loop through and extend each individual field\n    // definition. That way you can extend and overwrite\n    // base field definitions.\n    _.each(schema, function(def, field) {\n      mergedSchema[field] = mergedSchema[field] || {};\n      _.extend(mergedSchema[field], def);\n    });\n\n  });\n\n  // If we merged some schemas, do this again to make sure\n  // extended definitions are pushed into array item field\n  // definitions properly.\n  schemas.length && adjustArrayFields(mergedSchema);\n\n  return mergedSchema;\n};\n\nvar expandSchema = function(schema) {\n  // Flatten schema by inserting nested definitions\n  _.each(schema, function(val, key) {\n    var dot, type;\n    if (!val)\n      return;\n    if (Match.test(val.type, SimpleSchema)) {\n      dot = '.';\n      type = val.type;\n      val.type = Object;\n    } else if (Match.test(val.type, [SimpleSchema])) {\n      dot = '.$.';\n      type = val.type[0];\n      val.type = [Object];\n    } else {\n      return;\n    }\n    //add child schema definitions to parent schema\n    _.each(type._schema, function(subVal, subKey) {\n      var newKey = key + dot + subKey;\n      if (!(newKey in schema))\n        schema[newKey] = subVal;\n    });\n  });\n  return schema;\n};\n\nvar adjustArrayFields = function(schema) {\n  _.each(schema, function(def, existingKey) {\n    if (_.isArray(def.type) || def.type === Array) {\n      // Copy some options to array-item definition\n      var itemKey = existingKey + \".$\";\n      if (!(itemKey in schema)) {\n        schema[itemKey] = {};\n      }\n      if (_.isArray(def.type)) {\n        schema[itemKey].type = def.type[0];\n      }\n      if (def.label) {\n        schema[itemKey].label = def.label;\n      }\n      schema[itemKey].optional = true;\n      if (typeof def.min !== \"undefined\") {\n        schema[itemKey].min = def.min;\n      }\n      if (typeof def.max !== \"undefined\") {\n        schema[itemKey].max = def.max;\n      }\n      if (typeof def.allowedValues !== \"undefined\") {\n        schema[itemKey].allowedValues = def.allowedValues;\n      }\n      if (typeof def.valueIsAllowed !== \"undefined\") {\n        schema[itemKey].valueIsAllowed = def.valueIsAllowed;\n      }\n      if (typeof def.decimal !== \"undefined\") {\n        schema[itemKey].decimal = def.decimal;\n      }\n      if (typeof def.regEx !== \"undefined\") {\n        schema[itemKey].regEx = def.regEx;\n      }\n      // Remove copied options and adjust type\n      def.type = Array;\n      _.each(['min', 'max', 'allowedValues', 'valueIsAllowed', 'decimal', 'regEx'], function(k) {\n        deleteIfPresent(def, k);\n      });\n    }\n  });\n};\n\n/**\n * Adds implied keys.\n * * If schema contains a key like \"foo.$.bar\" but not \"foo\", adds \"foo\".\n * * If schema contains a key like \"foo\" with an array type, adds \"foo.$\".\n * @param {Object} schema\n * @returns {Object} modified schema\n */\nvar addImplicitKeys = function(schema) {\n  var arrayKeysToAdd = [], objectKeysToAdd = [], newKey, key;\n\n  // Pass 1 (objects)\n  _.each(schema, function(def, existingKey) {\n    var pos = existingKey.indexOf(\".\");\n    while (pos !== -1) {\n      newKey = existingKey.substring(0, pos);\n\n      // It's an array item; nothing to add\n      if (newKey.substring(newKey.length - 2) === \".$\") {\n        pos = -1;\n      }\n      // It's an array of objects; add it with type [Object] if not already in the schema\n      else if (existingKey.substring(pos, pos + 3) === \".$.\") {\n        arrayKeysToAdd.push(newKey); // add later, since we are iterating over schema right now\n        pos = existingKey.indexOf(\".\", pos + 3); // skip over next dot, find the one after\n      }\n      // It's an object; add it with type Object if not already in the schema\n      else {\n        objectKeysToAdd.push(newKey); // add later, since we are iterating over schema right now\n        pos = existingKey.indexOf(\".\", pos + 1); // find next dot\n      }\n    }\n  });\n\n  for (var i = 0, ln = arrayKeysToAdd.length; i < ln; i++) {\n    key = arrayKeysToAdd[i];\n    if (!(key in schema)) {\n      schema[key] = {type: [Object], optional: true};\n    }\n  }\n\n  for (var i = 0, ln = objectKeysToAdd.length; i < ln; i++) {\n    key = objectKeysToAdd[i];\n    if (!(key in schema)) {\n      schema[key] = {type: Object, optional: true};\n    }\n  }\n\n  // Pass 2 (arrays)\n  adjustArrayFields(schema);\n\n  return schema;\n};\n\n// Returns an object relating the keys in the list\n// to their parent object.\nvar getObjectKeys = function(schema, schemaKeyList) {\n  var keyPrefix, remainingText, rKeys = {}, loopArray;\n  _.each(schema, function(definition, fieldName) {\n    if (definition.type === Object) {\n      //object\n      keyPrefix = fieldName + \".\";\n    } else {\n      return;\n    }\n\n    loopArray = [];\n    _.each(schemaKeyList, function(fieldName2) {\n      if (S(fieldName2).startsWith(keyPrefix)) {\n        remainingText = fieldName2.substring(keyPrefix.length);\n        if (remainingText.indexOf(\".\") === -1) {\n          loopArray.push(remainingText);\n        }\n      }\n    });\n    rKeys[keyPrefix] = loopArray;\n  });\n  return rKeys;\n};\n\n// returns an inflected version of fieldName to use as the label\nvar inflectedLabel = function(fieldName) {\n  var label = fieldName, lastPeriod = label.lastIndexOf(\".\");\n  if (lastPeriod !== -1) {\n    label = label.substring(lastPeriod + 1);\n    if (label === \"$\") {\n      var pcs = fieldName.split(\".\");\n      label = pcs[pcs.length - 2];\n    }\n  }\n  if (label === \"_id\")\n    return \"ID\";\n  return S(label).humanize().s;\n};\n\nvar deleteIfPresent = function(obj, key) {\n  if (key in obj) {\n    delete obj[key];\n  }\n};\n\n/**\n * @method getAutoValues\n * @private \n * @param {MongoObject} mDoc\n * @param {Boolean} [isModifier=false] - Is it a modifier doc?\n * @param {Object} [extendedAutoValueContext] - Object that will be added to the context when calling each autoValue function\n * @returns {undefined}\n * \n * Updates doc with automatic values from autoValue functions or default\n * values from defaultValue. Modifies the referenced object in place.\n */\nfunction getAutoValues(mDoc, isModifier, extendedAutoValueContext) {\n  var self = this;\n  var doneKeys = [];\n\n  //on the client we can add the userId if not already in the custom context\n  if (Meteor.isClient && extendedAutoValueContext.userId === void 0) {\n    extendedAutoValueContext.userId = (Meteor.userId && Meteor.userId()) || null;\n  }\n  \n  function runAV(func) {\n    var affectedKey = this.key;\n    // If already called for this key, skip it\n    if (_.contains(doneKeys, affectedKey))\n      return;\n    var lastDot = affectedKey.lastIndexOf('.');\n    var fieldParentName = lastDot === -1 ? '' : affectedKey.slice(0, lastDot + 1);\n    var doUnset = false;\n    var autoValue = func.call(_.extend({\n      isSet: (this.value !== void 0),\n      unset: function() {\n        doUnset = true;\n      },\n      value: this.value,\n      operator: this.operator,\n      field: function(fName) {\n        var keyInfo = mDoc.getInfoForKey(fName) || {};\n        return {\n          isSet: (keyInfo.value !== void 0),\n          value: keyInfo.value,\n          operator: keyInfo.operator || null\n        };\n      },\n      siblingField: function(fName) {\n        var keyInfo = mDoc.getInfoForKey(fieldParentName + fName) || {};\n        return {\n          isSet: (keyInfo.value !== void 0),\n          value: keyInfo.value,\n          operator: keyInfo.operator || null\n        };\n      }\n    }, extendedAutoValueContext || {}), mDoc.getObject());\n\n    // Update tracking of which keys we've run autovalue for\n    doneKeys.push(affectedKey);\n\n    if (autoValue === void 0) {\n      if (doUnset) {\n        mDoc.removeValueForPosition(this.position);\n      }\n      return;\n    }\n\n    // If the user's auto value is of the pseudo-modifier format, parse it\n    // into operator and value.\n    var op, newValue;\n    if (_.isObject(autoValue)) {\n      for (var key in autoValue) {\n        if (autoValue.hasOwnProperty(key) && key.substring(0, 1) === \"$\") {\n          op = key;\n          newValue = autoValue[key];\n          break;\n        }\n      }\n    }\n\n    // Add $set for updates and upserts if necessary\n    if (!op && isModifier && this.position.slice(0, 1) !== '$') {\n      op = \"$set\";\n      newValue = autoValue;\n    }\n\n    // Update/change value\n    if (op) {\n      mDoc.removeValueForPosition(this.position);\n      mDoc.setValueForPosition(op + '[' + affectedKey + ']', newValue);\n    } else {\n      mDoc.setValueForPosition(this.position, autoValue);\n    }\n  }\n\n  _.each(self._autoValues, function(func, fieldName) {\n    var positionSuffix, key, keySuffix, positions;\n    \n    // If we're under an array, run autovalue for all the properties of\n    // any objects that are present in the nearest ancestor array.\n    if (fieldName.indexOf(\"$\") !== -1) {\n      var testField = fieldName.slice(0, fieldName.lastIndexOf(\"$\") + 1);\n      keySuffix = fieldName.slice(testField.length + 1);\n      positionSuffix = MongoObject._keyToPosition(keySuffix, true);\n      keySuffix = '.' + keySuffix;\n      positions = mDoc.getPositionsForGenericKey(testField);\n    } else {\n      \n      // See if anything in the object affects this key\n      positions = mDoc.getPositionsForGenericKey(fieldName);\n      \n      // Run autovalue for properties that are set in the object\n      if (positions.length) {\n        key = fieldName;\n        keySuffix = '';\n        positionSuffix = '';\n      }\n      \n      // Run autovalue for properties that are NOT set in the object\n      else {\n        key = fieldName;\n        keySuffix = '';\n        positionSuffix = '';\n        if (isModifier) {\n          positions = [\"$set[\" + fieldName + \"]\"];\n        } else {\n          positions = [MongoObject._keyToPosition(fieldName)];\n        }\n      }\n    \n    }\n\n    _.each(positions, function(position) {\n      runAV.call({\n        key: (key || MongoObject._positionToKey(position)) + keySuffix,\n        value: mDoc.getValueForPosition(position + positionSuffix),\n        operator: extractOp(position),\n        position: position + positionSuffix\n      }, func);\n    });\n  });\n}\n\n// Extracts operator piece, if present, from position string\nvar extractOp = function extractOp(position) {\n  var firstPositionPiece = position.slice(0, position.indexOf(\"[\"));\n  return (firstPositionPiece.substring(0, 1) === \"$\") ? firstPositionPiece : null;\n};\n","/*\n * PUBLIC API\n */\n\nSimpleSchemaValidationContext = function(ss) {\n  var self = this;\n  self._simpleSchema = ss;\n  self._schema = ss.schema();\n  self._schemaKeys = _.keys(self._schema);\n  self._invalidKeys = [];\n  //set up validation dependencies\n  self._deps = {};\n  self._depsAny = new Deps.Dependency;\n  _.each(self._schemaKeys, function(name) {\n    self._deps[name] = new Deps.Dependency;\n  });\n};\n\n//validates the object against the simple schema and sets a reactive array of error objects\nSimpleSchemaValidationContext.prototype.validate = function(doc, options) {\n  var self = this;\n  options = _.extend({\n    modifier: false,\n    upsert: false,\n    extendedCustomContext: {}\n  }, options || {});\n\n  //on the client we can add the userId if not already in the custom context\n  if (Meteor.isClient && options.extendedCustomContext.userId === void 0) {\n    options.extendedCustomContext.userId = (Meteor.userId && Meteor.userId()) || null;\n  }\n\n  var invalidKeys = doValidation(doc, options.modifier, options.upsert, null, self._simpleSchema, options.extendedCustomContext);\n\n  //now update self._invalidKeys and dependencies\n\n  //note any currently invalid keys so that we can mark them as changed\n  //due to new validation (they may be valid now, or invalid in a different way)\n  var removedKeys = _.pluck(self._invalidKeys, \"name\");\n\n  //update\n  self._invalidKeys = invalidKeys;\n\n  //add newly invalid keys to changedKeys\n  var addedKeys = _.pluck(self._invalidKeys, \"name\");\n\n  //mark all changed keys as changed\n  var changedKeys = _.union(addedKeys, removedKeys);\n  self._markKeysChanged(changedKeys);\n\n  // Return true if it was valid; otherwise, return false\n  return self._invalidKeys.length === 0;\n};\n\n//validates doc against self._schema for one key and sets a reactive array of error objects\nSimpleSchemaValidationContext.prototype.validateOne = function(doc, keyName, options) {\n  var self = this;\n  options = _.extend({\n    modifier: false,\n    upsert: false,\n    extendedCustomContext: {}\n  }, options || {});\n\n  //on the client we can add the userId if not already in the custom context\n  if (Meteor.isClient && options.extendedCustomContext.userId === void 0) {\n    options.extendedCustomContext.userId = (Meteor.userId && Meteor.userId()) || null;\n  }\n\n  var invalidKeys = doValidation(doc, options.modifier, options.upsert, keyName, self._simpleSchema, options.extendedCustomContext);\n\n  //now update self._invalidKeys and dependencies\n\n  //remove objects from self._invalidKeys where name = keyName\n  var newInvalidKeys = [];\n  for (var i = 0, ln = self._invalidKeys.length, k; i < ln; i++) {\n    k = self._invalidKeys[i];\n    if (k.name !== keyName) {\n      newInvalidKeys.push(k);\n    }\n  }\n  self._invalidKeys = newInvalidKeys;\n\n  //merge invalidKeys into self._invalidKeys\n  for (var i = 0, ln = invalidKeys.length, k; i < ln; i++) {\n    k = invalidKeys[i];\n    self._invalidKeys.push(k);\n  }\n\n  //mark key as changed due to new validation (they may be valid now, or invalid in a different way)\n  self._markKeysChanged([keyName]);\n\n  // Return true if it was valid; otherwise, return false\n  return !self._keyIsInvalid(keyName);\n};\n\n//reset the invalidKeys array\nSimpleSchemaValidationContext.prototype.resetValidation = function() {\n  var self = this;\n  var removedKeys = _.pluck(self._invalidKeys, \"name\");\n  self._invalidKeys = [];\n  self._markKeysChanged(removedKeys);\n};\n\nSimpleSchemaValidationContext.prototype.isValid = function() {\n  var self = this;\n  self._depsAny.depend();\n  return !self._invalidKeys.length;\n};\n\nSimpleSchemaValidationContext.prototype.invalidKeys = function() {\n  var self = this;\n  self._depsAny.depend();\n  return self._invalidKeys;\n};\n\nSimpleSchemaValidationContext.prototype.addInvalidKeys = function(errors) {\n  var self = this;\n\n  if (!errors || !errors.length)\n    return;\n\n  var changedKeys = [];\n  _.each(errors, function (errorObject) {\n    changedKeys.push(errorObject.name);\n    self._invalidKeys.push(errorObject);\n  });\n\n  self._markKeysChanged(changedKeys);\n};\n\nSimpleSchemaValidationContext.prototype._markKeysChanged = function(keys) {\n  var self = this;\n\n  if (!keys || !keys.length)\n    return;\n\n  _.each(keys, function(name) {\n    var genericName = SimpleSchema._makeGeneric(name);\n    if (genericName in self._deps) {\n      self._deps[genericName].changed();\n    }\n  });\n  self._depsAny.changed();\n};\n\nSimpleSchemaValidationContext.prototype._keyIsInvalid = function(name, genericName) {\n  var self = this;\n  genericName = genericName || SimpleSchema._makeGeneric(name);\n  var specificIsInvalid = !!_.findWhere(self._invalidKeys, {name: name});\n  var genericIsInvalid = (genericName !== name) ? (!!_.findWhere(self._invalidKeys, {name: genericName})) : false;\n  return specificIsInvalid || genericIsInvalid;\n};\n\nSimpleSchemaValidationContext.prototype.keyIsInvalid = function(name) {\n  var self = this, genericName = SimpleSchema._makeGeneric(name);\n  self._deps[genericName].depend();\n  return self._keyIsInvalid(name, genericName);\n};\n\nSimpleSchemaValidationContext.prototype.keyErrorMessage = function(name) {\n  var self = this, genericName = SimpleSchema._makeGeneric(name);\n  var ss = self._simpleSchema;\n  self._deps[genericName].depend();\n  \n  var errorObj = _.findWhere(self._invalidKeys, {name: name});\n  if (!errorObj) {\n    errorObj = _.findWhere(self._invalidKeys, {name: genericName});\n    if (!errorObj) {\n      return \"\";\n    }\n  }\n\n  var def = ss.schema(genericName);\n  if (!def) {\n    return \"\";\n  }\n  \n  return ss.messageForError(errorObj.type, errorObj.name, def, errorObj.value);\n};\n\n/*\n * PRIVATE\n */\n\nvar doValidation = function(obj, isModifier, isUpsert, keyToValidate, ss, extendedCustomContext) {\n  var setKeys = [];\n\n  // First do some basic checks of the object, and throw errors if necessary\n  if (!_.isObject(obj)) {\n    throw new Error(\"The first argument of validate() or validateOne() must be an object\");\n  }\n\n  if (isModifier) {\n    if (_.isEmpty(obj)) {\n      throw new Error(\"When the modifier option is true, validation object must have at least one operator\");\n    } else {\n      var allKeysAreOperators = _.every(obj, function(v, k) {\n        return (k.substring(0, 1) === \"$\");\n      });\n      if (!allKeysAreOperators) {\n        throw new Error(\"When the modifier option is true, all validation object keys must be operators\");\n      }\n\n      // Get a list of all keys in $set and $setOnInsert combined, for use later\n      setKeys = setKeys.concat(_.keys(obj.$set || {})).concat(_.keys(obj.$setOnInsert || {}));\n    }\n  } else if (looksLikeModifier(obj)) {\n    throw new Error(\"When the validation object contains mongo operators, you must set the modifier option to true\");\n  }\n\n  // If this is an upsert, add all the $setOnInsert keys to $set;\n  // since we don't know whether it will be an insert or update, we'll\n  // validate upserts as if they will be an insert.\n  if (\"$setOnInsert\" in obj) {\n    if (isUpsert) {\n      obj.$set = obj.$set || {};\n      obj.$set = _.extend(obj.$set, obj.$setOnInsert);\n    }\n    delete obj.$setOnInsert;\n  }\n\n  var invalidKeys = [];\n  var mDoc; // for caching the MongoObject if necessary\n\n  // Validation function called for each affected key\n  function validate(val, affectedKey, affectedKeyGeneric, def, op, skipRequiredCheck, strictRequiredCheck) {\n\n    // Get the schema for this key, marking invalid if there isn't one.\n    if (!def) {\n      invalidKeys.push(errorObject(\"keyNotInSchema\", affectedKey, val, def, ss));\n      return;\n    }\n\n    // Check for missing required values. The general logic is this:\n    // * If there's no operator, or if the operator is $set and it's an upsert,\n    //   val must not be undefined, null, or an empty string.\n    // * If there is an operator other than $unset or $rename, val must\n    //   not be null or an empty string, but undefined is OK.\n    // * If the operator is $unset or $rename, it's invalid.\n    if (!skipRequiredCheck && !def.optional) {\n      if (\n        op === \"$unset\" ||\n        op === \"$rename\" ||\n        ((!op || (op === \"$set\" && isUpsert) || strictRequiredCheck) && isBlankNullOrUndefined(val)) ||\n        (op && isBlankOrNull(val))\n        ) {\n        invalidKeys.push(errorObject(\"required\", affectedKey, null, def, ss));\n        return;\n      }\n    }\n\n    // For $rename, make sure that the new name is allowed by the schema\n    if (op === \"$rename\" && typeof val === \"string\" && !ss.allowsKey(val)) {\n      invalidKeys.push(errorObject(\"keyNotInSchema\", val, null, null, ss));\n      return;\n    }\n\n    // No further checking necessary for $unset or $rename\n    if (_.contains([\"$unset\", \"$rename\"], op)) {\n      return;\n    }\n\n    // Value checks are not necessary for null or undefined values\n    if (isSet(val)) {\n\n      // Check that value is of the correct type\n      var typeError = doTypeChecks(def, val, op);\n      if (typeError) {\n        invalidKeys.push(errorObject(typeError, affectedKey, val, def, ss));\n        return;\n      }\n\n      // Check value against allowedValues array\n      if (def.allowedValues && !_.contains(def.allowedValues, val)) {\n        invalidKeys.push(errorObject(\"notAllowed\", affectedKey, val, def, ss));\n        return;\n      }\n\n    }\n\n    // DEPRECATED: Check value using valusIsAllowed function\n    if (def.valueIsAllowed && !def.valueIsAllowed(val, obj, op)) {\n      console.warn(\"SimpleSchema: 'valueIsAllowed' is deprecated. Use 'custom' instead.\");\n      invalidKeys.push(errorObject(\"notAllowed\", affectedKey, val, def, ss));\n      return;\n    }\n\n    // Perform custom validation\n    var lastDot = affectedKey.lastIndexOf('.');\n    var fieldParentName = lastDot === -1 ? '' : affectedKey.slice(0, lastDot + 1);\n    var validators = def.custom ? [def.custom] : [];\n    validators = validators.concat(ss._validators).concat(SimpleSchema._validators);\n    _.every(validators, function(validator) {\n      var errorType = validator.call(_.extend({\n        key: affectedKey,\n        genericKey: affectedKeyGeneric,\n        definition: def,\n        isSet: (val !== void 0),\n        value: val,\n        operator: op,\n        field: function(fName) {\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed\n          var keyInfo = mDoc.getInfoForKey(fName) || {};\n          return {\n            isSet: (keyInfo.value !== void 0),\n            value: keyInfo.value,\n            operator: keyInfo.operator\n          };\n        },\n        siblingField: function(fName) {\n          mDoc = mDoc || new MongoObject(obj, ss._blackboxKeys); //create if necessary, cache for speed\n          var keyInfo = mDoc.getInfoForKey(fieldParentName + fName) || {};\n          return {\n            isSet: (keyInfo.value !== void 0),\n            value: keyInfo.value,\n            operator: keyInfo.operator\n          };\n        }\n      }, extendedCustomContext || {}), affectedKeyGeneric, val, def, op); //pass args for backwards compatibility; don't use them\n      if (typeof errorType === \"string\") {\n        invalidKeys.push(errorObject(errorType, affectedKey, val, def, ss));\n        return false;\n      }\n      return true;\n    });\n  }\n\n  // The recursive function\n  function checkObj(val, affectedKey, operator, adjusted, skipRequiredCheck, strictRequiredCheck) {\n    var affectedKeyGeneric, def, checkAllRequired = false;\n\n    // Adjust for first-level modifier operators\n    if (!operator && affectedKey && affectedKey.substring(0, 1) === \"$\") {\n      operator = affectedKey;\n      affectedKey = null;\n    }\n\n    if (affectedKey) {\n\n      // Adjust for $push and $addToSet\n      if (!adjusted && (operator === \"$push\" || operator === \"$addToSet\")) {\n        // Adjust for $each\n        // We can simply jump forward and pretend like the $each array\n        // is the array for the field. This has the added benefit of\n        // skipping past any $slice, which we also don't care about.\n        if (isBasicObject(val) && \"$each\" in val) {\n          val = val.$each;\n        } else {\n          affectedKey = affectedKey + \".0\";\n        }\n        checkAllRequired = adjusted = true;\n      }\n\n      // Make a generic version of the affected key, and use that\n      // to get the schema for this key.\n      affectedKeyGeneric = SimpleSchema._makeGeneric(affectedKey);\n      def = ss.schema(affectedKeyGeneric);\n\n      // We didn't find a schema for our key, so check if the key\n      // is a nested dot-syntax key inside of a blackbox object\n      if (!def) {\n        var parentPath = affectedKeyGeneric, lastDot;\n\n        // Iterate the dot-syntax hierarchy until we find a key in our schema\n        do {\n          lastDot = parentPath.lastIndexOf('.');\n          if (lastDot !== -1) {\n            parentPath = parentPath.slice(0, lastDot); // Remove last path component\n            def = ss.schema(parentPath);\n          }\n        } while (lastDot !== -1 && !def);\n\n        if (!def || !def.blackbox) {\n          def = null;\n        } else {\n          return; // The key points inside of a black box so our validation attempt ends\n        }\n      }\n\n      // Perform validation for this key\n      if (!keyToValidate || keyToValidate === affectedKey || keyToValidate === affectedKeyGeneric) {\n        validate(val, affectedKey, affectedKeyGeneric, def, operator, skipRequiredCheck, strictRequiredCheck);\n      }\n    }\n\n    // Temporarily convert missing objects to empty objects\n    // so that the looping code will be called and required\n    // descendent keys can be validated.\n    if ((val === void 0 || val === null) && (!def || (def.type === Object && !def.optional))) {\n      val = {};\n    }\n\n    // Loop through arrays\n    if (_.isArray(val)) {\n      _.each(val, function(v, i) {\n        checkObj(v, affectedKey + '.' + i, operator, adjusted);\n      });\n    }\n\n    // Loop through object keys\n    else if (isBasicObject(val) && (!def || !def.blackbox)) {\n      var presentKeys, requiredKeys, valueIsAllowedKeys, customKeys;\n\n      // Get list of present keys\n      presentKeys = _.keys(val);\n\n      if (!isModifier || operator === \"$set\" || checkAllRequired) {\n\n        // For required checks, we want to also loop through all keys expected\n        // based on the schema, in case any are missing.\n        requiredKeys = ss.requiredObjectKeys(affectedKeyGeneric);\n\n        // We want to be sure to call any present valueIsAllowed and custom functions\n        // even if the value isn't set, so they can be used for custom\n        // required errors, such as basing it on another field's value.\n        valueIsAllowedKeys = ss.valueIsAllowedObjectKeys(affectedKeyGeneric);\n        customKeys = ss.customObjectKeys(affectedKeyGeneric);\n      }\n\n      // Merge the lists\n      var keysToCheck = _.union(presentKeys, requiredKeys || [], valueIsAllowedKeys || [], customKeys || []);\n\n      // If this object is within an array, make sure we check for\n      // required as if it's not a modifier\n      var strictRequiredCheck = (affectedKeyGeneric && affectedKeyGeneric.slice(-2) === \".$\");\n\n      // Check all keys in the merged list\n      _.each(keysToCheck, function(key) {\n        if (shouldCheck(key)) {\n          // We can skip the required check for keys that are ancestors\n          // of those in $set or $setOnInsert because they will be created\n          // by MongoDB while setting.\n          skipRequiredCheck = _.some(setKeys, function(sk) {\n            return (sk.slice(0, key.length + 1) === key + \".\");\n          });\n          checkObj(val[key], appendAffectedKey(affectedKey, key), operator, adjusted, skipRequiredCheck, strictRequiredCheck);\n        }\n      });\n    }\n\n  }\n\n  // Kick off the validation\n  checkObj(obj);\n\n  // Make sure there is only one error per fieldName\n  var addedFieldNames = [];\n  invalidKeys = _.filter(invalidKeys, function(errObj) {\n    if (!_.contains(addedFieldNames, errObj.name)) {\n      addedFieldNames.push(errObj.name);\n      return true;\n    }\n    return false;\n  });\n\n  return invalidKeys;\n};\n\nvar doTypeChecks = function(def, keyValue, op) {\n  var expectedType = def.type;\n\n  // If min/max are functions, call them\n  var min = def.min;\n  var max = def.max;\n  if (typeof min === \"function\") {\n    min = min();\n  }\n  if (typeof max === \"function\") {\n    max = max();\n  }\n\n  // String checks\n  if (expectedType === String) {\n    if (typeof keyValue !== \"string\") {\n      return \"expectedString\";\n    } else if (max !== null && max < keyValue.length) {\n      return \"maxString\";\n    } else if (min !== null && min > keyValue.length) {\n      return \"minString\";\n    } else if (def.regEx instanceof RegExp && !def.regEx.test(keyValue)) {\n      return \"regEx\";\n    } else if (_.isArray(def.regEx)) {\n      var regExError;\n      _.every(def.regEx, function(re, i) {\n        if (!re.test(keyValue)) {\n          regExError = \"regEx.\" + i;\n          return false;\n        }\n        return true;\n      });\n      if (regExError)\n        return regExError;\n    }\n  }\n\n  // Number checks\n  else if (expectedType === Number) {\n    if (typeof keyValue !== \"number\" || isNaN(keyValue)) {\n      return \"expectedNumber\";\n    } else if (op !== \"$inc\" && max !== null && max < keyValue) {\n      return \"maxNumber\";\n    } else if (op !== \"$inc\" && min !== null && min > keyValue) {\n      return \"minNumber\";\n    } else if (!def.decimal && keyValue.toString().indexOf(\".\") > -1) {\n      return \"noDecimal\";\n    }\n  }\n\n  // Boolean checks\n  else if (expectedType === Boolean) {\n    if (typeof keyValue !== \"boolean\") {\n      return \"expectedBoolean\";\n    }\n  }\n\n  // Object checks\n  else if (expectedType === Object) {\n    if (!isBasicObject(keyValue)) {\n      return \"expectedObject\";\n    }\n  }\n\n  // Array checks\n  else if (expectedType === Array) {\n    if (!_.isArray(keyValue)) {\n      return \"expectedArray\";\n    } else if (def.minCount !== null && keyValue.length < def.minCount) {\n      return \"minCount\";\n    } else if (def.maxCount !== null && keyValue.length > def.maxCount) {\n      return \"maxCount\";\n    }\n  }\n\n  // Constructor function checks\n  else if (expectedType instanceof Function || safariBugFix(expectedType)) {\n\n    // Generic constructor checks\n    if (!(keyValue instanceof expectedType)) {\n      return \"expectedConstructor\";\n    }\n\n    // Date checks\n    else if (expectedType === Date) {\n      if (_.isDate(min) && min.getTime() > keyValue.getTime()) {\n        return \"minDate\";\n      } else if (_.isDate(max) && max.getTime() < keyValue.getTime()) {\n        return \"maxDate\";\n      }\n    }\n  }\n\n};\n\n/*\n * HELPERS\n */\n\nvar appendAffectedKey = function(affectedKey, key) {\n  if (key === \"$each\") {\n    return affectedKey;\n  } else {\n    return (affectedKey ? affectedKey + \".\" + key : key);\n  }\n};\n\nvar shouldCheck = function(key) {\n  if (key === \"$pushAll\") {\n    throw new Error(\"$pushAll is not supported; use $push + $each\");\n  }\n  return !_.contains([\"$pull\", \"$pullAll\", \"$pop\", \"$slice\"], key);\n};\n\nvar isBlank = function(str) {\n  if (typeof str !== \"string\") {\n    return false;\n  }\n  return (/^\\s*$/).test(str);\n};\n\nvar isBlankNullOrUndefined = function(str) {\n  return (str === void 0 || str === null || isBlank(str));\n};\n\nvar isBlankOrNull = function(str) {\n  return (str === null || isBlank(str));\n};\n\nvar errorObject = function(errorType, keyName, keyValue, def, ss) {\n  // TODO when we're sure nothing relies on the `message` prop anymore, retire it\n  // We should be getting error message dynamically from keyErrorMessage method\n  return {name: keyName, type: errorType, value: keyValue, message: ss.messageForError(errorType, keyName, def, keyValue)};\n};\n\n// Tests whether it's an Object as opposed to something that inherits from Object\nvar isBasicObject = function(obj) {\n  return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};\n\n// The latest Safari returns false for Uint8Array, etc. instanceof Function\n// unlike other browsers.\nvar safariBugFix = function(type) {\n  return (typeof Uint8Array !== \"undefined\" && type === Uint8Array)\n          || (typeof Uint16Array !== \"undefined\" && type === Uint16Array)\n          || (typeof Uint32Array !== \"undefined\" && type === Uint32Array)\n          || (typeof Uint8ClampedArray !== \"undefined\" && type === Uint8ClampedArray);\n};\n\nvar isSet = function(val) {\n  return val !== void 0 && val !== null;\n};"]}