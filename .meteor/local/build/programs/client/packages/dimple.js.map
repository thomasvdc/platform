)]}'
{"version":3,"file":"/packages/dimple.js","sources":["dimple/dimple.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,oC;AACA,qF;AACA,gC;;AAEA,yB;AACA,c;AACA,qB;AACA,a;AACA,uB;AACA,E;;AAEA,uB;;AAEA,yD;AACA,c;AACA,iB;;AAEA,wC;AACA,yF;AACA,yC;AACA,wE;AACA,kF;;AAEA,uF;AACA,2B;AACA,0F;AACA,iC;AACA,gG;AACA,sH;AACA,yF;AACA,+B;AACA,2F;AACA,mC;AACA,kG;AACA,kC;AACA,wF;AACA,4B;AACA,6F;AACA,iC;AACA,wF;AACA,2B;AACA,6F;AACA,gC;AACA,6F;AACA,gC;AACA,wF;AACA,2B;AACA,+F;AACA,kC;AACA,gG;AACA,mC;AACA,4F;AACA,+B;AACA,iG;AACA,oC;AACA,4F;AACA,+B;AACA,4F;AACA,+B;AACA,8F;AACA,8B;AACA,wF;AACA,4B;AACA,yF;AACA,0B;;AAEA,oD;AACA,2B;AACA,8C;AACA,sB;AACA,sB;AACA,+D;AACA,2B;AACA,oC;AACA,4B;AACA,qC;AACA,8B;AACA,2C;AACA,mC;;;AAGA,4C;AACA,6F;AACA,qD;AACA,0B;;;AAGA,4C;AACA,6F;AACA,0D;AACA,uC;AACA,6B;AACA,oB;AACA,oB;AACA,oB;AACA,uB;AACA,uB;AACA,mB;AACA,4E;AACA,2C;AACA,mE;AACA,wB;AACA,8D;AACA,iB;AACA,0C;AACA,8C;AACA,8D;AACA,sE;AACA,4E;AACA,gC;AACA,6C;AACA,yE;AACA,iE;AACA,uD;AACA,4G;AACA,gG;AACA,kB;AACA,+C;AACA,oE;AACA,oE;AACA,uD;AACA,8B;AACA,oE;AACA,kE;AACA,yD;AACA,iD;AACA,+G;AACA,sB;AACA,wB;AACA,4C;AACA,8D;AACA,iB;AACA,oB;AACA,0D;AACA,a;AACA,gC;AACA,U;;AAEA,4C;AACA,6F;AACA,8D;AACA,2C;AACA,uC;AACA,4C;AACA,gC;AACA,6C;AACA,oG;AACA,iH;AACA,mH;AACA,+E;AACA,gD;AACA,gD;AACA,wD;AACA,gD;AACA,0D;AACA,8C;AACA,2D;AACA,6C;AACA,4D;AACA,8C;AACA,6D;AACA,+C;AACA,wB;AACA,8C;AACA,iB;AACA,a;AACA,8B;AACA,6B;AACA,U;;;AAGA,4C;AACA,6F;AACA,8D;AACA,2C;AACA,yH;AACA,U;;;AAGA,4C;AACA,6F;AACA,2D;AACA,wC;AACA,yE;AACA,U;;;AAGA,4C;AACA,6F;AACA,6D;AACA,0C;AACA,6E;AACA,U;;;AAGA,4C;AACA,6F;AACA,0D;AACA,6C;AACA,uC;AACA,wB;AACA,sF;AACA,4G;AACA,4F;AACA,qC;AACA,oE;AACA,+C;AACA,wB;AACA,qG;AACA,iD;AACA,iD;AACA,iB;AACA,oB;AACA,6E;AACA,a;AACA,8B;AACA,2B;AACA,U;;;AAGA,4C;AACA,6F;AACA,uD;AACA,4C;;AAEA,kC;AACA,sB;AACA,qB;AACA,0B;AACA,uB;AACA,uE;AACA,0D;AACA,6D;AACA,0C;AACA,qC;AACA,sC;AACA,4C;AACA,0B;AACA,yC;AACA,yD;AACA,+D;AACA,+E;AACA,yG;AACA,2C;AACA,kC;AACA,yB;AACA,qB;AACA,kC;AACA,oF;AACA,gE;AACA,+E;AACA,2D;AACA,4C;AACA,6B;AACA,iC;AACA,qB;AACA,8F;AACA,oF;AACA,kB;;AAEA,oG;AACA,mF;AACA,8E;AACA,4E;;AAEA,+C;AACA,mF;AACA,mF;;AAEA,mC;AACA,wC;AACA,2C;AACA,iD;AACA,+G;AACA,wD;AACA,yC;AACA,gD;AACA,0G;AACA,iC;AACA,uF;AACA,2F;AACA,0B;AACA,oC;AACA,2C;AACA,gC;AACA,iF;AACA,wE;AACA,oD;AACA,gH;AACA,2D;AACA,wB;AACA,mD;AACA,0G;AACA,+D;AACA,iB;AACA,uG;AACA,mC;AACA,+D;AACA,2B;AACA,kD;AACA,6C;AACA,gD;AACA,8B;AACA,2B;AACA,kD;AACA,0C;AACA,gD;AACA,8B;AACA,4B;AACA,8B;AACA,qB;AACA,iB;AACA,+C;AACA,2C;AACA,iD;AACA,gH;AACA,wD;AACA,yC;AACA,gD;AACA,2G;AACA,iC;AACA,uF;AACA,2F;AACA,0B;AACA,oC;AACA,2C;AACA,gC;AACA,iF;AACA,wE;AACA,oD;AACA,iH;AACA,2D;AACA,wB;AACA,mD;AACA,2G;AACA,uD;AACA,gC;AACA,iB;AACA,uG;AACA,mC;AACA,+D;AACA,2B;AACA,kD;AACA,2C;AACA,gD;AACA,8B;AACA,2B;AACA,kD;AACA,4C;AACA,gD;AACA,8B;AACA,4B;AACA,8B;AACA,qB;AACA,iB;AACA,8E;AACA,kC;AACA,gD;AACA,mG;AACA,iC;AACA,uF;AACA,2F;AACA,0B;AACA,oC;AACA,4C;AACA,wB;AACA,mD;AACA,mG;AACA,wD;AACA,iB;AACA,8E;AACA,+C;AACA,gH;AACA,oD;AACA,a;AACA,0D;AACA,gS;;AAEA,kE;AACA,8C;AACA,6C;AACA,2C;AACA,oC;AACA,wE;;AAEA,+C;AACA,sC;AACA,qC;AACA,mE;AACA,oE;AACA,oH;AACA,uC;AACA,iB;AACA,a;;AAEA,yG;AACA,4G;AACA,+B;AACA,iG;AACA,6D;AACA,oB;AACA,+C;AACA,a;;AAEA,0C;AACA,uF;AACA,sC;AACA,a;;AAEA,uC;AACA,wB;AACA,U;;;AAGA,4C;AACA,6F;AACA,iE;AACA,mG;AACA,4D;AACA,6E;AACA,U;AACA,4C;AACA,6F;AACA,4D;AACA,8F;AACA,uD;AACA,wE;AACA,U;AACA,M;AACA,sB;;;AAGA,wC;AACA,yF;AACA,0C;AACA,yE;AACA,yC;;AAEA,sF;AACA,uB;AACA,oF;AACA,uB;AACA,oF;AACA,uB;AACA,wF;AACA,2B;AACA,yF;AACA,4B;AACA,uF;AACA,yB;AACA,4F;AACA,+B;AACA,uF;AACA,uB;AACA,yF;AACA,yB;AACA,0F;AACA,0B;AACA,6F;AACA,+B;AACA,6F;AACA,+B;AACA,yF;AACA,2B;;AAEA,oE;AACA,sC;AACA,wF;AACA,+F;AACA,yE;AACA,kC;AACA,mE;AACA,kC;AACA,4F;AACA,4B;;AAEA,4C;AACA,6F;AACA,2D;AACA,+G;AACA,sI;AACA,wD;;AAEA,sB;AACA,8B;AACA,2B;;AAEA,uD;AACA,4C;AACA,sC;AACA,0B;AACA,iB;AACA,uH;AACA,mC;AACA,iB;AACA,a;;AAEA,yB;;AAEA,U;;;AAGA,4C;AACA,6F;AACA,4D;AACA,4C;AACA,wC;AACA,oF;AACA,gC;AACA,kD;AACA,wF;AACA,0D;AACA,a;AACA,0C;AACA,8F;AACA,kD;AACA,uF;AACA,+D;AACA,qB;AACA,mB;AACA,a;AACA,uC;AACA,8B;AACA,U;;;AAGA,4C;AACA,6F;AACA,+D;AACA,+E;AACA,2C;AACA,kC;AACA,oE;AACA,yC;AACA,uD;AACA,+C;AACA,wC;AACA,wH;AACA,qF;AACA,yD;AACA,iD;AACA,gD;AACA,2D;AACA,2F;AACA,mE;AACA,gF;AACA,mE;AACA,6C;AACA,iC;AACA,6B;AACA,+C;AACA,0B;AACA,yE;AACA,8E;AACA,kH;AACA,6D;AACA,oK;AACA,yG;AACA,yD;AACA,+D;AACA,4B;AACA,0D;AACA,uC;AACA,uC;AACA,2D;AACA,4B;AACA,sC;AACA,oD;AACA,uC;AACA,gD;AACA,kC;AACA,wC;AACA,kC;AACA,wC;AACA,mC;AACA,8D;AACA,wC;;AAEA,iI;AACA,qE;AACA,2H;AACA,qB;;AAEA,uC;AACA,8E;AACA,0D;AACA,2J;AACA,qB;AACA,8E;AACA,0D;AACA,2J;AACA,qB;;AAEA,oI;AACA,wI;AACA,4H;AACA,8D;AACA,6D;AACA,oG;AACA,qF;AACA,2G;AACA,qF;AACA,4D;AACA,qF;AACA,4D;AACA,qF;AACA,yB;AACA,kG;AACA,qB;;AAEA,qD;AACA,4C;AACA,8C;AACA,oI;AACA,yB;AACA,+D;AACA,oG;AACA,yB;AACA,+D;AACA,oG;AACA,yB;AACA,oE;AACA,8H;AACA,yB;AACA,2C;AACA,uB;;AAEA,mF;AACA,qD;AACA,0C;AACA,4C;AACA,2D;AACA,2D;AACA,2D;AACA,0F;AACA,0C;AACA,gC;AACA,8B;AACA,mC;AACA,uC;AACA,0I;AACA,+C;AACA,qH;AACA,kE;AACA,gC;AACA,0E;AACA,sD;AACA,qC;AACA,yB;AACA,oC;AACA,4H;AACA,qE;AACA,oE;AACA,4D;AACA,+C;AACA,sC;AACA,6B;AACA,yB;AACA,iE;AACA,gD;AACA,sC;AACA,yC;AACA,mD;AACA,+C;AACA,6C;AACA,0C;AACA,+C;AACA,6C;AACA,0C;AACA,+C;AACA,6C;AACA,0C;AACA,0C;AACA,0C;AACA,qC;AACA,qC;AACA,2C;AACA,2C;AACA,yC;AACA,0C;AACA,sC;AACA,sC;AACA,0C;AACA,0C;AACA,+C;AACA,+C;AACA,+C;AACA,+C;AACA,yC;AACA,0C;AACA,8B;AACA,oD;AACA,+D;AACA,yB;;AAEA,qE;AACA,kE;AACA,sD;AACA,6D;AACA,6D;AACA,iD;AACA,6C;AACA,uC;AACA,sD;AACA,8E;AACA,qF;AACA,gD;AACA,uD;AACA,qC;AACA,sD;AACA,oF;AACA,yC;AACA,6B;AACA,sE;AACA,qD;AACA,oE;AACA,6D;AACA,yE;AACA,4E;AACA,gE;AACA,yC;AACA,sJ;AACA,kH;AACA,sG;AACA,yC;AACA,4J;AACA,sF;AACA,iF;AACA,2E;AACA,yC;AACA,4F;AACA,oF;AACA,oF;AACA,oE;AACA,qG;AACA,6E;AACA,qC;AACA,iC;AACA,6B;AACA,0B;AACA,8C;AACA,8D;AACA,8D;AACA,8D;AACA,8D;AACA,6B;AACA,0D;AACA,8K;AACA,wC;AACA,qD;AACA,0F;AACA,yB;AACA,2J;AACA,qB;AACA,8K;AACA,wC;AACA,qD;AACA,0F;AACA,yB;AACA,2J;AACA,sD;AACA,qB;AACA,uD;AACA,gD;AACA,4F;AACA,uN;AACA,iE;AACA,yB;AACA,gD;AACA,4F;AACA,uN;AACA,iE;AACA,yB;AACA,gD;AACA,4F;AACA,uN;AACA,iE;AACA,yB;AACA,gD;AACA,2H;AACA,2H;AACA,yB;AACA,6B;AACA,gF;;AAEA,mE;AACA,mH;AACA,mH;AACA,mH;;AAEA,uD;AACA,sC;AACA,wC;AACA,kC;AACA,qC;AACA,4C;AACA,sE;AACA,+C;AACA,0C;AACA,gD;AACA,wC;AACA,6C;AACA,0E;AACA,wD;AACA,iE;AACA,yJ;AACA,8G;AACA,oN;AACA,kK;AACA,0D;AACA,4I;AACA,4C;AACA,iE;AACA,gG;AACA,4K;AACA,uF;AACA,wJ;AACA,2E;AACA,6C;AACA,mL;AACA,8D;AACA,gJ;AACA,gD;AACA,8F;AACA,0D;AACA,gK;AACA,4H;AACA,8F;AACA,6C;AACA,yC;AACA,qC;AACA,iC;AACA,8B;AACA,4D;AACA,6D;AACA,wD;;AAEA,mD;AACA,wG;AACA,0D;AACA,sE;AACA,uD;AACA,uD;AACA,6B;AACA,uI;AACA,+I;AACA,oF;AACA,6J;AACA,6J;AACA,0J;AACA,yE;AACA,yM;AACA,yD;AACA,8E;AACA,iE;AACA,oD;AACA,6B;AACA,iE;AACA,4H;AACA,uE;AACA,oG;AACA,iI;AACA,0F;AACA,2F;AACA,oC;AACA,4D;AACA,oG;AACA,6B;AACA,mE;AACA,oH;AACA,oH;AACA,oH;AACA,wD;AACA,4D;AACA,0E;AACA,yB;;AAEA,6B;;AAEA,sD;AACA,sD;;AAEA,yB;AACA,a;AACA,U;;;AAGA,4C;AACA,6F;AACA,8D;AACA,gE;AACA,0C;AACA,wE;AACA,U;;AAEA,4C;AACA,6F;AACA,uE;AACA,2D;AACA,yD;AACA,qF;AACA,sE;AACA,sC;AACA,sG;AACA,4G;AACA,yG;AACA,wF;AACA,qD;AACA,gC;AACA,mD;AACA,yB;AACA,mE;AACA,2D;AACA,mE;AACA,uF;AACA,6B;AACA,uD;AACA,2C;AACA,2C;AACA,2C;AACA,oD;AACA,2D;AACA,8D;AACA,mD;AACA,2B;AACA,qB;AACA,yB;AACA,a;AACA,U;;;AAGA,4C;AACA,6F;AACA,6D;AACA,+D;AACA,yC;AACA,uE;AACA,U;AACA,4C;AACA,6F;AACA,yD;AACA,0E;AACA,qC;AACA,mE;AACA,U;AACA,4C;AACA,6F;AACA,yD;AACA,0E;AACA,qC;AACA,mE;AACA,U;AACA,4C;AACA,6F;AACA,wD;AACA,0F;AACA,gF;AACA,6F;AACA,0E;AACA,2D;AACA,a;AACA,oE;AACA,uC;AACA,qB;AACA,yB;AACA,+B;AACA,wB;AACA,yB;AACA,c;AACA,sD;AACA,iC;AACA,8B;AACA,wB;AACA,U;;;AAGA,4C;AACA,6F;AACA,gE;AACA,kG;AACA,oE;AACA,gE;AACA,U;;;AAGA,4C;AACA,6F;AACA,6D;AACA,+F;AACA,wD;AACA,6D;AACA,oG;AACA,6B;AACA,U;;;AAGA,0D;AACA,4F;AACA,kF;AACA,wC;AACA,iG;AACA,qH;AACA,gC;AACA,+F;AACA,0C;AACA,sC;AACA,uC;AACA,0B;AACA,U;AACA,4C;AACA,6F;AACA,2D;AACA,6F;AACA,kE;AACA,oE;AACA,4D;AACA,uC;AACA,a;AACA,+B;AACA,wB;AACA,U;AACA,4C;AACA,6F;AACA,+D;AACA,iG;AACA,4D;AACA,yD;AACA,U;;;AAGA,4C;AACA,6F;AACA,2D;AACA,6F;AACA,oE;AACA,+B;AACA,kE;AACA,sE;AACA,oB;AACA,iE;AACA,a;AACA,uC;AACA,2B;AACA,U;;;AAGA,4C;AACA,6F;AACA,0D;AACA,4F;AACA,wE;AACA,uC;AACA,0E;AACA,yC;AACA,2G;AACA,uD;AACA,6B;AACA,6B;AACA,6B;AACA,iC;AACA,uB;AACA,+D;AACA,0C;AACA,8F;AACA,qE;AACA,qC;AACA,4E;AACA,qC;AACA,4E;AACA,qC;AACA,gF;AACA,yC;AACA,qB;AACA,iB;AACA,qB;AACA,yD;AACA,0E;AACA,2D;AACA,a;AACA,qC;AACA,uC;AACA,qB;AACA,+B;AACA,sB;AACA,sB;AACA,sB;AACA,0B;AACA,6B;AACA,2C;AACA,oC;AACA,c;AACA,kD;AACA,qC;AACA,gC;AACA,0B;AACA,U;;;AAGA,4C;AACA,6F;AACA,4D;AACA,8F;AACA,sF;AACA,qE;AACA,2C;AACA,+C;AACA,wB;AACA,U;;;AAGA,4C;AACA,6F;AACA,4D;AACA,8F;AACA,kE;AACA,gF;AACA,6C;AACA,U;;;AAGA,4C;AACA,6F;AACA,8D;AACA,gG;AACA,8B;AACA,gD;AACA,+C;AACA,kD;AACA,iD;AACA,kD;AACA,kD;AACA,qD;AACA,qD;AACA,uD;AACA,oD;AACA,gD;AACA,gD;AACA,U;AACA,4C;AACA,6F;AACA,qD;AACA,uF;AACA,uD;AACA,2C;AACA,oF;AACA,sC;AACA,8B;AACA,8B;AACA,6B;AACA,iC;AACA,iC;AACA,yC;AACA,yC;AACA,iD;AACA,mD;;AAEA,iG;AACA,8C;AACA,gG;AACA,sC;AACA,a;;AAEA,8F;AACA,kG;AACA,+C;AACA,8B;AACA,8B;AACA,oD;AACA,yC;AACA,sD;AACA,uC;AACA,6C;AACA,2D;AACA,iD;AACA,6D;AACA,6C;AACA,2E;AACA,mF;AACA,mF;AACA,0C;AACA,yB;AACA,6B;AACA,kG;AACA,2G;AACA,kC;AACA,kC;AACA,iE;AACA,6F;AACA,6F;AACA,iC;AACA,qB;AACA,kD;AACA,iE;AACA,qC;AACA,qC;AACA,6D;AACA,oE;AACA,mE;AACA,2C;AACA,yB;AACA,mE;AACA,2C;AACA,yB;AACA,6B;AACA,mD;AACA,mF;AACA,kC;AACA,sC;AACA,6D;AACA,qF;AACA,yE;AACA,yB;AACA,6B;AACA,oD;AACA,iB;;;AAGA,kE;AACA,+B;;AAEA,mE;AACA,+D;AACA,kC;AACA,sE;AACA,kC;AACA,iB;AACA,qB;AACA,qC;AACA,+C;AACA,mD;AACA,sC;AACA,qC;AACA,iC;AACA,yC;AACA,gC;AACA,oC;AACA,+B;AACA,iE;AACA,+B;AACA,+B;AACA,gC;AACA,iC;AACA,mD;AACA,0L;AACA,gF;AACA,iG;AACA,oD;AACA,4C;AACA,gC;AACA,4C;AACA,yB;AACA,qB;AACA,wB;AACA,gD;AACA,wC;AACA,4B;AACA,wC;AACA,qB;AACA,iB;AACA,2C;AACA,uE;AACA,gF;AACA,qC;AACA,iB;AACA,kF;AACA,yD;AACA,yK;AACA,8G;AACA,4C;AACA,gE;AACA,2J;AACA,6G;AACA,2C;AACA,mD;AACA,0H;AACA,4C;AACA,mD;AACA,yH;AACA,2C;AACA,iB;AACA,gC;AACA,+I;AACA,+D;AACA,6C;AACA,kC;AACA,4E;AACA,uC;AACA,4B;AACA,uE;AACA,qB;AACA,qC;AACA,kB;AACA,gE;;AAEA,wC;AACA,+C;AACA,6K;AACA,6C;AACA,2H;AACA,4B;AACA,6H;AACA,qB;AACA,uD;AACA,mJ;AACA,qB;AACA,yC;AACA,8E;AACA,oD;AACA,+G;AACA,2D;AACA,qH;AACA,yB;AACA,qB;AACA,8H;AACA,wI;AACA,kE;AACA,wH;AACA,8H;AACA,yB;AACA,wH;AACA,uH;AACA,yB;AACA,qB;AACA,iB;AACA,8C;AACA,sC;AACA,8D;AACA,2D;AACA,oG;AACA,oE;AACA,8C;AACA,iD;AACA,gE;AACA,uD;AACA,0E;AACA,kD;AACA,yD;AACA,mD;AACA,qB;AACA,iB;AACA,gF;AACA,0E;AACA,0C;AACA,yG;AACA,mC;AACA,wE;AACA,iE;AACA,+D;AACA,2B;AACA,4F;AACA,2C;AACA,yD;AACA,8D;AACA,mD;AACA,6D;AACA,mD;AACA,2I;AACA,mC;AACA,gC;AACA,mF;AACA,4C;AACA,yD;AACA,+D;AACA,uD;AACA,yB;AACA,uD;AACA,yG;AACA,mC;AACA,qD;AACA,+C;AACA,qE;AACA,mE;AACA,+B;AACA,4F;AACA,2C;AACA,yD;AACA,4D;AACA,mD;AACA,6D;AACA,mD;AACA,wJ;AACA,mC;AACA,gC;AACA,mF;AACA,4C;AACA,yD;AACA,+D;AACA,uD;AACA,yB;AACA,qB;AACA,iB;AACA,gF;AACA,6C;AACA,iB;AACA,qD;AACA,6C;AACA,uC;AACA,iD;AACA,wE;AACA,mD;AACA,yB;AACA,0E;AACA,sD;AACA,yB;AACA,sC;AACA,2F;AACA,uE;AACA,6B;AACA,mF;AACA,+D;AACA,6B;AACA,gC;AACA,kE;AACA,8C;AACA,6B;AACA,2E;AACA,uD;AACA,6B;AACA,yB;AACA,uB;;AAEA,4C;AACA,0C;AACA,kE;AACA,4B;AACA,qD;AACA,qB;AACA,uD;AACA,mD;AACA,0C;AACA,qD;AACA,4B;AACA,kE;AACA,qB;AACA,wD;AACA,2E;AACA,iB;;AAEA,2C;AACA,uF;AACA,6F;AACA,mC;AACA,0C;AACA,0C;AACA,sD;AACA,kD;AACA,qL;AACA,2C;AACA,mD;AACA,+C;AACA,uE;AACA,gH;AACA,6B;AACA,2B;;AAEA,4G;AACA,4C;AACA,0C;AACA,0D;AACA,6F;AACA,2B;AACA,iD;AACA,0D;AACA,6F;AACA,2B;AACA,qB;AACA,iB;AACA,mB;AACA,qB;;AAEA,iC;AACA,mD;AACA,yD;AACA,oD;AACA,qB;;AAEA,kC;AACA,oD;AACA,uC;AACA,qB;;AAEA,4C;AACA,4E;AACA,4C;AACA,+C;AACA,qD;AACA,iB;AACA,a;;AAEA,4C;AACA,wB;;AAEA,U;;AAEA,4C;AACA,6F;AACA,yD;AACA,2F;AACA,wC;AACA,kD;AACA,gG;AACA,gF;AACA,oF;AACA,a;AACA,+B;AACA,6C;AACA,U;;;AAGA,4C;AACA,6F;AACA,0D;AACA,4F;AACA,yD;AACA,0C;AACA,uB;AACA,uB;AACA,+B;AACA,iC;AACA,yD;AACA,yC;AACA,uE;AACA,c;AACA,yD;AACA,yC;AACA,uE;AACA,c;AACA,6D;AACA,6C;AACA,2E;AACA,c;AACA,6D;AACA,8C;AACA,4E;AACA,c;AACA,qE;AACA,+B;AACA,0D;AACA,wB;AACA,U;;;AAGA,4C;AACA,6F;AACA,2D;AACA,6F;AACA,+D;AACA,2E;AACA,0B;AACA,yB;AACA,2B;AACA,4B;AACA,yD;AACA,yC;AACA,uE;AACA,c;AACA,yD;AACA,yC;AACA,uE;AACA,c;AACA,6D;AACA,6C;AACA,+H;AACA,c;AACA,6D;AACA,8C;AACA,iI;AACA,c;AACA,qE;AACA,+B;AACA,0D;AACA,wB;AACA,U;;;AAGA,4C;AACA,6F;AACA,8D;AACA,gG;AACA,qE;AACA,+C;AACA,0E;AACA,oC;AACA,oE;AACA,qD;AACA,a;AACA,oC;AACA,mC;AACA,U;;AAEA,M;AACA,uB;;;AAGA,wC;AACA,yF;AACA,0C;AACA,yE;AACA,qD;;AAEA,uF;AACA,yB;AACA,yF;AACA,+G;AACA,0F;AACA,mF;;AAEA,M;AACA,uB;;;AAGA,wC;AACA,yF;AACA,8C;AACA,6E;AACA,oC;;AAEA,kG;AACA,gC;AACA,6F;AACA,2B;AACA,6F;AACA,2B;AACA,6F;AACA,2B;AACA,iG;AACA,+B;AACA,iG;AACA,+B;AACA,mG;AACA,iC;AACA,oG;AACA,kC;;AAEA,M;AACA,2B;;;AAGA,wC;AACA,yF;AACA,2C;AACA,0E;AACA,oF;;AAEA,yF;AACA,2B;AACA,0F;AACA,6B;AACA,qF;AACA,mB;AACA,qF;AACA,mB;AACA,yF;AACA,2B;AACA,0F;AACA,6B;AACA,mG;AACA,+C;AACA,0F;AACA,2B;AACA,4C;AACA,6F;AACA,uD;AACA,4B;AACA,0C;;AAEA,yE;AACA,iD;AACA,6B;AACA,8B;AACA,6B;AACA,6B;AACA,8B;AACA,8B;AACA,4B;AACA,4B;;AAEA,2E;AACA,oE;AACA,2B;AACA,iC;AACA,6C;AACA,uC;AACA,8B;AACA,a;;AAEA,kE;AACA,yF;AACA,+B;AACA,2C;AACA,4C;AACA,kC;AACA,wB;AACA,4B;AACA,4C;AACA,wC;;AAEA,sC;AACA,sC;AACA,uE;AACA,4C;AACA,mC;AACA,iC;AACA,kB;AACA,mC;AACA,gD;AACA,+D;AACA,qI;AACA,oE;AACA,qB;AACA,kB;AACA,mC;AACA,2C;AACA,6C;AACA,2C;AACA,qB;AACA,+C;AACA,6C;AACA,qB;AACA,mB;;AAEA,6C;AACA,sC;AACA,2C;AACA,0C;AACA,0C;;AAEA,mG;AACA,2B;AACA,4E;AACA,sC;;AAEA,iG;AACA,uB;AACA,oC;AACA,oE;AACA,qC;AACA,8C;AACA,qB;AACA,0D;AACA,iD;AACA,4B;AACA,sD;AACA,oM;AACA,oD;AACA,mG;AACA,wE;AACA,iG;AACA,8B;AACA,+D;AACA,kE;AACA,sD;AACA,8D;AACA,sK;AACA,kE;AACA,sD;AACA,qD;AACA,iH;AACA,qH;AACA,uH;AACA,oE;AACA,6C;AACA,qB;AACA,mB;;AAEA,0D;AACA,uB;AACA,6B;AACA,sC;AACA,yC;AACA,oC;;AAEA,+E;AACA,sC;AACA,U;;AAEA,4C;AACA,6F;AACA,6D;AACA,iE;AACA,wC;AACA,wD;AACA,6B;AACA,uC;AACA,oE;AACA,oD;AACA,uD;AACA,0C;AACA,oD;AACA,kD;AACA,iD;AACA,4D;AACA,uC;AACA,8B;AACA,iE;AACA,+E;AACA,0C;AACA,sC;AACA,6B;AACA,yB;AACA,2C;AACA,yF;AACA,yJ;AACA,uD;AACA,yB;AACA,uB;AACA,yB;AACA,a;AACA,2B;AACA,U;;AAEA,4C;AACA,6F;AACA,+D;AACA,kE;AACA,0C;AACA,8E;AACA,U;;AAEA,4C;AACA,6F;AACA,8D;AACA,iE;AACA,yC;AACA,6E;AACA,U;AACA,4C;AACA,6F;AACA,0D;AACA,4E;AACA,qC;AACA,yE;AACA,U;AACA,4C;AACA,6F;AACA,0D;AACA,4E;AACA,qC;AACA,yE;AACA,U;AACA,M;AACA,wB;;;AAGA,wC;AACA,yF;AACA,2C;AACA,0E;AACA,gI;;AAEA,yF;AACA,2B;AACA,qF;AACA,uB;AACA,qF;AACA,uB;AACA,qF;AACA,uB;AACA,qF;AACA,2B;AACA,wF;AACA,iC;AACA,kG;AACA,6C;AACA,qG;AACA,2C;AACA,2F;AACA,+B;AACA,0F;AACA,0B;AACA,iG;AACA,iC;AACA,8F;AACA,4B;AACA,+F;AACA,iC;;AAEA,mD;AACA,iC;AACA,6C;AACA,gC;AACA,qC;AACA,8B;;AAEA,4C;AACA,6F;AACA,6D;AACA,gD;AACA,4C;AACA,uD;AACA,mC;AACA,yD;AACA,qC;AACA,uD;AACA,oC;AACA,uD;AACA,6B;AACA,4B;AACA,0B;AACA,6B;AACA,6C;;AAEA,oG;AACA,mC;AACA,qC;AACA,uC;AACA,0C;AACA,qC;AACA,uC;AACA,0C;AACA,qC;AACA,0C;AACA,qC;AACA,a;;AAEA,yD;AACA,0C;AACA,mC;AACA,8C;AACA,yE;AACA,uE;AACA,qB;AACA,yE;AACA,uE;AACA,qB;AACA,yB;AACA,sI;AACA,8C;AACA,qD;AACA,yG;AACA,uJ;AACA,oE;AACA,wF;AACA,gC;AACA,wF;AACA,yB;AACA,4B;AACA,8F;AACA,6E;AACA,2E;AACA,yB;AACA,6E;AACA,2E;AACA,yB;AACA,qB;AACA,yB;AACA,oB;AACA,wI;AACA,6D;AACA,6D;AACA,0E;AACA,kC;AACA,8C;AACA,yE;AACA,uD;AACA,4D;AACA,uC;AACA,iD;AACA,wD;AACA,qB;AACA,iD;AACA,8D;AACA,mE;AACA,gD;AACA,iD;AACA,yB;AACA,qB;AACA,gF;AACA,yD;AACA,uC;AACA,iD;AACA,mG;AACA,gC;AACA,mG;AACA,yB;AACA,4B;AACA,8F;AACA,yE;AACA,uE;AACA,yB;AACA,yE;AACA,uE;AACA,yB;AACA,qB;AACA,yB;AACA,0D;AACA,+C;AACA,sD;AACA,oD;AACA,yB;AACA,sD;AACA,oD;AACA,yB;AACA,qB;AACA,yB;AACA,a;AACA,0B;AACA,U;;;AAGA,4C;AACA,6F;AACA,iE;AACA,2C;;AAEA,8D;AACA,2B;AACA,2B;AACA,2D;AACA,yB;AACA,+D;AACA,4B;AACA,gE;AACA,2B;AACA,kB;AACA,+C;AACA,6B;AACA,4B;AACA,2B;AACA,kB;AACA,iD;AACA,qD;AACA,oE;AACA,+C;AACA,4D;AACA,4B;AACA,mD;AACA,qB;AACA,2E;AACA,+C;AACA,yF;AACA,4B;AACA,mD;AACA,qB;AACA,iB;AACA,qB;AACA,4D;AACA,qD;AACA,8D;AACA,0C;AACA,gE;AACA,2C;AACA,kD;AACA,kD;AACA,4D;AACA,yB;AACA,qB;AACA,gC;AACA,qE;AACA,0C;AACA,gE;AACA,2C;AACA,kD;AACA,kD;AACA,wF;AACA,yB;AACA,qB;AACA,gC;AACA,iB;AACA,qB;;AAEA,qC;AACA,yB;AACA,U;AACA,4C;AACA,6F;AACA,iE;AACA,mG;AACA,0D;AACA,yE;AACA,U;;;AAGA,4C;AACA,6F;AACA,8D;AACA,gG;AACA,uD;AACA,wE;AACA,U;AACA,M;AACA,wB;;;AAGA,wC;AACA,yF;AACA,+C;AACA,8E;AACA,0D;;AAEA,kD;AACA,sE;AACA,uD;AACA,S;;AAEA,6F;AACA,2B;AACA,sG;AACA,6C;AACA,gG;AACA,6B;AACA,qG;AACA,kC;AACA,kG;AACA,+B;AACA,8F;AACA,2B;;AAEA,kC;AACA,wB;AACA,iC;AACA,oC;AACA,8B;AACA,8B;AACA,2D;AACA,wC;AACA,gD;AACA,8B;;AAEA,4C;AACA,6F;AACA,8D;AACA,8C;AACA,4E;AACA,uC;AACA,+B;AACA,+C;AACA,sD;AACA,6C;AACA,oC;AACA,qB;AACA,yB;AACA,kE;AACA,wF;AACA,gK;AACA,uC;AACA,+C;AACA,mE;AACA,gI;AACA,yB;AACA,uB;AACA,a;AACA,2B;AACA,sD;AACA,oC;AACA,2B;AACA,mD;AACA,mF;AACA,sD;AACA,oC;AACA,U;;;AAGA,4C;AACA,6F;AACA,oE;AACA,0C;AACA,sE;AACA,kC;AACA,sC;AACA,gD;AACA,+D;AACA,4F;AACA,mC;AACA,mC;AACA,+I;AACA,uD;AACA,uE;AACA,wC;AACA,6C;AACA,6B;AACA,4C;AACA,iC;AACA,gE;AACA,2C;AACA,yD;AACA,gE;AACA,yB;AACA,qB;AACA,yB;AACA,sC;AACA,kE;AACA,a;AACA,+B;AACA,oC;AACA,U;AACA,4C;AACA,6F;AACA,qE;AACA,iD;AACA,+D;AACA,2F;AACA,oD;AACA,U;;;AAGA,4C;AACA,6F;AACA,kE;AACA,oG;AACA,uD;AACA,wE;AACA,U;AACA,4C;AACA,6F;AACA,mE;AACA,0C;AACA,mC;AACA,iF;AACA,iE;AACA,a;AACA,+B;AACA,U;;;AAGA,4C;AACA,6F;AACA,+D;AACA,+C;AACA,mD;AACA,qE;AACA,4C;AACA,a;AACA,U;;;AAGA,4C;AACA,6F;AACA,oE;AACA,2C;AACA,gD;AACA,2D;AACA,4C;AACA,a;AACA,U;;;AAGA,4C;AACA,6F;AACA,oE;AACA,2C;AACA,gD;AACA,gF;AACA,kF;AACA,wC;AACA,0E;AACA,yD;AACA,0E;AACA,yB;AACA,2E;AACA,sB;AACA,8C;AACA,a;AACA,U;;;AAGA,4C;AACA,6F;AACA,mE;AACA,0C;AACA,gD;AACA,2D;AACA,4C;AACA,gC;AACA,a;AACA,U;;;AAGA,M;AACA,4B;;;AAGA,wC;AACA,yF;AACA,kD;AACA,sD;AACA,gG;AACA,gG;AACA,gG;AACA,gG;AACA,6F;AACA,M;;AAEA,wC;AACA,yF;AACA,oD;AACA,wD;AACA,gG;AACA,gG;AACA,qC;AACA,M;;AAEA,wC;AACA,yF;AACA,kD;AACA,sD;AACA,gG;AACA,gG;AACA,6D;AACA,M;;AAEA,wC;AACA,yF;AACA,kD;AACA,sD;AACA,8J;AACA,M;;AAEA,wC;AACA,yF;AACA,kD;AACA,sD;AACA,gG;AACA,gG;AACA,qC;AACA,M;;AAEA,wC;AACA,yF;AACA,wC;AACA,wB;AACA,sB;;AAEA,uC;;AAEA,kD;AACA,mD;AACA,4B;AACA,4C;AACA,kC;AACA,6B;AACA,+B;AACA,qB;AACA,+B;AACA,wB;AACA,4B;;AAEA,oF;AACA,6C;AACA,a;;AAEA,8F;AACA,mF;AACA,yE;AACA,6B;AACA,a;AACA,uC;AACA,gC;AACA,kC;AACA,sB;AACA,mE;AACA,+C;AACA,iB;AACA,mD;AACA,8D;AACA,yB;AACA,6B;AACA,wD;AACA,iB;AACA,qB;;AAEA,kL;AACA,8B;AACA,6D;AACA,uM;AACA,2M;AACA,yB;AACA,a;;AAEA,gC;AACA,qF;AACA,sF;;AAEA,wE;AACA,+D;AACA,uC;AACA,4B;AACA,2C;AACA,4F;AACA,a;;AAEA,yB;AACA,mC;AACA,6B;AACA,mC;AACA,gG;AACA,yC;AACA,mC;AACA,sC;AACA,gC;AACA,4B;AACA,+B;AACA,0B;AACA,0B;AACA,0B;AACA,0B;AACA,0B;AACA,wE;AACA,qD;AACA,0C;AACA,wD;AACA,+H;AACA,+D;AACA,+H;AACA,yB;AACA,yC;AACA,uB;AACA,qE;AACA,4C;AACA,+F;AACA,wD;AACA,mD;AACA,+C;AACA,qD;AACA,yD;AACA,yF;AACA,sE;AACA,2D;AACA,oC;AACA,wC;AACA,wF;AACA,iE;AACA,6F;AACA,6G;AACA,oD;AACA,yC;AACA,qC;AACA,iC;AACA,gD;AACA,6B;AACA,kD;AACA,+D;AACA,+D;AACA,mD;AACA,+C;AACA,uD;AACA,yD;AACA,yF;AACA,sE;AACA,2D;AACA,oC;AACA,wC;AACA,wF;AACA,iE;AACA,6F;AACA,6G;AACA,oD;AACA,yC;AACA,qC;AACA,iC;AACA,gD;AACA,6B;AACA,kD;AACA,+D;AACA,yB;AACA,qB;AACA,kF;AACA,mF;AACA,kB;AACA,mC;AACA,2C;AACA,uK;AACA,6K;AACA,qE;AACA,qB;AACA,mB;;AAEA,qC;AACA,wF;AACA,oF;AACA,wB;AACA,iG;AACA,iB;AACA,sB;AACA,2B;AACA,4B;AACA,qC;AACA,+D;AACA,iD;AACA,8F;AACA,8F;AACA,iC;AACA,0C;AACA,4C;;AAEA,yB;AACA,2B;AACA,oD;AACA,8F;AACA,8F;AACA,sD;AACA,yB;AACA,2B;AACA,2B;AACA,oD;AACA,iC;AACA,8C;AACA,iD;AACA,uB;AACA,kD;AACA,a;;AAEA,0E;AACA,4E;AACA,wE;AACA,oB;AACA,qF;AACA,a;;;AAGA,uG;AACA,iC;AACA,mB;AACA,wB;AACA,iC;AACA,2D;AACA,yC;AACA,+C;AACA,mE;AACA,kB;AACA,gD;AACA,mE;AACA,kB;AACA,0F;AACA,0F;AACA,6B;AACA,+G;AACA,mC;AACA,2C;AACA,kD;AACA,qE;AACA,0D;AACA,oJ;AACA,+B;AACA,qB;AACA,mB;;AAEA,mB;AACA,gD;AACA,0F;AACA,0F;AACA,iD;AACA,mC;AACA,2C;AACA,kD;AACA,qE;AACA,0D;AACA,oJ;AACA,+B;AACA,qB;AACA,mB;;AAEA,mB;AACA,uB;AACA,gD;AACA,6B;AACA,0C;AACA,6C;AACA,mB;;AAEA,kD;AACA,sC;AACA,U;;AAEA,uC;AACA,+D;;AAEA,sD;AACA,+B;AACA,4D;AACA,iC;AACA,qD;AACA,mC;AACA,kE;AACA,iD;AACA,0D;AACA,0D;AACA,wD;AACA,oE;AACA,8D;AACA,oD;AACA,6E;AACA,0C;AACA,kE;AACA,kE;AACA,iE;AACA,kB;AACA,2E;AACA,wC;AACA,kE;AACA,kE;AACA,iE;AACA,kB;AACA,kB;AACA,sB;AACA,sB;AACA,sB;AACA,oB;AACA,wB;AACA,0B;;AAEA,oF;AACA,6C;AACA,a;AACA,wD;;AAEA,gE;AACA,8C;AACA,+C;AACA,gD;AACA,+B;AACA,+B;AACA,6B;AACA,mC;AACA,sC;AACA,sC;AACA,yC;AACA,6B;AACA,2C;AACA,+B;AACA,uC;AACA,qC;AACA,8C;;AAEA,4C;AACA,sC;AACA,kD;AACA,mC;AACA,4E;AACA,mC;AACA,4E;AACA,0C;AACA,0C;AACA,6C;AACA,wD;AACA,8C;AACA,iC;AACA,gD;AACA,mD;AACA,uC;AACA,sF;AACA,0F;AACA,oC;AACA,yF;AACA,a;;AAEA,4C;AACA,sC;AACA,kD;AACA,4E;AACA,mC;AACA,4E;AACA,mC;AACA,0C;AACA,0C;AACA,6C;AACA,wD;AACA,8C;AACA,iC;AACA,gD;AACA,mD;AACA,uC;AACA,sF;AACA,0F;AACA,oC;AACA,yF;AACA,a;;AAEA,mC;AACA,gD;AACA,2D;AACA,kC;AACA,0C;;AAEA,wC;AACA,4H;AACA,+D;AACA,2F;AACA,qF;AACA,yB;AACA,a;;AAEA,2C;AACA,0F;AACA,mD;AACA,4C;AACA,iE;AACA,2F;AACA,iF;AACA,yB;AACA,oB;AACA,6C;AACA,oF;AACA,a;;AAEA,2C;AACA,0F;AACA,mD;AACA,4C;AACA,iE;AACA,iF;AACA,yB;AACA,oB;AACA,6C;AACA,qF;AACA,a;;AAEA,8D;AACA,6C;AACA,qF;AACA,a;;AAEA,8D;AACA,6C;AACA,qF;AACA,a;;AAEA,kG;AACA,oD;AACA,kD;AACA,e;;AAEA,8D;AACA,8D;AACA,+B;AACA,6C;AACA,qD;AACA,uD;AACA,gD;;AAEA,6D;AACA,gC;AACA,0E;AACA,2E;AACA,e;;AAEA,gF;AACA,oD;AACA,+B;AACA,6B;AACA,wC;AACA,+C;AACA,+C;AACA,4D;AACA,2D;AACA,mB;;AAEA,yD;AACA,sC;AACA,uC;AACA,iE;AACA,kD;AACA,8B;AACA,8B;AACA,8C;AACA,kD;AACA,yC;AACA,wC;;AAEA,gG;AACA,2G;;AAEA,6G;AACA,8C;AACA,oH;AACA,wD;AACA,qB;AACA,U;;AAEA,uC;AACA,+D;AACA,+C;AACA,oH;AACA,oF;AACA,6C;AACA,a;AACA,S;AACA,M;;;AAGA,wC;AACA,yF;AACA,uC;AACA,uB;;AAEA,8E;AACA,sB;;AAEA,2D;AACA,uC;;AAEA,yB;AACA,kD;;AAEA,mD;AACA,4B;AACA,sC;AACA,iD;AACA,wG;AACA,mC;AACA,oE;;AAEA,oF;AACA,6C;AACA,a;;AAEA,wE;AACA,sF;AACA,oB;AACA,4F;AACA,a;;AAEA,kB;AACA,uB;AACA,wB;AACA,+B;AACA,2D;AACA,6C;AACA,gD;AACA,yE;AACA,uE;AACA,gE;AACA,kB;AACA,wF;AACA,mI;AACA,gJ;AACA,kJ;AACA,oG;AACA,+C;AACA,mE;AACA,kB;AACA,+C;AACA,kD;AACA,kB;AACA,mC;AACA,2C;AACA,0G;AACA,+G;AACA,qB;AACA,mB;;AAEA,qB;AACA,uB;AACA,gD;AACA,wF;AACA,wF;AACA,gG;AACA,kG;AACA,mC;AACA,2C;AACA,0G;AACA,+G;AACA,qB;AACA,mB;;AAEA,qB;AACA,uB;AACA,uB;AACA,gD;AACA,wF;AACA,wF;AACA,gG;AACA,kG;AACA,0C;AACA,6C;AACA,mB;;AAEA,kD;AACA,wC;AACA,U;;AAEA,uC;AACA,+D;;AAEA,sD;AACA,+B;AACA,4D;AACA,iC;AACA,qD;AACA,mC;AACA,kE;AACA,iD;AACA,wD;AACA,wD;AACA,gE;AACA,kE;AACA,wD;AACA,kD;AACA,oD;AACA,6E;AACA,0C;AACA,kE;AACA,kE;AACA,iE;AACA,kB;AACA,2E;AACA,wC;AACA,kE;AACA,kE;AACA,iE;AACA,kB;AACA,kB;AACA,oB;AACA,0B;AACA,4D;AACA,6B;AACA,0D;AACA,sB;AACA,sB;AACA,4C;AACA,2B;AACA,2B;;AAEA,oF;AACA,6C;AACA,a;AACA,wD;;AAEA,4C;AACA,oE;AACA,kD;AACA,+E;AACA,kE;AACA,+E;AACA,kE;AACA,0C;AACA,0C;AACA,6C;AACA,wD;AACA,8C;AACA,iC;AACA,gD;AACA,mD;AACA,uC;AACA,sF;AACA,0F;AACA,oC;AACA,wF;AACA,a;;AAEA,4C;AACA,oE;AACA,kD;AACA,iE;AACA,gF;AACA,iE;AACA,gF;AACA,0C;AACA,0C;AACA,6C;AACA,wD;AACA,8C;AACA,iC;AACA,gD;AACA,mD;AACA,uC;AACA,sF;AACA,0F;AACA,oC;AACA,wF;AACA,a;;AAEA,mC;AACA,gD;AACA,2D;AACA,kC;AACA,0C;;AAEA,wC;AACA,4H;AACA,+D;AACA,2F;AACA,qF;AACA,yB;AACA,a;;AAEA,2C;AACA,0F;AACA,mD;AACA,4C;AACA,iE;AACA,2F;AACA,iF;AACA,yB;AACA,oB;AACA,6C;AACA,oF;AACA,a;;AAEA,2C;AACA,0F;AACA,mD;AACA,4C;AACA,iE;AACA,iF;AACA,yB;AACA,oB;AACA,6C;AACA,qF;AACA,a;;AAEA,8D;AACA,6C;AACA,qH;AACA,a;;AAEA,kG;AACA,oD;AACA,kD;AACA,e;;AAEA,8D;AACA,8D;AACA,+B;AACA,6C;AACA,qD;AACA,uD;AACA,gD;;AAEA,6D;AACA,gC;AACA,0E;AACA,2E;AACA,e;;AAEA,gF;AACA,oD;AACA,+B;AACA,6B;AACA,wC;AACA,+C;AACA,sD;AACA,4D;AACA,kE;AACA,mB;;AAEA,yD;AACA,sC;AACA,uC;AACA,wE;AACA,kD;AACA,8B;AACA,8B;AACA,8C;AACA,kD;AACA,yC;AACA,wC;;AAEA,uE;AACA,0G;AACA,oC;AACA,oE;AACA,sF;AACA,0F;AACA,gE;AACA,mC;AACA,kE;AACA,sF;AACA,0F;AACA,0H;AACA,oC;AACA,0E;AACA,2D;AACA,kD;AACA,yE;AACA,gC;AACA,yB;AACA,oB;AACA,oC;AACA,0E;AACA,+D;AACA,kD;AACA,yE;AACA,gC;AACA,yB;AACA,a;AACA,U;;AAEA,uC;AACA,6C;AACA,oF;AACA,6C;AACA,a;AACA,S;AACA,M;;;AAGA,wC;AACA,yF;AACA,0C;AACA,0B;;AAEA,uD;AACA,uB;;AAEA,yD;AACA,4C;;AAEA,wB;AACA,kD;;AAEA,mD;AACA,4B;AACA,sC;AACA,iD;AACA,wG;AACA,mC;AACA,oE;;AAEA,oF;AACA,6C;AACA,a;;AAEA,wE;AACA,sF;AACA,oB;AACA,4F;AACA,a;;AAEA,kB;AACA,uB;AACA,wB;AACA,iC;AACA,2D;AACA,6C;AACA,mD;AACA,yE;AACA,uE;AACA,uE;AACA,gE;AACA,kB;AACA,0C;AACA,iH;AACA,kB;AACA,0C;AACA,iH;AACA,kB;AACA,6B;AACA,oG;AACA,+C;AACA,mE;AACA,kB;AACA,+C;AACA,kD;AACA,kB;AACA,mC;AACA,2C;AACA,0G;AACA,+G;AACA,qB;AACA,mB;;AAEA,qB;AACA,uB;AACA,gD;AACA,0F;AACA,0F;AACA,wF;AACA,mC;AACA,2C;AACA,0G;AACA,+G;AACA,qB;AACA,mB;;AAEA,qB;AACA,uB;AACA,uB;AACA,gD;AACA,6B;AACA,0C;AACA,iH;AACA,kB;AACA,0C;AACA,iH;AACA,kB;AACA,0C;AACA,6C;AACA,mB;;AAEA,kD;AACA,wC;AACA,U;;AAEA,uC;AACA,+D;;AAEA,sD;AACA,+B;AACA,4D;AACA,iC;AACA,qD;AACA,mC;AACA,kE;AACA,iD;AACA,0D;AACA,0D;AACA,wD;AACA,wD;AACA,kD;AACA,oD;AACA,6E;AACA,0C;AACA,kE;AACA,kE;AACA,iE;AACA,kB;AACA,2E;AACA,wC;AACA,kE;AACA,kE;AACA,iE;AACA,kB;AACA,kB;AACA,oB;AACA,0B;AACA,4D;AACA,sB;AACA,0D;AACA,sB;AACA,sB;AACA,wB;;AAEA,oF;AACA,6C;AACA,a;AACA,wD;;AAEA,+C;AACA,gD;AACA,+B;AACA,+B;AACA,6B;AACA,mC;AACA,sC;AACA,sC;AACA,yC;AACA,6B;AACA,+C;AACA,mC;AACA,2C;AACA,yC;AACA,kD;;AAEA,4C;AACA,sC;AACA,kD;AACA,mC;AACA,4E;AACA,mC;AACA,4E;AACA,0C;AACA,0C;AACA,6C;AACA,wD;AACA,8C;AACA,iC;AACA,gD;AACA,mD;AACA,uC;AACA,0F;AACA,8F;AACA,wC;AACA,6F;AACA,a;;AAEA,4C;AACA,sC;AACA,kD;AACA,4E;AACA,mC;AACA,4E;AACA,mC;AACA,0C;AACA,0C;AACA,6C;AACA,wD;AACA,8C;AACA,iC;AACA,gD;AACA,mD;AACA,uC;AACA,0F;AACA,8F;AACA,wC;AACA,6F;AACA,a;;AAEA,mC;AACA,gD;AACA,2D;AACA,kC;AACA,0C;;AAEA,wC;AACA,4H;AACA,+D;AACA,2F;AACA,qF;AACA,yB;AACA,a;;AAEA,2C;AACA,0F;AACA,mD;AACA,4C;AACA,iE;AACA,2F;AACA,iF;AACA,yB;AACA,oB;AACA,6C;AACA,iF;AACA,a;;AAEA,2C;AACA,0F;AACA,mD;AACA,4C;AACA,iE;AACA,iF;AACA,yB;AACA,oB;AACA,6C;AACA,iF;AACA,a;;AAEA,8D;AACA,6C;AACA,qF;AACA,a;;AAEA,8D;AACA,6C;AACA,qF;AACA,a;;AAEA,kG;AACA,oD;AACA,kD;AACA,e;;AAEA,8D;AACA,8D;AACA,+B;AACA,6C;AACA,qD;AACA,uD;AACA,gD;;AAEA,6D;AACA,gC;AACA,0E;AACA,2E;AACA,e;;AAEA,gF;AACA,oD;AACA,+B;AACA,6B;AACA,wC;AACA,+C;AACA,+C;AACA,4D;AACA,2D;AACA,mB;;AAEA,yD;AACA,sC;AACA,uC;AACA,iE;AACA,kD;AACA,8B;AACA,8B;AACA,8C;AACA,kD;AACA,yC;AACA,wC;;AAEA,gG;AACA,2G;;AAEA,6G;AACA,8C;AACA,oH;AACA,wD;AACA,qB;AACA,U;;AAEA,uC;AACA,6C;AACA,oF;AACA,6C;AACA,a;AACA,S;AACA,M;;;AAGA,wC;AACA,yF;AACA,wC;AACA,wB;AACA,uB;AACA,uC;AACA,kD;;AAEA,mD;AACA,4B;AACA,4C;AACA,6B;AACA,kC;AACA,kG;AACA,uF;AACA,6B;AACA,+B;AACA,qB;AACA,wB;AACA,4B;;AAEA,oF;AACA,6C;AACA,a;;AAEA,yE;AACA,6B;AACA,a;;AAEA,uC;AACA,gC;AACA,kC;AACA,sB;;AAEA,mE;AACA,+C;AACA,iB;;AAEA,mD;AACA,wE;AACA,yB;;AAEA,6B;AACA,8C;AACA,iB;;AAEA,qB;;AAEA,kL;AACA,8B;AACA,6D;AACA,uM;AACA,yB;AACA,a;;AAEA,gC;AACA,iF;AACA,kF;;AAEA,wE;AACA,+D;AACA,uC;AACA,4B;AACA,2C;AACA,gG;AACA,a;AACA,yB;AACA,mC;AACA,gD;AACA,0G;AACA,yC;AACA,wC;AACA,+C;AACA,uC;AACA,8B;AACA,2E;AACA,6E;AACA,yB;AACA,kC;AACA,+C;AACA,yB;AACA,6B;AACA,qD;AACA,0C;AACA,wD;AACA,+H;AACA,+D;AACA,+H;AACA,yB;AACA,yC;AACA,uB;AACA,kD;AACA,sC;AACA,iF;AACA,iF;AACA,6E;AACA,yE;AACA,2B;AACA,iD;AACA,qB;AACA,4C;AACA,kB;AACA,mC;AACA,2C;AACA,iD;AACA,4L;AACA,qE;AACA,qB;AACA,mB;;AAEA,qC;AACA,wF;AACA,oF;AACA,wB;AACA,iG;AACA,iB;AACA,sB;AACA,2B;AACA,4B;AACA,qC;AACA,+D;AACA,iD;AACA,8F;AACA,8F;AACA,iC;AACA,0C;AACA,4C;;AAEA,yB;AACA,2B;AACA,oD;AACA,8F;AACA,8F;AACA,sD;AACA,yB;AACA,2B;AACA,2B;AACA,oD;AACA,iC;AACA,8C;AACA,iD;AACA,uB;AACA,kD;AACA,a;;AAEA,0E;AACA,4E;AACA,wE;AACA,oB;AACA,qF;AACA,a;;;AAGA,uG;AACA,iC;AACA,mB;AACA,wB;AACA,iC;AACA,2D;AACA,yC;AACA,+C;AACA,mE;AACA,kB;AACA,gD;AACA,mE;AACA,kB;AACA,0F;AACA,0F;AACA,6B;AACA,+G;AACA,mC;AACA,2C;AACA,kD;AACA,qE;AACA,0D;AACA,oJ;AACA,+B;AACA,qB;AACA,mB;;AAEA,mB;AACA,gD;AACA,0F;AACA,0F;AACA,iD;AACA,mC;AACA,2C;AACA,kD;AACA,qE;AACA,0D;AACA,oJ;AACA,+B;AACA,qB;AACA,mB;;AAEA,mB;AACA,uB;AACA,gD;AACA,6B;AACA,0C;AACA,6C;AACA,mB;;AAEA,kD;AACA,sC;;AAEA,mE;AACA,sC;AACA,+C;AACA,kC;AACA,4B;AACA,qC;AACA,8D;AACA,8D;AACA,iD;AACA,wE;AACA,uC;AACA,+C;AACA,+E;AACA,wD;AACA,yB;AACA,uB;AACA,a;AACA,U;;AAEA,uC;AACA,+D;;AAEA,sD;AACA,+B;AACA,4D;AACA,iC;AACA,qD;AACA,mC;AACA,kE;AACA,iD;AACA,0D;AACA,0D;AACA,wD;AACA,oE;AACA,oD;AACA,oD;AACA,6E;AACA,0C;AACA,kE;AACA,kE;AACA,iE;AACA,kB;AACA,2E;AACA,wC;AACA,kE;AACA,kE;AACA,iE;AACA,kB;AACA,4D;AACA,sB;AACA,0D;AACA,sB;AACA,sB;AACA,kB;AACA,oB;AACA,0B;AACA,wB;;AAEA,oF;AACA,6C;AACA,a;AACA,wD;;AAEA,gE;AACA,8C;;AAEA,+C;AACA,gD;AACA,+B;AACA,+B;AACA,6B;AACA,mC;AACA,sC;AACA,sC;AACA,yC;AACA,6B;AACA,+C;AACA,mC;AACA,2C;AACA,6D;AACA,kD;;AAEA,4C;AACA,sC;AACA,kD;AACA,mC;AACA,oH;AACA,mC;AACA,oH;AACA,0C;AACA,0C;AACA,6C;AACA,wD;AACA,8C;AACA,iC;AACA,gD;AACA,mD;AACA,uC;AACA,0F;AACA,8F;AACA,wC;AACA,6F;AACA,a;;AAEA,4C;AACA,sC;AACA,kD;AACA,oH;AACA,mC;AACA,oH;AACA,mC;AACA,0C;AACA,0C;AACA,6C;AACA,wD;AACA,8C;AACA,iC;AACA,gD;AACA,mD;AACA,uC;AACA,0F;AACA,8F;AACA,wC;AACA,6F;AACA,a;;AAEA,mC;AACA,gD;AACA,2D;AACA,kC;AACA,0C;;AAEA,wC;AACA,4H;AACA,+D;AACA,2F;AACA,qF;AACA,yB;AACA,a;;AAEA,2C;AACA,0F;AACA,mD;AACA,4C;AACA,iE;AACA,2F;AACA,iF;AACA,yB;AACA,yC;AACA,qC;AACA,0D;AACA,oB;AACA,6C;AACA,iF;AACA,a;;AAEA,2C;AACA,0F;AACA,mD;AACA,4C;AACA,iE;AACA,iF;AACA,yB;AACA,yC;AACA,qC;AACA,0D;AACA,oB;AACA,6C;AACA,iF;AACA,a;;AAEA,8D;AACA,6C;AACA,qF;AACA,a;;AAEA,8D;AACA,6C;AACA,qF;AACA,a;;AAEA,kG;AACA,oD;AACA,kD;AACA,e;;AAEA,8D;AACA,8D;AACA,+B;AACA,6C;AACA,qD;AACA,uD;AACA,gD;;AAEA,6D;AACA,gC;AACA,0E;AACA,2E;AACA,e;;AAEA,gF;AACA,oD;AACA,+B;AACA,6B;AACA,wC;AACA,+C;AACA,+C;AACA,4D;AACA,2D;AACA,mB;;AAEA,yD;AACA,sC;AACA,uC;AACA,iE;AACA,kD;AACA,8B;AACA,8B;AACA,8C;AACA,kD;AACA,yC;AACA,wC;;AAEA,gG;AACA,2G;;AAEA,6G;AACA,8C;AACA,oH;AACA,wD;AACA,qB;AACA,U;;AAEA,uC;AACA,+D;AACA,+C;AACA,oH;AACA,oF;AACA,6C;AACA,a;AACA,S;AACA,M;;;AAGA,wC;AACA,yF;AACA,2C;AACA,0G;;AAEA,iD;AACA,sB;AACA,oD;AACA,8B;AACA,wB;;AAEA,mC;AACA,gD;AACA,oC;AACA,a;AACA,iB;;AAEA,sG;;AAEA,mC;AACA,+B;AACA,wD;AACA,+B;AACA,wD;AACA,4I;AACA,6I;AACA,0J;AACA,4J;AACA,S;;AAEA,wC;;AAEA,yB;AACA,sB;;AAEA,qD;AACA,yH;AACA,kC;AACA,0B;AACA,iB;AACA,a;;AAEA,gH;AACA,iB;;AAEA,yB;AACA,kC;AACA,6B;AACA,gD;AACA,iE;AACA,qE;AACA,gB;AACA,kC;AACA,6B;AACA,wB;AACA,+B;AACA,iE;AACA,qE;AACA,S;AACA,M;;;AAGA,wC;AACA,yF;AACA,4D;AACA,2E;AACA,4B;AACA,2B;AACA,4B;AACA,iC;AACA,sB;AACA,oD;AACA,0E;AACA,iD;AACA,S;AACA,4B;AACA,iE;AACA,6D;AACA,qC;AACA,sB;AACA,qD;AACA,wC;AACA,wF;AACA,2C;AACA,qB;AACA,iB;AACA,0D;AACA,0C;AACA,a;AACA,iB;AACA,6D;AACA,iD;AACA,+B;AACA,+C;AACA,4C;AACA,yC;AACA,4C;AACA,4F;AACA,4C;AACA,oC;AACA,6E;AACA,4C;AACA,sC;AACA,8B;AACA,+D;AACA,kD;AACA,0C;AACA,sC;AACA,oC;AACA,8D;AACA,6B;AACA,yB;AACA,qC;AACA,sB;AACA,+C;AACA,uC;AACA,0C;AACA,0C;AACA,uF;AACA,yE;AACA,0F;AACA,yE;AACA,iD;AACA,wC;AACA,iD;AACA,uC;AACA,yB;AACA,sC;AACA,sB;AACA,4D;AACA,qD;AACA,wD;AACA,oD;AACA,gE;AACA,uB;AACA,uD;AACA,+D;AACA,+D;AACA,8E;AACA,oD;AACA,mD;AACA,kE;AACA,6B;AACA,0D;AACA,oD;AACA,2D;AACA,2D;AACA,gC;AACA,gC;AACA,8F;AACA,+F;AACA,uD;AACA,uD;AACA,gF;AACA,gF;AACA,6D;AACA,uB;AACA,wB;AACA,oC;AACA,oD;AACA,2C;AACA,uC;AACA,yC;AACA,+E;AACA,kE;AACA,uF;AACA,yB;AACA,wD;AACA,uB;AACA,iB;AACA,e;AACA,6C;AACA,kC;AACA,+B;AACA,sE;AACA,wD;AACA,mC;AACA,iB;AACA,8B;AACA,e;AACA,yE;AACA,wE;AACA,6C;AACA,8C;AACA,qB;AACA,S;AACA,kC;AACA,0B;AACA,M;;;AAGA,wC;AACA,yF;AACA,uC;AACA,uB;;AAEA,0C;AACA,yC;AACA,6B;AACA,8E;AACA,iD;AACA,0F;AACA,8M;AACA,oB;AACA,gG;AACA,a;AACA,4B;AACA,U;;AAEA,0C;AACA,yC;AACA,6B;AACA,8E;AACA,iD;AACA,0I;AACA,6P;AACA,oB;AACA,iG;AACA,a;AACA,4B;AACA,U;;AAEA,+B;AACA,wC;AACA,4B;AACA,8D;AACA,4B;AACA,gD;AACA,+C;AACA,oB;AACA,uE;AACA,a;AACA,2B;AACA,U;;AAEA,kD;AACA,wC;AACA,+B;AACA,qG;AACA,0H;AACA,a;AACA,8B;AACA,U;;AAEA,kE;AACA,kD;AACA,sC;AACA,0L;AACA,uM;AACA,a;AACA,qC;AACA,U;;AAEA,kD;AACA,wC;AACA,+B;AACA,qG;AACA,2H;AACA,a;AACA,8B;AACA,U;;AAEA,kE;AACA,kD;AACA,sC;AACA,0L;AACA,yM;AACA,a;AACA,qC;AACA,U;;AAEA,gE;AACA,wC;AACA,4B;AACA,2C;AACA,+F;AACA,qF;AACA,+C;AACA,oB;AACA,mP;AACA,a;AACA,2B;AACA,U;;AAEA,gE;AACA,wC;AACA,4B;AACA,2C;AACA,gG;AACA,qF;AACA,+C;AACA,oB;AACA,gS;AACA,a;AACA,2B;AACA,U;;AAEA,kD;AACA,4C;AACA,gC;AACA,8E;AACA,0H;AACA,kD;AACA,wD;AACA,oB;AACA,mL;AACA,a;AACA,+B;AACA,U;;AAEA,mD;AACA,6C;AACA,iC;AACA,2C;AACA,yD;AACA,qF;AACA,8H;AACA,oB;AACA,sL;AACA,a;AACA,gC;AACA,U;;AAEA,2C;AACA,8C;AACA,kC;AACA,8D;AACA,0C;AACA,oB;AACA,gF;AACA,a;AACA,iC;AACA,U;;AAEA,iD;AACA,2C;AACA,+B;AACA,8D;AACA,oC;AACA,oB;AACA,0E;AACA,a;AACA,8B;AACA,U;;AAEA,mD;AACA,6C;AACA,2B;AACA,8D;AACA,kC;AACA,oB;AACA,wE;AACA,a;AACA,0B;AACA,S;;AAEA,M;;;AAGA,wC;AACA,yF;AACA,4C;AACA,8C;AACA,8D;AACA,8C;AACA,8B;AACA,oF;AACA,8C;AACA,S;AACA,mE;AACA,gE;AACA,kF;AACA,oF;AACA,6C;AACA,oF;AACA,gF;AACA,iD;AACA,gC;AACA,oB;AACA,2D;AACA,0G;AACA,a;AACA,S;AACA,2B;AACA,M;;AAEA,wC;AACA,yF;AACA,2C;AACA,6C;AACA,8D;AACA,6C;AACA,8B;AACA,oF;AACA,6C;AACA,S;AACA,mE;AACA,gE;AACA,kF;AACA,oF;AACA,6C;AACA,oF;AACA,gF;AACA,iD;AACA,gC;AACA,oB;AACA,2D;AACA,yG;AACA,a;AACA,S;AACA,2B;AACA,M;;AAEA,wC;AACA,yF;AACA,8C;AACA,uD;AACA,4B;AACA,iD;AACA,qC;AACA,gD;AACA,gC;AACA,iD;AACA,iD;AACA,8G;AACA,kD;AACA,wE;AACA,wB;AACA,wC;AACA,iB;AACA,a;AACA,iB;AACA,2B;AACA,M;;AAEA,wC;AACA,yF;AACA,8C;AACA,uD;AACA,4B;AACA,iD;AACA,qC;AACA,gD;AACA,gC;AACA,iD;AACA,iD;AACA,+G;AACA,kD;AACA,wE;AACA,wB;AACA,wC;AACA,iB;AACA,a;AACA,iB;AACA,2B;AACA,M;;AAEA,wC;AACA,yF;AACA,sC;AACA,6D;;AAEA,4B;AACA,qD;AACA,sD;AACA,uC;AACA,gB;AACA,wB;AACA,S;AACA,wC;AACA,mC;AACA,oE;AACA,2B;AACA,4B;AACA,6B;AACA,8D;AACA,gD;AACA,mC;AACA,wC;AACA,iC;AACA,4D;AACA,iD;AACA,uD;AACA,6B;AACA,uD;AACA,gC;AACA,kC;AACA,qB;AACA,iB;AACA,qB;AACA,wD;AACA,+B;AACA,2C;AACA,oB;AACA,mE;AACA,6C;AACA,qC;AACA,yB;AACA,wC;AACA,8C;AACA,a;AACA,iD;AACA,oD;AACA,mD;AACA,sD;AACA,2C;AACA,qB;AACA,mE;AACA,iB;AACA,qB;AACA,qC;AACA,uC;AACA,iB;AACA,oC;AACA,0B;AACA,M;;AAEA,wC;AACA,yF;AACA,yC;AACA,mF;AACA,8D;AACA,8B;AACA,sD;AACA,yE;AACA,gH;AACA,iC;AACA,4B;AACA,mC;AACA,uC;AACA,oE;AACA,wC;AACA,uC;AACA,wB;AACA,mF;AACA,2C;AACA,qB;AACA,iB;AACA,qB;AACA,S;AACA,mC;AACA,0B;AACA,M;;;AAGA,wC;AACA,yF;AACA,8C;AACA,wF;AACA,sD;AACA,4B;AACA,qD;AACA,sD;AACA,uC;AACA,4C;AACA,uC;AACA,gH;AACA,+B;AACA,gD;AACA,gC;AACA,qC;AACA,qB;AACA,kC;AACA,yB;AACA,wF;AACA,uD;AACA,2C;AACA,iB;AACA,qB;AACA,S;AACA,0B;AACA,M;;AAEA,wC;AACA,yF;AACA,qC;AACA,+E;AACA,8D;AACA,iC;AACA,sE;AACA,oC;AACA,S;AACA,kD;AACA,oC;AACA,wJ;AACA,S;AACA,uF;AACA,M;;;AAGA,K;AACA,a","sourcesContent":["// Copyright: 2013 PMSI-AlignAlytics\n// License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n// Source: /src/objects/begin.js\n\n// Create the stub object\nvar dimple = {\n    version: \"1.1.5\",\n    plot: {},\n    aggregateMethod: {}\n};\n\nwindow.dimple = dimple;\n\n// Wrap all application code in a self-executing function\n(function () {\n    \"use strict\";\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/axis/begin.js\n    // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis\n    dimple.axis = function (chart, position, categoryFields, measure, timeField) {\n\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-chart\n        this.chart = chart;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-position\n        this.position = position;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-categoryFields\n        this.categoryFields = (timeField === null || timeField === undefined ? categoryFields : [].concat(timeField));\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-measure\n        this.measure = measure;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-timeField\n        this.timeField = timeField;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-floatingBarWidth\n        this.floatingBarWidth = 5;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-hidden\n        this.hidden = false;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-showPercent\n        this.showPercent = false;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-colors\n        this.colors = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-overrideMin\n        this.overrideMin = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-overrideMax\n        this.overrideMax = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-shapes\n        this.shapes = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-showGridlines\n        this.showGridlines = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-gridlineShapes\n        this.gridlineShapes = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-titleShape\n        this.titleShape = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-dateParseFormat\n        this.dateParseFormat = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-tickFormat\n        this.tickFormat = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-timePeriod\n        this.timePeriod = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-timeInterval\n        this.timeInterval = 1;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-useLog\n        this.useLog = false;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-logBase\n        this.logBase = 10;\n\n        // The scale determined by the update method\n        this._scale = null;\n        // The minimum and maximum axis values\n        this._min = 0;\n        this._max = 0;\n        // Chart origin before and after an update.  This helps\n        // with transitions\n        this._previousOrigin = null;\n        this._origin = null;\n        // The order definition array\n        this._orderRules = [];\n        // The group order definition array\n        this._groupOrderRules = [];\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/axis/methods/_draw.js\n        this._draw = null;\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/axis/methods/_getFormat.js\n        this._getFormat = function () {\n            var returnFormat,\n                max,\n                min,\n                len,\n                chunks,\n                suffix,\n                dp;\n            if (this.tickFormat !== null && this.tickFormat !== undefined) {\n                if (this._hasTimeField()) {\n                    returnFormat = d3.time.format(this.tickFormat);\n                } else {\n                    returnFormat = d3.format(this.tickFormat);\n                }\n            } else if (this.showPercent) {\n                returnFormat = d3.format(\"%\");\n            } else if (this.useLog && this.measure !== null) {\n                // With linear axes the range is used to apply uniform\n                // formatting but with a log axis it is based on each number\n                // independently\n                returnFormat = function (n) {\n                    var l = Math.floor(Math.abs(n), 0).toString().length,\n                        c = Math.min(Math.floor((l - 1) / 3), 4),\n                        s = \"kmBT\".substring(c - 1, c),\n                        d = (Math.round((n / Math.pow(1000, c)) * 10).toString().slice(-1) === \"0\" ? 0 : 1);\n                    return (n === 0 ? 0 : d3.format(\",.\" + d + \"f\")(n / Math.pow(1000, c)) + s);\n                };\n            } else if (this.measure !== null) {\n                max = Math.floor(Math.abs(this._max), 0).toString();\n                min = Math.floor(Math.abs(this._min), 0).toString();\n                len = Math.max(min.length, max.length);\n                if (len > 3) {\n                    chunks = Math.min(Math.floor((len - 1) / 3), 4);\n                    suffix = \"kmBT\".substring(chunks - 1, chunks);\n                    dp = (len - chunks * 3 <= 1 ? 1 : 0);\n                    returnFormat = function (n) {\n                        return (n === 0 ? 0 : d3.format(\",.\" + dp + \"f\")(n / Math.pow(1000, chunks)) + suffix);\n                    };\n                } else {\n                    dp = (len <= 1 ? 1 : 0);\n                    returnFormat = d3.format(\",.\" + dp + \"f\");\n                }\n            } else {\n                returnFormat = function (n) { return n; };\n            }\n            return returnFormat;\n        };\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/axis/methods/_getTimePeriod.js\n        this._getTimePeriod = function () {\n            // A javascript date object\n            var outPeriod = this.timePeriod,\n                maxPeriods = 30,\n                diff = this._max - this._min;\n            if (this._hasTimeField && (this.timePeriod === null || this.timePeriod === undefined)) {\n                // Calculate using millisecond values for speed.  Using the date range requires creating an array\n                // which in the case of seconds kills the browser.  All constants are straight sums of milliseconds\n                // except months taken as (86400000 * 365.25) / 12 = 2629800000\n                if (diff / 1000 <= maxPeriods) {\n                    outPeriod = d3.time.seconds;\n                } else if (diff / 60000 <= maxPeriods) {\n                    outPeriod = d3.time.minutes;\n                } else if (diff / 3600000 <= maxPeriods) {\n                    outPeriod = d3.time.hours;\n                } else if (diff / 86400000 <= maxPeriods) {\n                    outPeriod = d3.time.days;\n                } else if (diff / 604800000 <= maxPeriods) {\n                    outPeriod = d3.time.weeks;\n                } else if (diff / 2629800000 <= maxPeriods) {\n                    outPeriod = d3.time.months;\n                } else {\n                    outPeriod = d3.time.years;\n                }\n            }\n            // Return the date\n            return outPeriod;\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/axis/methods/_hasCategories.js\n        this._hasCategories = function () {\n            return (this.categoryFields !== null && this.categoryFields !== undefined && this.categoryFields.length > 0);\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/axis/methods/_hasMeasure.js\n        this._hasMeasure = function () {\n            return (this.measure !== null && this.measure !== undefined);\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/axis/methods/_hasTimeField.js\n        this._hasTimeField = function () {\n            return (this.timeField !== null && this.timeField !== undefined);\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/axis/methods/_parseDate.js\n        this._parseDate = function (inDate) {\n            // A javascript date object\n            var outDate;\n            if (this.dateParseFormat === null || this.dateParseFormat === undefined) {\n                // Moved this into the condition so that using epoch time requires no data format to be set.\n                // For example 20131122 might be parsed as %Y%m%d not treated as epoch time.\n                if (!isNaN(inDate)) {\n                    // If inDate is a number, assume it's epoch time\n                    outDate = new Date(inDate);\n                } else {\n                    // If nothing has been explicity defined you are in the hands of the browser gods\n                    // may they smile upon you...\n                    outDate = Date.parse(inDate);\n                }\n            } else {\n                outDate = d3.time.format(this.dateParseFormat).parse(inDate);\n            }\n            // Return the date\n            return outDate;\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/axis/methods/_update.js\n        this._update = function (refactor) {\n\n            var distinctCats = [],\n                ticks,\n                step,\n                remainder,\n                origin,\n                getOrderedCategories = function (self, axPos, oppPos) {\n                    var category = self.categoryFields[0],\n                        chartData = self.chart._getAllData(),\n                        sortBy = category,\n                        desc = false,\n                        isDate = true,\n                        currentValue = null,\n                        i,\n                        definitions = [];\n                    // Check whether this field is a date\n                    for (i = 0; i < chartData.length; i += 1) {\n                        currentValue = self._parseDate(chartData[i][category]);\n                        if (currentValue !== null && currentValue !== undefined && isNaN(currentValue)) {\n                            isDate = false;\n                            break;\n                        }\n                    }\n                    if (!isDate) {\n                        // Find the first series which connects this axis to another\n                        self.chart.series.forEach(function (s) {\n                            if (s[axPos] === self && s[oppPos]._hasMeasure()) {\n                                sortBy = s[oppPos].measure;\n                                desc = true;\n                            }\n                        }, this);\n                    }\n                    definitions = self._orderRules.concat({ ordering : sortBy, desc : desc });\n                    return dimple._getOrderedList(chartData, category, definitions);\n                };\n\n            // If the axis is a percentage type axis the bounds must be between -1 and 1.  Sometimes\n            // binary rounding means it can fall outside that bound so tidy up here\n            this._min = (this.showPercent && this._min < -1 ? -1 : this._min);\n            this._max = (this.showPercent && this._max > 1 ? 1 : this._max);\n\n            // Override or round the min or max\n            this._min = (this.overrideMin !== null ? this.overrideMin : this._min);\n            this._max = (this.overrideMax !== null ? this.overrideMax : this._max);\n\n            // If this is an x axis\n            if (this.position === \"x\") {\n                if (this._hasTimeField()) {\n                    this._scale = d3.time.scale()\n                        .rangeRound([this.chart._xPixels(), this.chart._xPixels() + this.chart._widthPixels()])\n                        .domain([this._min, this._max]);\n                } else if (this.useLog) {\n                    this._scale = d3.scale.log()\n                        .range([this.chart._xPixels(), this.chart._xPixels() + this.chart._widthPixels()])\n                        .domain([\n                            (this._min === 0 ? Math.pow(this.logBase, -1) : this._min),\n                            (this._max === 0 ? -1 * Math.pow(this.logBase, -1) : this._max)\n                        ])\n                        .clamp(true)\n                        .base(this.logBase)\n                        .nice();\n                } else if (this.measure === null || this.measure === undefined) {\n                    distinctCats = getOrderedCategories(this, \"x\", \"y\");\n                    this._scale = d3.scale.ordinal()\n                        .rangePoints([this.chart._xPixels(), this.chart._xPixels() + this.chart._widthPixels()])\n                        .domain(distinctCats.concat([\"\"]));\n                } else {\n                    this._scale = d3.scale.linear()\n                        .range([this.chart._xPixels(), this.chart._xPixels() + this.chart._widthPixels()])\n                        .domain([this._min, this._max]).nice();\n                }\n                // If it's visible, orient it at the top or bottom if it's first or second respectively\n                if (!this.hidden) {\n                    switch (this.chart._axisIndex(this, \"x\")) {\n                    case 0:\n                        this._draw = d3.svg.axis()\n                            .orient(\"bottom\")\n                            .scale(this._scale);\n                        break;\n                    case 1:\n                        this._draw = d3.svg.axis()\n                            .orient(\"top\")\n                            .scale(this._scale);\n                        break;\n                    default:\n                        break;\n                    }\n                }\n            } else if (this.position === \"y\") {\n                if (this._hasTimeField()) {\n                    this._scale = d3.time.scale()\n                        .rangeRound([this.chart._yPixels() + this.chart._heightPixels(), this.chart._yPixels()])\n                        .domain([this._min, this._max]);\n                } else if (this.useLog) {\n                    this._scale = d3.scale.log()\n                        .range([this.chart._yPixels() + this.chart._heightPixels(), this.chart._yPixels()])\n                        .domain([\n                            (this._min === 0 ? Math.pow(this.logBase, -1) : this._min),\n                            (this._max === 0 ? -1 * Math.pow(this.logBase, -1) : this._max)\n                        ])\n                        .clamp(true)\n                        .base(this.logBase)\n                        .nice();\n                } else if (this.measure === null || this.measure === undefined) {\n                    distinctCats = getOrderedCategories(this, \"y\", \"x\");\n                    this._scale = d3.scale.ordinal()\n                        .rangePoints([this.chart._yPixels() + this.chart._heightPixels(), this.chart._yPixels()])\n                        .domain(distinctCats.concat([\"\"]));\n                } else {\n                    this._scale = d3.scale.linear()\n                        .range([this.chart._yPixels() + this.chart._heightPixels(), this.chart._yPixels()])\n                        .domain([this._min, this._max])\n                        .nice();\n                }\n                // if it's visible, orient it at the left or right if it's first or second respectively\n                if (!this.hidden) {\n                    switch (this.chart._axisIndex(this, \"y\")) {\n                    case 0:\n                        this._draw = d3.svg.axis()\n                            .orient(\"left\")\n                            .scale(this._scale);\n                        break;\n                    case 1:\n                        this._draw = d3.svg.axis()\n                            .orient(\"right\")\n                            .scale(this._scale);\n                        break;\n                    default:\n                        break;\n                    }\n                }\n            } else if (this.position.length > 0 && this.position[0] === \"z\") {\n                if (this.useLog) {\n                    this._scale = d3.scale.log()\n                        .range([this.chart._heightPixels() / 300, this.chart._heightPixels() / 10])\n                        .domain([\n                            (this._min === 0 ? Math.pow(this.logBase, -1) : this._min),\n                            (this._max === 0 ? -1 * Math.pow(this.logBase, -1) : this._max)\n                        ])\n                        .clamp(true)\n                        .base(this.logBase);\n                } else {\n                    this._scale = d3.scale.linear()\n                        .range([this.chart._heightPixels() / 300, this.chart._heightPixels() / 10])\n                        .domain([this._min, this._max]);\n                }\n            } else if (this.position.length > 0 && this.position[0] === \"c\") {\n                this._scale = d3.scale.linear()\n                    .range([0, (this.colors === null || this.colors.length === 1 ? 1 : this.colors.length - 1)])\n                    .domain([this._min, this._max]);\n            }\n            // Check that the axis ends on a labelled tick\n            if ((refactor === null || refactor === undefined || refactor === false) && !this._hasTimeField() && this._scale !== null && this._scale.ticks !== null && this._scale.ticks !== undefined && this._scale.ticks(10).length > 0 && (this.position === \"x\" || this.position === \"y\")) {\n\n                // Get the ticks determined based on a split of 10\n                ticks = this._scale.ticks(10);\n                // Get the step between ticks\n                step = ticks[1] - ticks[0];\n                // Get the remainder\n                remainder = ((this._max - this._min) % step).toFixed(0);\n\n                // If the remainder is not zero\n                if (remainder !== 0) {\n                    // Set the bounds\n                    this._max = Math.ceil(this._max / step) * step;\n                    this._min = Math.floor(this._min / step) * step;\n                    // Recursively call the method to recalculate the scale.  This shouldn't enter this block again.\n                    this._update(true);\n                }\n            }\n\n            // Populate the origin.  Previously this incorrectly looked up 0 on the axis which only works\n            // for measure axes leading to Issue #19.  This fix uses the first category value in cases where\n            // one is required.\n            if (distinctCats !== null && distinctCats !== undefined && distinctCats.length > 0) {\n                origin = this._scale.copy()(distinctCats[0]);\n            } else {\n                origin = this._scale.copy()(0);\n            }\n\n            if (this._origin !== origin) {\n                this._previousOrigin = (this._origin === null ? origin : this._origin);\n                this._origin = origin;\n            }\n\n            // Return axis for chaining\n            return this;\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/axis/methods/addGroupOrderRule.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-addGroupOrderRule\n        this.addGroupOrderRule = function (ordering, desc) {\n            this._groupOrderRules.push({ ordering : ordering, desc : desc });\n        };\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/axis/methods/addOrderRule.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.axis#wiki-addOrderRule\n        this.addOrderRule = function (ordering, desc) {\n            this._orderRules.push({ ordering : ordering, desc : desc });\n        };\n    };\n    // End dimple.axis\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/chart/begin.js\n    // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart\n    dimple.chart = function (svg, data) {\n\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-svg\n        this.svg = svg;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-x\n        this.x = \"10%\";\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-y\n        this.y = \"10%\";\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-width\n        this.width = \"80%\";\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-height\n        this.height = \"80%\";\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-data\n        this.data = data;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-noFormats\n        this.noFormats = false;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-axes\n        this.axes = [];\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-series\n        this.series = [];\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-legends\n        this.legends = [];\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-storyboard\n        this.storyboard = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-titleShape\n        this.titleShape = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-shapes\n        this.shapes = null;\n\n        // The group within which to put all of this chart's objects\n        this._group = svg.append(\"g\");\n        // The group within which to put tooltips.  This is not initialised here because\n        // the group would end up behind other chart contents in a multi chart output.  It will\n        // therefore be added and removed by the mouse enter/leave events\n        this._tooltipGroup = null;\n        // Colors assigned to chart contents.  E.g. a series value.\n        this._assignedColors = {};\n        // The next colour index to use, this value is cycled around for all default colours\n        this._nextColor = 0;\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/_axisIndex.js\n        // Return the ordinal value of the passed axis.  If an orientation is passed, return the order for the \n        // specific orientation, otherwise return the order from all axes.  Returns -1 if the passed axis isn't part of the collection\n        this._axisIndex = function (axis, orientation) {\n\n            var i = 0,\n                axisCount = 0,\n                index = -1;\n\n            for (i = 0; i < this.axes.length; i += 1) {\n                if (this.axes[i] === axis) {\n                    index = axisCount;\n                    break;\n                }\n                if (orientation === null || orientation === undefined || orientation[0] === this.axes[i].position[0]) {\n                    axisCount += 1;\n                }\n            }\n\n            return index;\n\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/_getAllData.js\n        // Mash together all of the datasets\n        this._getAllData = function () {\n            // The return array will include all data for chart as well as an series\n            var returnData = [];\n            // If there is data at the chart level\n            if (this.data !== null && this.data !== undefined && this.data.length > 0) {\n                returnData = returnData.concat(this.data);\n            }\n            // If there are series defined\n            if (this.series !== null && this.series !== undefined && this.series.length > 0) {\n                this.series.forEach(function (s) {\n                    if (s.data !== null && s.data !== undefined && s.data.length > 0) {\n                        returnData = returnData.concat(s.data);\n                    }\n                });\n            }\n            // Return the final dataset\n            return returnData;\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/_getSeriesData.js\n        // Create a dataset containing positioning information for every series\n        this._getSeriesData = function () {\n            // If there are series\n            if (this.series !== null && this.series !== undefined) {\n                // Iterate all the series\n                this.series.forEach(function (series) {\n                    // The data for this series\n                    var returnData = [],\n                        // Handle multiple category values by iterating the fields in the row and concatonate the values\n                        // This is repeated for each axis using a small anon function\n                        getField = function (axis, row) {\n                            var returnField = [];\n                            if (axis !== null) {\n                                if (axis._hasTimeField()) {\n                                    returnField.push(axis._parseDate(row[axis.timeField]));\n                                } else if (axis._hasCategories()) {\n                                    axis.categoryFields.forEach(function (cat) {\n                                        returnField.push(row[cat]);\n                                    }, this);\n                                }\n                            }\n                            return returnField;\n                        },\n                        // Catch a non-numeric value and re-calc as count\n                        useCount = { x: false, y: false, z: false, c: false },\n                        // If the elements are grouped a unique list of secondary category values will be required\n                        secondaryElements = { x: [], y: [] },\n                        // Get the x and y totals for percentages.  This cannot be done in the loop above as we need the data aggregated before we get an abs total.\n                        // otherwise it will wrongly account for negatives and positives rolled together.\n                        totals = { x: [], y: [], z: [] },\n                        colorBounds = { min: null, max: null },\n                        tot,\n                        running = { x: [], y: [], z: [] },\n                        addedCats = [],\n                        catTotals = {},\n                        grandTotals = { x: 0, y: 0, z: 0 },\n                        key,\n                        storyCat = \"\",\n                        orderedStoryboardArray = [],\n                        seriesCat = \"\",\n                        orderedSeriesArray = [],\n                        xCat = \"\",\n                        xSortArray = [],\n                        yCat = \"\",\n                        ySortArray = [],\n                        rules = [],\n                        sortedData = series.data || this.data,\n                        groupRules = [];\n\n                    if (this.storyboard !== null && this.storyboard !== undefined && this.storyboard.categoryFields.length > 0) {\n                        storyCat = this.storyboard.categoryFields[0];\n                        orderedStoryboardArray = dimple._getOrderedList(sortedData, storyCat, this.storyboard._orderRules);\n                    }\n\n                    // Deal with mekkos\n                    if (series.x._hasCategories() && series.x._hasMeasure()) {\n                        xCat = series.x.categoryFields[0];\n                        xSortArray = dimple._getOrderedList(sortedData, xCat, series.x._orderRules.concat([{ ordering : series.x.measure, desc : true }]));\n                    }\n                    if (series.y._hasCategories() && series.y._hasMeasure()) {\n                        yCat = series.y.categoryFields[0];\n                        ySortArray = dimple._getOrderedList(sortedData, yCat, series.y._orderRules.concat([{ ordering : series.y.measure, desc : true }]));\n                    }\n\n                    if (series.categoryFields !== null && series.categoryFields !== undefined && series.categoryFields.length > 0) {\n                        // Concat is used here to break the reference to the parent array, if we don't do this, in a storyboarded chart,\n                        // the series rules to grow and grow until the system grinds to a halt trying to deal with them all.\n                        rules = [].concat(series._orderRules);\n                        seriesCat = series.categoryFields[0];\n                        if (series.c !== null && series.c !== undefined && series.c._hasMeasure()) {\n                            rules.push({ ordering : series.c.measure, desc : true });\n                        } else if (series.z !== null && series.z !== undefined && series.z._hasMeasure()) {\n                            rules.push({ ordering : series.z.measure, desc : true });\n                        } else if (series.x._hasMeasure()) {\n                            rules.push({ ordering : series.x.measure, desc : true });\n                        } else if (series.y._hasMeasure()) {\n                            rules.push({ ordering : series.y.measure, desc : true });\n                        }\n                        orderedSeriesArray = dimple._getOrderedList(sortedData, seriesCat, rules);\n                    }\n\n                    sortedData.sort(function (a, b) {\n                        var returnValue = 0;\n                        if (storyCat !== \"\") {\n                            returnValue = orderedStoryboardArray.indexOf(a[storyCat]) - orderedStoryboardArray.indexOf(b[storyCat]);\n                        }\n                        if (xCat !== \"\" && returnValue === 0) {\n                            returnValue = xSortArray.indexOf(a[xCat]) - xSortArray.indexOf(b[xCat]);\n                        }\n                        if (yCat !== \"\" && returnValue === 0) {\n                            returnValue = ySortArray.indexOf(a[yCat]) - ySortArray.indexOf(b[yCat]);\n                        }\n                        if (seriesCat !== \"\" && returnValue === 0) {\n                            returnValue = orderedSeriesArray.indexOf(a[seriesCat]) - orderedSeriesArray.indexOf(b[seriesCat]);\n                        }\n                        return returnValue;\n                    });\n\n                    // Iterate every row in the data to calculate the return values\n                    sortedData.forEach(function (d) {\n                        // Reset the index\n                        var foundIndex = -1,\n                            xField = getField(series.x, d),\n                            yField = getField(series.y, d),\n                            zField = getField(series.z, d),\n                            // Get the aggregate field using the other fields if necessary\n                            aggField = [],\n                            key,\n                            k,\n                            newRow,\n                            updateData;\n                        if (series.categoryFields === null || series.categoryFields === undefined || series.categoryFields.length === 0) {\n                            aggField = [\"All\"];\n                        } else if (series.categoryFields.length === 1 && d[series.categoryFields[0]] === undefined) {\n                            aggField = [series.categoryFields[0]];\n                        } else {\n                            series.categoryFields.forEach(function (cat) {\n                                aggField.push(d[cat]);\n                            }, this);\n                        }\n                        // Add a key\n                        key = aggField.join(\"/\") + \"_\" + xField.join(\"/\") + \"_\" + yField.join(\"/\") + \"_\" + zField.join(\"/\");\n                        // See if this field has already been added. \n                        for (k = 0; k < returnData.length; k += 1) {\n                            if (returnData[k].key === key) {\n                                foundIndex = k;\n                                break;\n                            }\n                        }\n                        // If the field was not added, do so here\n                        if (foundIndex === -1) {\n                            newRow = {\n                                key: key,\n                                aggField: aggField,\n                                xField: xField,\n                                xValue: null,\n                                xCount: 0,\n                                yField: yField,\n                                yValue: null,\n                                yCount: 0,\n                                zField: zField,\n                                zValue: null,\n                                zCount: 0,\n                                cValue: 0,\n                                cCount: 0,\n                                x: 0,\n                                y: 0,\n                                xOffset: 0,\n                                yOffset: 0,\n                                width: 0,\n                                height: 0,\n                                cx: 0,\n                                cy: 0,\n                                xBound: 0,\n                                yBound: 0,\n                                xValueList: [],\n                                yValueList: [],\n                                zValueList: [],\n                                cValueList: [],\n                                fill: {},\n                                stroke: {}\n                            };\n                            returnData.push(newRow);\n                            foundIndex = returnData.length - 1;\n                        }\n\n                        // Update the return data for the passed axis\n                        updateData = function (axis, storyboard) {\n                            var passStoryCheck = true,\n                                lhs = { value: 0, count: 1 },\n                                rhs = { value: 0, count: 1 },\n                                selectStoryValue,\n                                compare = \"\",\n                                retRow;\n                            if (storyboard !== null) {\n                                selectStoryValue = storyboard.getFrameValue();\n                                storyboard.categoryFields.forEach(function (cat, m) {\n                                    if (m > 0) {\n                                        compare += \"/\";\n                                    }\n                                    compare += d[cat];\n                                    passStoryCheck = (compare === selectStoryValue);\n                                }, this);\n                            }\n                            if (axis !== null && axis !== undefined) {\n                                if (passStoryCheck) {\n                                    retRow = returnData[foundIndex];\n                                    if (axis._hasMeasure()) {\n                                        // Treat undefined values as zero\n                                        if (d[axis.measure] === undefined) {\n                                            d[axis.measure] = 0;\n                                        }\n                                        // Keep a distinct list of values to calculate a distinct count in the case of a non-numeric value being found\n                                        if (retRow[axis.position + \"ValueList\"].indexOf(d[axis.measure]) === -1) {\n                                            retRow[axis.position + \"ValueList\"].push(d[axis.measure]);\n                                        }\n                                        // The code above is outside this check for non-numeric values because we might encounter one far down the list, and\n                                        // want to have a record of all values so far.\n                                        if (isNaN(parseFloat(d[axis.measure]))) {\n                                            useCount[axis.position] = true;\n                                        }\n                                        // Set the value using the aggregate function method\n                                        lhs.value = retRow[axis.position + \"Value\"];\n                                        lhs.count = retRow[axis.position + \"Count\"];\n                                        rhs.value = d[axis.measure];\n                                        retRow[axis.position + \"Value\"] = series.aggregate(lhs, rhs);\n                                        retRow[axis.position + \"Count\"] += 1;\n                                    }\n                                }\n                            }\n                        };\n                        // Update all the axes\n                        updateData(series.x, this.storyboard);\n                        updateData(series.y, this.storyboard);\n                        updateData(series.z, this.storyboard);\n                        updateData(series.c, this.storyboard);\n                    }, this);\n                    // Get secondary elements if necessary\n                    if (series.x !== null && series.x !== undefined && series.x._hasCategories() && series.x.categoryFields.length > 1 && secondaryElements.x !== undefined) {\n                        groupRules = [];\n                        if (series.y._hasMeasure()) {\n                            groupRules.push({ ordering : series.y.measure, desc : true });\n                        }\n                        secondaryElements.x = dimple._getOrderedList(sortedData, series.x.categoryFields[1], series.x._groupOrderRules.concat(groupRules));\n                    }\n                    if (series.y !== null && series.y !== undefined && series.y._hasCategories() && series.y.categoryFields.length > 1 && secondaryElements.y !== undefined) {\n                        groupRules = [];\n                        if (series.x._hasMeasure()) {\n                            groupRules.push({ ordering : series.x.measure, desc : true });\n                        }\n                        secondaryElements.y = dimple._getOrderedList(sortedData, series.y.categoryFields[1], series.y._groupOrderRules.concat(groupRules));\n                        secondaryElements.y.reverse();\n                    }\n                    returnData.forEach(function (ret) {\n                        if (series.x !== null) {\n                            if (useCount.x === true) { ret.xValue = ret.xValueList.length; }\n                            tot = (totals.x[ret.xField.join(\"/\")] === null || totals.x[ret.xField.join(\"/\")] === undefined ? 0 : totals.x[ret.xField.join(\"/\")]) + (series.y._hasMeasure() ? Math.abs(ret.yValue) : 0);\n                            totals.x[ret.xField.join(\"/\")] = tot;\n                        }\n                        if (series.y !== null) {\n                            if (useCount.y === true) { ret.yValue = ret.yValueList.length; }\n                            tot = (totals.y[ret.yField.join(\"/\")] === null || totals.y[ret.yField.join(\"/\")] === undefined ? 0 : totals.y[ret.yField.join(\"/\")]) + (series.x._hasMeasure() ? Math.abs(ret.xValue) : 0);\n                            totals.y[ret.yField.join(\"/\")] = tot;\n                        }\n                        if (series.z !== null) {\n                            if (useCount.z === true) { ret.zValue = ret.zValueList.length; }\n                            tot = (totals.z[ret.zField.join(\"/\")] === null || totals.z[ret.zField.join(\"/\")] === undefined ? 0 : totals.z[ret.zField.join(\"/\")]) + (series.z._hasMeasure() ? Math.abs(ret.zValue) : 0);\n                            totals.z[ret.zField.join(\"/\")] = tot;\n                        }\n                        if (series.c !== null) {\n                            if (colorBounds.min === null || ret.cValue < colorBounds.min) { colorBounds.min = ret.cValue; }\n                            if (colorBounds.max === null || ret.cValue > colorBounds.max) { colorBounds.max = ret.cValue; }\n                        }\n                    }, this);\n                    // Before calculating the positions we need to sort elements\n\n                    // Set all the dimension properties of the data\n                    for (key in totals.x) { if (totals.x.hasOwnProperty(key)) { grandTotals.x += totals.x[key]; } }\n                    for (key in totals.y) { if (totals.y.hasOwnProperty(key)) { grandTotals.y += totals.y[key]; } }\n                    for (key in totals.z) { if (totals.z.hasOwnProperty(key)) { grandTotals.z += totals.z[key]; } }\n\n                    returnData.forEach(function (ret) {\n                        var baseColor,\n                            targetColor,\n                            scale,\n                            colorVal,\n                            floatingPortion,\n                            getAxisData = function (axis, opp, size) {\n                                var totalField,\n                                    value,\n                                    selectValue,\n                                    pos,\n                                    cumValue;\n                                if (axis !== null && axis !== undefined) {\n                                    pos = axis.position;\n                                    if (!axis._hasCategories()) {\n                                        value = (axis.showPercent ? ret[pos + \"Value\"] / totals[opp][ret[opp + \"Field\"].join(\"/\")] : ret[pos + \"Value\"]);\n                                        totalField = ret[opp + \"Field\"].join(\"/\") + (ret[pos + \"Value\"] >= 0);\n                                        cumValue = running[pos][totalField] = ((running[pos][totalField] === null || running[pos][totalField] === undefined || pos === \"z\") ? 0 : running[pos][totalField]) + value;\n                                        selectValue = ret[pos + \"Bound\"] = ret[\"c\" + pos] = (((pos === \"x\" || pos === \"y\") && series.stacked) ? cumValue : value);\n                                        ret[size] = value;\n                                        ret[pos] = selectValue - (((pos === \"x\" && value >= 0) || (pos === \"y\" && value <= 0)) ? value : 0);\n                                    } else {\n                                        if (axis._hasMeasure()) {\n                                            totalField = ret[axis.position + \"Field\"].join(\"/\");\n                                            value = (axis.showPercent ? totals[axis.position][totalField] / grandTotals[axis.position] : totals[axis.position][totalField]);\n                                            if (addedCats.indexOf(totalField) === -1) {\n                                                catTotals[totalField] = value + (addedCats.length > 0 ? catTotals[addedCats[addedCats.length - 1]] : 0);\n                                                addedCats.push(totalField);\n                                            }\n                                            selectValue = ret[pos + \"Bound\"] = ret[\"c\" + pos] = (((pos === \"x\" || pos === \"y\") && series.stacked) ? catTotals[totalField] : value);\n                                            ret[size] = value;\n                                            ret[pos] = selectValue - (((pos === \"x\" && value >= 0) || (pos === \"y\" && value <= 0)) ? value : 0);\n                                        } else {\n                                            ret[pos] = ret[\"c\" + pos] = ret[pos + \"Field\"][0];\n                                            ret[size] = 1;\n                                            if (secondaryElements[pos] !== undefined && secondaryElements[pos] !== null && secondaryElements[pos].length >= 2) {\n                                                ret[pos + \"Offset\"] = secondaryElements[pos].indexOf(ret[pos + \"Field\"][1]);\n                                                ret[size] = 1 / secondaryElements[pos].length;\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        getAxisData(series.x, \"y\", \"width\");\n                        getAxisData(series.y, \"x\", \"height\");\n                        getAxisData(series.z, \"z\", \"r\");\n\n                        // If there is a color axis\n                        if (series.c !== null && colorBounds.min !== null && colorBounds.max !== null) {\n                            // Handle matching min and max\n                            if (colorBounds.min === colorBounds.max) {\n                                colorBounds.min -= 0.5;\n                                colorBounds.max += 0.5;\n                            }\n                            // Limit the bounds of the color value to be within the range.  Users may override the axis bounds and this\n                            // allows a 2 color scale rather than blending if the min and max are set to 0 and 0.01 for example negative values\n                            // and zero value would be 1 color and positive another.\n                            colorBounds.min = (series.c.overrideMin !== null && series.c.overrideMin !== undefined ? series.c.overrideMin : colorBounds.min);\n                            colorBounds.max = (series.c.overrideMax !== null && series.c.overrideMax !== undefined ? series.c.overrideMax : colorBounds.max);\n                            ret.cValue = (ret.cValue > colorBounds.max ? colorBounds.max : (ret.cValue < colorBounds.min ? colorBounds.min : ret.cValue));\n                            // Calculate the factors for the calculations\n                            scale = d3.scale.linear().range([0, (series.c.colors === null || series.c.colors.length === 1 ? 1 : series.c.colors.length - 1)]).domain([colorBounds.min, colorBounds.max]);\n                            colorVal = scale(ret.cValue);\n                            floatingPortion = colorVal - Math.floor(colorVal);\n                            if (ret.cValue === colorBounds.max) {\n                                floatingPortion = 1;\n                            }\n                            // If there is a single color defined\n                            if (series.c.colors !== null && series.c.colors !== undefined && series.c.colors.length === 1) {\n                                baseColor = d3.rgb(series.c.colors[0]);\n                                targetColor = d3.rgb(this.getColor(ret.aggField.slice(-1)[0]).fill);\n                            } else if (series.c.colors !== null && series.c.colors !== undefined && series.c.colors.length > 1) {\n                                baseColor = d3.rgb(series.c.colors[Math.floor(colorVal)]);\n                                targetColor = d3.rgb(series.c.colors[Math.ceil(colorVal)]);\n                            } else {\n                                baseColor = d3.rgb(\"white\");\n                                targetColor = d3.rgb(this.getColor(ret.aggField.slice(-1)[0]).fill);\n                            }\n                            // Calculate the correct grade of color\n                            baseColor.r = Math.floor(baseColor.r + (targetColor.r - baseColor.r) * floatingPortion);\n                            baseColor.g = Math.floor(baseColor.g + (targetColor.g - baseColor.g) * floatingPortion);\n                            baseColor.b = Math.floor(baseColor.b + (targetColor.b - baseColor.b) * floatingPortion);\n                            // Set the colors on the row\n                            ret.fill = baseColor.toString();\n                            ret.stroke = baseColor.darker(0.5).toString();\n                        }\n\n                    }, this);\n\n                    // populate the data in the series\n                    series._positionData = returnData;\n\n                }, this);\n            }\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/_heightPixels.js\n        // Access the pixel value of the height of the plot area\n        this._heightPixels = function () {\n            return dimple._parseYPosition(this.height, this.svg.node());\n        };\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/_registerEventHandlers.js\n        // Register events, handle standard d3 shape events\n        this._registerEventHandlers = function (series) {\n            if (series._eventHandlers !== null && series._eventHandlers.length > 0) {\n                series._eventHandlers.forEach(function (thisHandler) {\n                    var shapes = null;\n                    if (thisHandler.handler !== null && typeof (thisHandler.handler) === \"function\") {\n                        // Some classes work from markers rather than the shapes (line and area for example)\n                        // in these cases the events should be applied to the markers instead.  Issue #15\n                        if (series._markers !== null && series._markers !== undefined) {\n                            shapes = series._markers;\n                        } else {\n                            shapes = series.shapes;\n                        }\n                        shapes.on(thisHandler.event, function (d) {\n                            var e = new dimple.eventArgs();\n                            if (series.chart.storyboard !== null) {\n                                e.frameValue = series.chart.storyboard.getFrameValue();\n                            }\n                            e.seriesValue = d.aggField;\n                            e.xValue = d.x;\n                            e.yValue = d.y;\n                            e.zValue = d.z;\n                            e.colorValue = d.cValue;\n                            e.seriesShapes = series.shapes;\n                            e.selectedShape = d3.select(this);\n                            thisHandler.handler(e);\n                        });\n                    }\n                }, this);\n            }\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/_widthPixels.js\n        // Access the pixel value of the width of the plot area\n        this._widthPixels = function () {\n            return dimple._parseXPosition(this.width, this.svg.node());\n        };\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/_xPixels.js\n        // Access the pixel position of the x co-ordinate of the plot area\n        this._xPixels = function () {\n            return dimple._parseXPosition(this.x, this.svg.node());\n        };\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/_yPixels.js\n        // Access the pixel position of the y co-ordinate of the plot area\n        this._yPixels = function () {\n            return dimple._parseYPosition(this.y, this.svg.node());\n        };\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/addAxis.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-addAxis\n        this.addAxis = function (position, categoryFields, measure, timeField) {\n            // Convert the passed category fields to an array in case a single string is sent\n            if (categoryFields !== null && categoryFields !== undefined) {\n                categoryFields = [].concat(categoryFields);\n            }\n            // Create the axis object based on the passed parameters\n            var axis = new dimple.axis(\n                this,\n                position,\n                categoryFields,\n                measure,\n                timeField\n            );\n            // Add the axis to the array for the chart\n            this.axes.push(axis);\n            // return the axis\n            return axis;\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/addCategoryAxis.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-addCategoryAxis\n        this.addCategoryAxis = function (position, categoryFields) {\n            return this.addAxis(position, categoryFields, null);\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/addColorAxis.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-addColorAxis\n        this.addColorAxis = function (measure, colors) {\n            var colorAxis = this.addAxis(\"c\", null, measure);\n            colorAxis.colors = (colors === null || colors === undefined ? null : [].concat(colors));\n            return colorAxis;\n        };\n\n\n        // Source: /src/objects/chart/methods/addLegend.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-addLegend\n        this.addLegend = function (x, y, width, height, horizontalAlign, series) {\n            // Use all series by default\n            series = (series === null || series === undefined ? this.series : [].concat(series));\n            horizontalAlign = (horizontalAlign === null || horizontalAlign === undefined ? \"left\" : horizontalAlign);\n            // Create the legend\n            var legend = new dimple.legend(this, x, y, width, height, horizontalAlign, series);\n            // Add the legend to the array\n            this.legends.push(legend);\n            // Return the legend object\n            return legend;\n        };\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/addLogAxis.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-addLogAxis\n        this.addLogAxis = function (position, logField, logBase) {\n            var axis = this.addAxis(position, null, logField, null);\n            if (logBase !== null && logBase !== undefined) {\n                axis.logBase = logBase;\n            }\n            axis.useLog = true;\n            return axis;\n        };\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/addMeasureAxis.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-addMeasureAxis\n        this.addMeasureAxis = function (position, measure) {\n            return this.addAxis(position, null, measure);\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/addPctAxis.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-addPctAxis\n        this.addPctAxis = function (position, measure, categories) {\n            var pctAxis = null;\n            if (categories !== null && categories !== undefined) {\n                pctAxis = this.addAxis(position, categories, measure);\n            } else {\n                pctAxis = this.addMeasureAxis(position, measure);\n            }\n            pctAxis.showPercent = true;\n            return pctAxis;\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/addSeries.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-addSeries\n        this.addSeries = function (categoryFields, plotFunction, axes) {\n            // Deal with no axes passed\n            if (axes === null || axes === undefined) { axes = this.axes; }\n            // Deal with no plot function\n            if (plotFunction === null || plotFunction === undefined) { plotFunction = dimple.plot.bubble; }\n            // Axis objects to be picked from the array\n            var xAxis = null,\n                yAxis = null,\n                zAxis = null,\n                colorAxis = null,\n                series;\n            // Iterate the array and pull out the relevant axes\n            axes.forEach(function (axis) {\n                if (axis !== null && plotFunction.supportedAxes.indexOf(axis.position) > -1) {\n                    if (xAxis === null && axis.position[0] === \"x\") {\n                        xAxis = axis;\n                    } else if (yAxis === null && axis.position[0] === \"y\") {\n                        yAxis = axis;\n                    } else if (zAxis === null && axis.position[0] === \"z\") {\n                        zAxis = axis;\n                    } else if (colorAxis === null && axis.position[0] === \"c\") {\n                        colorAxis = axis;\n                    }\n                }\n            }, this);\n            // Put single values into single value arrays\n            if (categoryFields !== null && categoryFields !== undefined) {\n                categoryFields = [].concat(categoryFields);\n            }\n            // Create a series object\n            series = new dimple.series(\n                this,\n                categoryFields,\n                xAxis,\n                yAxis,\n                zAxis,\n                colorAxis,\n                plotFunction,\n                dimple.aggregateMethod.sum,\n                plotFunction.stacked\n            );\n            // Add the series to the chart's array\n            this.series.push(series);\n            // Return the series\n            return series;\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/addTimeAxis.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-addTimeAxis\n        this.addTimeAxis = function (position, timeField, inputFormat, outputFormat) {\n            var axis = this.addAxis(position, null, null, timeField);\n            axis.tickFormat = outputFormat;\n            axis.dateParseFormat = inputFormat;\n            return axis;\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/assignColor.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-assignColor\n        this.assignColor = function (tag, fill, stroke, opacity) {\n            this._assignedColors[tag] = new dimple.color(fill, stroke, opacity);\n            return this._assignedColors[tag];\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/defaultColors.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-defaultColors\n        this.defaultColors = [\n            new dimple.color(\"#80B1D3\"), // Blue\n            new dimple.color(\"#FB8072\"), // Red\n            new dimple.color(\"#FDB462\"), // Orange\n            new dimple.color(\"#B3DE69\"), // Green\n            new dimple.color(\"#FFED6F\"), // Yellow\n            new dimple.color(\"#BC80BD\"), // Purple\n            new dimple.color(\"#8DD3C7\"), // Turquoise\n            new dimple.color(\"#CCEBC5\"), // Pale Blue\n            new dimple.color(\"#FFFFB3\"), // Pale Yellow\n            new dimple.color(\"#BEBADA\"), // Lavender\n            new dimple.color(\"#FCCDE5\"), // Pink\n            new dimple.color(\"#D9D9D9\")  // Grey\n        ];\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/draw.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-draw\n        this.draw = function (duration, noDataChange) {\n            // Deal with optional parameter\n            duration = (duration === null || duration === undefined ? 0 : duration);\n            // Catch the first x and y\n            var firstX = null,\n                firstY = null,\n                distinctCats,\n                xGridSet = false,\n                yGridSet = false,\n                chartX = this._xPixels(),\n                chartY = this._yPixels(),\n                chartWidth = this._widthPixels(),\n                chartHeight = this._heightPixels();\n\n            // Many of the draw methods use positioning data in each series.  Therefore we should\n            // decorate the series with it now\n            if (noDataChange === undefined || noDataChange === null || noDataChange === false) {\n                this._getSeriesData();\n            }\n\n            // Iterate the axes and calculate bounds, this is done within the chart because an\n            // axis' bounds are determined by other axes and the way that series tie them together\n            this.axes.forEach(function (axis) {\n                axis._min = 0;\n                axis._max = 0;\n                // Check that the axis has a measure\n                if (axis._hasMeasure()) {\n                    // Is this axis linked to a series\n                    var linked = false;\n                    // Find any linked series\n                    this.series.forEach(function (series) {\n                        // if this axis is linked\n                        if (series[axis.position] === axis) {\n                            // Get the bounds\n                            var bounds = series._axisBounds(axis.position);\n                            if (axis._min > bounds.min) { axis._min = bounds.min; }\n                            if (axis._max < bounds.max) { axis._max = bounds.max; }\n                            linked = true;\n                        }\n                    }, this);\n                    // If the axis is not linked, use the data bounds, this is unlikely to be used\n                    // in a real context, but when developing it is nice to see axes before any series have\n                    // been added.\n                    if (!linked) {\n                        this._getAllData().forEach(function (d) {\n                            if (axis._min > d[axis.measure]) { axis._min = d[axis.measure]; }\n                            if (axis._max < d[axis.measure]) { axis._max = d[axis.measure]; }\n                        }, this);\n                    }\n                } else if (axis._hasTimeField()) {\n                    // Parse the dates and assign the min and max\n                    axis._min = null;\n                    axis._max = null;\n                    this._getAllData().forEach(function (d) {\n                        var dt = axis._parseDate(d[axis.timeField]);\n                        if (axis._min === null || dt < axis._min) {\n                            axis._min = dt;\n                        }\n                        if (axis._max === null || dt > axis._max) {\n                            axis._max = dt;\n                        }\n                    }, this);\n                } else if (axis._hasCategories()) {\n                    // A category axis is just set to show the number of categories\n                    axis._min = 0;\n                    distinctCats = [];\n                    this._getAllData().forEach(function (d) {\n                        if (distinctCats.indexOf(d[axis.categoryFields[0]]) === -1) {\n                            distinctCats.push(d[axis.categoryFields[0]]);\n                        }\n                    }, this);\n                    axis._max = distinctCats.length;\n                }\n\n\n                // Update the axis now we have all information set\n                axis._update();\n\n                // Record the index of the first x and first y axes\n                if (firstX === null && axis.position === \"x\") {\n                    firstX = axis;\n                } else if (firstY === null && axis.position === \"y\") {\n                    firstY = axis;\n                }\n            }, this);\n            // Iterate the axes again\n            this.axes.forEach(function (axis) {\n                // Don't animate axes on first draw\n                var firstDraw = false,\n                    transform = null,\n                    gridSize = 0,\n                    gridTransform = null,\n                    handleTrans,\n                    rotated = false,\n                    widest = 0,\n                    box = { l: null, t: null, r: null, b: null },\n                    titleX = 0,\n                    titleY = 0,\n                    rotate = \"\",\n                    chart = this;\n                if (axis.gridlineShapes === null) {\n                    if (axis.showGridlines || (axis.showGridlines === null && !axis._hasCategories() && ((!xGridSet && axis.position === \"x\") || (!yGridSet && axis.position === \"y\")))) {\n                        // Add a group for the gridlines to allow css formatting\n                        axis.gridlineShapes = this._group.append(\"g\").attr(\"class\", \"gridlines\");\n                        if (axis.position === \"x\") {\n                            xGridSet = true;\n                        } else {\n                            yGridSet = true;\n                        }\n                    }\n                } else {\n                    if (axis.position === \"x\") {\n                        xGridSet = true;\n                    } else {\n                        yGridSet = true;\n                    }\n                }\n                if (axis.shapes === null) {\n                    // Add a group for the axes to allow css formatting\n                    axis.shapes = this._group.append(\"g\").attr(\"class\", \"axis\");\n                    firstDraw = true;\n                }\n                // If this is the first x and there is a y axis cross them at zero\n                if (axis === firstX && firstY !== null) {\n                    transform = \"translate(0, \" + (firstY.categoryFields === null || firstY.categoryFields.length === 0 ? firstY._scale(0) : chartY + chartHeight) + \")\";\n                    gridTransform = \"translate(0, \" + (axis === firstX ? chartY + chartHeight : chartY) + \")\";\n                    gridSize = -chartHeight;\n                } else if (axis === firstY && firstX !== null) {\n                    transform = \"translate(\" + (firstX.categoryFields === null || firstX.categoryFields.length === 0 ? firstX._scale(0) : chartX) + \", 0)\";\n                    gridTransform = \"translate(\" + (axis === firstY ? chartX : chartX + chartWidth) + \", 0)\";\n                    gridSize = -chartWidth;\n                } else if (axis.position === \"x\") {\n                    gridTransform = transform = \"translate(0, \" + (axis === firstX ? chartY + chartHeight : chartY) + \")\";\n                    gridSize = -chartHeight;\n                } else if (axis.position === \"y\") {\n                    gridTransform = transform = \"translate(\" + (axis === firstY ? chartX : chartX + chartWidth) + \", 0)\";\n                    gridSize = -chartWidth;\n                }\n                // Draw the axis\n                // This code might seem unneccesary but even applying a duration of 0 to a transition will cause the code to execute after the \n                // code below and precedence is important here.\n                handleTrans = function (ob) {\n                    var returnObj;\n                    if (transform === null || duration === 0 || firstDraw) {\n                        returnObj = ob;\n                    } else {\n                        returnObj = ob.transition().duration(duration);\n                    }\n                    return returnObj;\n                };\n                if (transform !== null && axis._draw !== null) {\n\n                    // Add a tick format\n                    if (axis._hasTimeField()) {\n                        handleTrans(axis.shapes).call(axis._draw.ticks(axis._getTimePeriod(), axis.timeInterval).tickFormat(axis._getFormat())).attr(\"transform\", transform);\n                    } else if (axis.useLog) {\n                        handleTrans(axis.shapes).call(axis._draw.ticks(4, axis._getFormat())).attr(\"transform\", transform);\n                    } else {\n                        handleTrans(axis.shapes).call(axis._draw.tickFormat(axis._getFormat())).attr(\"transform\", transform);\n                    }\n                    if (axis.gridlineShapes !== null) {\n                        handleTrans(axis.gridlineShapes).call(axis._draw.tickSize(gridSize, 0, 0).tickFormat(\"\")).attr(\"transform\", gridTransform);\n                    }\n                    // Move labels around\n                    if (axis.measure === null || axis.measure === undefined) {\n                        if (axis.position === \"x\") {\n                            handleTrans(axis.shapes.selectAll(\"text\")).attr(\"x\", (chartWidth / axis._max) / 2);\n                        } else if (axis.position === \"y\") {\n                            handleTrans(axis.shapes.selectAll(\"text\")).attr(\"y\", -1 * (chartHeight / axis._max) / 2);\n                        }\n                    }\n                    if (axis.categoryFields !== null && axis.categoryFields !== undefined && axis.categoryFields.length > 0) {\n                        // Off set the labels to counter the transform.  This will put the labels along the outside of the chart so they\n                        // don't interfere with the chart contents\n                        if (axis === firstX && (firstY.categoryFields === null || firstY.categoryFields.length === 0)) {\n                            handleTrans(axis.shapes.selectAll(\"text\")).attr(\"y\", chartY + chartHeight - firstY._scale(0) + 9);\n                        }\n                        if (axis === firstY && (firstX.categoryFields === null || firstX.categoryFields.length === 0)) {\n                            handleTrans(axis.shapes.selectAll(\"text\")).attr(\"x\", -1 * (firstX._scale(0) - chartX) - 9);\n                        }\n                    }\n                }\n                // Set some initial css values\n                if (!this.noFormats) {\n                    handleTrans(axis.shapes.selectAll(\"text\"))\n                        .style(\"font-family\", \"sans-serif\")\n                        .style(\"font-size\", (chartHeight / 35 > 10 ? chartHeight / 35 : 10) + \"px\");\n                    handleTrans(axis.shapes.selectAll(\"path, line\"))\n                        .style(\"fill\", \"none\")\n                        .style(\"stroke\", \"black\")\n                        .style(\"shape-rendering\", \"crispEdges\");\n                    if (axis.gridlineShapes !== null) {\n                        handleTrans(axis.gridlineShapes.selectAll(\"line\"))\n                            .style(\"fill\", \"none\")\n                            .style(\"stroke\", \"lightgray\")\n                            .style(\"opacity\", 0.8);\n                    }\n                }\n                // Rotate labels, this can only be done once the formats are set\n                if (axis.measure === null || axis.measure === undefined) {\n                    if (axis === firstX) {\n                        // If the gaps are narrower than the widest label display all labels horizontally\n                        widest = 0;\n                        axis.shapes.selectAll(\"text\").each(function () {\n                            var w = this.getComputedTextLength();\n                            widest = (w > widest ? w : widest);\n                        });\n                        if (widest > chartWidth / axis.shapes.selectAll(\"text\")[0].length) {\n                            rotated = true;\n                            axis.shapes.selectAll(\"text\")\n                                .style(\"text-anchor\", \"start\")\n                                .each(function () {\n                                    var rec = this.getBBox();\n                                    d3.select(this)\n                                        .attr(\"transform\", \"rotate(90,\" + rec.x + \",\" + (rec.y + (rec.height / 2)) + \") translate(-5, 0)\");\n                                });\n                        } else {\n                            // For redraw operations we need to clear the transform\n                            rotated = false;\n                            axis.shapes.selectAll(\"text\")\n                                .style(\"text-anchor\", \"middle\")\n                                .attr(\"transform\", \"\");\n                        }\n                    } else if (axis.position === \"x\") {\n                        // If the gaps are narrower than the widest label display all labels horizontally\n                        widest = 0;\n                        axis.shapes.selectAll(\"text\")\n                            .each(function () {\n                                var w = this.getComputedTextLength();\n                                widest = (w > widest ? w : widest);\n                            });\n                        if (widest > chartWidth / axis.shapes.selectAll(\"text\")[0].length) {\n                            rotated = true;\n                            axis.shapes.selectAll(\"text\")\n                                .style(\"text-anchor\", \"end\")\n                                .each(function () {\n                                    var rec = this.getBBox();\n                                    d3.select(this)\n                                        .attr(\"transform\", \"rotate(90,\" + (rec.x + rec.width) + \",\" + (rec.y + (rec.height / 2)) + \") translate(5, 0)\");\n                                });\n                        } else {\n                            // For redraw operations we need to clear the transform\n                            rotated = false;\n                            axis.shapes.selectAll(\"text\")\n                                .style(\"text-anchor\", \"middle\")\n                                .attr(\"transform\", \"\");\n                        }\n                    }\n                }\n                if (axis.titleShape !== null && axis.titleShape !== undefined) {\n                    axis.titleShape.remove();\n                }\n                // Get the bounds of the axis objects\n                axis.shapes.selectAll(\"text\")\n                    .each(function () {\n                        var rec = this.getBBox();\n                        if (box.l === null ||  -9 - rec.width < box.l) {\n                            box.l = -9 - rec.width;\n                        }\n                        if (box.r === null || rec.x + rec.width > box.r) {\n                            box.r = rec.x + rec.width;\n                        }\n                        if (rotated) {\n                            if (box.t === null || rec.y + rec.height - rec.width < box.t) {\n                                box.t = rec.y + rec.height - rec.width;\n                            }\n                            if (box.b === null || rec.height + rec.width > box.b) {\n                                box.b = rec.height + rec.width;\n                            }\n                        } else {\n                            if (box.t === null || rec.y < box.t) {\n                                box.t = rec.y;\n                            }\n                            if (box.b === null || 9 + rec.height > box.b) {\n                                box.b = 9 + rec.height;\n                            }\n                        }\n                    });\n\n                if (axis.position === \"x\") {\n                    if (axis === firstX) {\n                        titleY = chartY + chartHeight + box.b + 5;\n                    } else {\n                        titleY = chartY + box.t - 10;\n                    }\n                    titleX = chartX + (chartWidth / 2);\n                } else if (axis.position === \"y\") {\n                    if (axis === firstY) {\n                        titleX = chartX + box.l - 10;\n                    } else {\n                        titleX = chartX + chartWidth + box.r + 20;\n                    }\n                    titleY = chartY + (chartHeight / 2);\n                    rotate = \"rotate(270, \" + titleX + \", \" + titleY + \")\";\n                }\n\n                // Add a title for the axis\n                if (!axis.hidden && (axis.position === \"x\" || axis.position === \"y\")) {\n                    axis.titleShape = this._group.append(\"text\").attr(\"class\", \"axis title\");\n                    axis.titleShape\n                        .attr(\"x\", titleX)\n                        .attr(\"y\", titleY)\n                        .attr(\"text-anchor\", \"middle\")\n                        .attr(\"transform\", rotate)\n                        .text((axis.categoryFields === null || axis.categoryFields === undefined || axis.categoryFields.length === 0 ? axis.measure : axis.categoryFields.join(\"/\")))\n                        .each(function () {\n                            if (!chart.noFormats) {\n                                d3.select(this)\n                                    .style(\"font-family\", \"sans-serif\")\n                                    .style(\"font-size\", (chartHeight / 35 > 10 ? chartHeight / 35 : 10) + \"px\");\n                            }\n                        });\n\n                    // Offset Y position to baseline. This previously used dominant-baseline but this caused\n                    // browser inconsistency\n                    if (axis === firstX) {\n                        axis.titleShape.each(function () {\n                            d3.select(this).attr(\"y\", titleY + this.getBBox().height / 1.65);\n                        });\n                    } else if (axis === firstY) {\n                        axis.titleShape.each(function () {\n                            d3.select(this).attr(\"x\", titleX + this.getBBox().height / 1.65);\n                        });\n                    }\n                }\n               // }\n            }, this);\n\n            // Iterate the series\n            this.series.forEach(function (series) {\n                series.plot.draw(this, series, duration);\n                this._registerEventHandlers(series);\n            }, this);\n\n            // Iterate the legends\n            this.legends.forEach(function (legend) {\n                legend._draw(duration);\n            }, this);\n\n            // If the chart has a storyboard\n            if (this.storyboard !== null && this.storyboard !== undefined) {\n                this.storyboard._drawText();\n                if (this.storyboard.autoplay) {\n                    this.storyboard.startAnimation();\n                }\n            }\n\n            // Return the chart for chaining\n            return this;\n\n        };\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/getColor.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-getColor\n        this.getColor = function (tag) {\n            // If no color is assigned, do so here\n            if (this._assignedColors[tag] === null || this._assignedColors[tag] === undefined) {\n                this._assignedColors[tag] = this.defaultColors[this._nextColor];\n                this._nextColor = (this._nextColor + 1) % this.defaultColors.length;\n            }\n            // Return the color\n            return this._assignedColors[tag];\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/setBounds.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-setBounds\n        this.setBounds = function (x, y, width, height) {\n            // Store the passed parameters\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.height = height;\n            // Access the pixel value of the x coordinate\n            this._xPixels = function () {\n                return dimple._parseXPosition(this.x, this.svg.node());\n            };\n            // Access the pixel value of the y coordinate\n            this._yPixels = function () {\n                return dimple._parseYPosition(this.y, this.svg.node());\n            };\n            // Access the pixel value of the width coordinate\n            this._widthPixels = function () {\n                return dimple._parseXPosition(this.width, this.svg.node());\n            };\n            // Access the pixel value of the width coordinate\n            this._heightPixels = function () {\n                return dimple._parseYPosition(this.height, this.svg.node());\n            };\n            // Refresh the axes to redraw them against the new bounds\n            this.draw(0, true);\n            // return the chart object for method chaining\n            return this;\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/setMargins.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-setMargins\n        this.setMargins = function (left, top, right, bottom) {\n            // Set the bounds here, functions below will be used for access\n            this.x = left;\n            this.y = top;\n            this.width = 0;\n            this.height = 0;\n            // Access the pixel value of the x coordinate\n            this._xPixels = function () {\n                return dimple._parseXPosition(this.x, this.svg.node());\n            };\n            // Access the pixel value of the y coordinate\n            this._yPixels = function () {\n                return dimple._parseYPosition(this.y, this.svg.node());\n            };\n            // Access the pixel value of the width coordinate\n            this._widthPixels = function () {\n                return dimple._parentWidth(this.svg.node()) - this._xPixels() - dimple._parseXPosition(right, this.svg.node());\n            };\n            // Access the pixel value of the width coordinate\n            this._heightPixels = function () {\n                return dimple._parentHeight(this.svg.node()) - this._yPixels() - dimple._parseYPosition(bottom, this.svg.node());\n            };\n            // Refresh the axes to redraw them against the new bounds\n            this.draw(0, true);\n            // return the chart object for method chaining\n            return this;\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/chart/methods/setStoryboard.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.chart#wiki-setStoryboard\n        this.setStoryboard = function (categoryFields, tickHandler) {\n            // Create and assign the storyboard\n            this.storyboard = new dimple.storyboard(this, categoryFields);\n            // Set the event handler\n            if (tickHandler !== null && tickHandler !== undefined) {\n                this.storyboard.onTick = tickHandler;\n            }\n            // Return the storyboard\n            return this.storyboard;\n        };\n\n    };\n    // End dimple.chart\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/color/begin.js\n    // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.color\n    dimple.color = function (fill, stroke, opacity) {\n\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.color#wiki-fill\n        this.fill = fill;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.color#wiki-stroke\n        this.stroke = (stroke === null || stroke === undefined ? d3.rgb(fill).darker(0.5).toString() : stroke);\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.color#wiki-opacity\n        this.opacity = (opacity === null || opacity === undefined ? 0.8 : opacity);\n\n    };\n    // End dimple.color\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/eventArgs/begin.js\n    // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.eventArgs\n    dimple.eventArgs = function () {\n\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.eventArgs#wiki-seriesValue\n        this.seriesValue = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.eventArgs#wiki-xValue\n        this.xValue = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.eventArgs#wiki-yValue\n        this.yValue = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.eventArgs#wiki-zValue\n        this.zValue = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.eventArgs#wiki-colorValue\n        this.colorValue = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.eventArgs#wiki-frameValue\n        this.frameValue = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.eventArgs#wiki-seriesShapes\n        this.seriesShapes = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.eventArgs#wiki-selectedShape\n        this.selectedShape = null;\n\n    };\n    // End dimple.eventArgs\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/legend/begin.js\n    // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.legend\n    dimple.legend = function (chart, x, y, width, height, horizontalAlign, series) {\n\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.legend#wiki-chart\n        this.chart = chart;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.legend#wiki-series\n        this.series = series;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.legend#wiki-x\n        this.x = x;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.legend#wiki-y\n        this.y = y;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.legend#wiki-width\n        this.width = width;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.legend#wiki-height\n        this.height = height;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.legend#wiki-horizontalAlign\n        this.horizontalAlign = horizontalAlign;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.legend#wiki-shapes\n        this.shapes = null;\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/legend/methods/_draw.js\n        // Render the legend\n        this._draw = function (duration) {\n\n            // Create an array of distinct color elements from the series\n            var legendArray = this._getEntries(),\n                maxWidth = 0,\n                maxHeight = 0,\n                runningX = 0,\n                runningY = 0,\n                keyWidth = 15,\n                keyHeight = 9,\n                self = this,\n                theseShapes;\n\n            // If there is already a legend, fade to transparent and remove\n            if (this.shapes !== null && this.shapes !== undefined) {\n                this.shapes\n                    .transition()\n                    .duration(duration * 0.2)\n                    .attr(\"opacity\", 0)\n                    .remove();\n            }\n\n            // Create an empty hidden group for every legend entry\n            // the selector here must not pick up any legend entries being removed by the\n            // transition above\n            theseShapes = this.chart._group\n                .selectAll(\".dontSelectAny\")\n                .data(legendArray)\n                .enter()\n                .append(\"g\")\n                    .attr(\"class\", \"legend\")\n                    .attr(\"opacity\", 0);\n\n            // Add text into the group\n            theseShapes.append(\"text\")\n                .attr(\"id\", function (d) { return \"legend_\" + d.key; })\n                .attr(\"class\", \"legendText\")\n                .text(function(d) {\n                    return d.key;\n                })\n                .call(function () {\n                    if (!self.chart.noFormats) {\n                        this.style(\"font-family\", \"sans-serif\")\n                            .style(\"font-size\", (self.chart._heightPixels() / 35 > 10 ? self.chart._heightPixels() / 35 : 10) + \"px\")\n                            .style(\"shape-rendering\", \"crispEdges\");\n                    }\n                })\n                .each(function () {\n                    var b = this.getBBox();\n                    if (b.width > maxWidth) {\n                        maxWidth = b.width;\n                    }\n                    if (b.height > maxHeight) {\n                        maxHeight = b.height;\n                    }\n                });\n\n            // Add a rectangle into the group\n            theseShapes.append(\"rect\")\n                .attr(\"class\", \"legendKey\")\n                .attr(\"height\", keyHeight)\n                .attr(\"width\",  keyWidth);\n\n            // Expand the bounds of the largest shape slightly.  This will be the size allocated to\n            // all elements\n            maxHeight = (maxHeight < keyHeight ? keyHeight : maxHeight) + 2;\n            maxWidth += keyWidth + 20;\n\n            // Iterate the shapes and position them based on the alignment and size of the legend\n            theseShapes\n                .each(function (d) {\n                    if (runningX + maxWidth > self._widthPixels()) {\n                        runningX = 0;\n                        runningY += maxHeight;\n                    }\n                    if (runningY > self._heightPixels()) {\n                        d3.select(this).remove();\n                    } else {\n                        d3.select(this).select(\"text\")\n                            .attr(\"x\", (self.horizontalAlign === \"left\" ? self._xPixels() + keyWidth + 5 + runningX : self._xPixels() + (self._widthPixels() - runningX - maxWidth) + keyWidth + 5))\n                            .attr(\"y\", function () {\n                                // This was previously done with dominant-baseline but this is used\n                                // instead due to browser inconsistancy.\n                                return self._yPixels() + runningY + this.getBBox().height / 1.65;\n                            })\n                            .attr(\"width\", self._widthPixels())\n                            .attr(\"height\", self._heightPixels());\n                        d3.select(this).select(\"rect\")\n                            .attr(\"class\", \"legend legendKey\")\n                            .attr(\"x\", (self.horizontalAlign === \"left\" ? self._xPixels() + runningX : self._xPixels() + (self._widthPixels() - runningX - maxWidth)))\n                            .attr(\"y\", self._yPixels() + runningY)\n                            .attr(\"height\", keyHeight)\n                            .attr(\"width\",  keyWidth)\n                            .style(\"fill\", function () { return dimple._helpers.fill(d, self.chart, d.series); })\n                            .style(\"stroke\", function () { return dimple._helpers.stroke(d, self.chart, d.series); })\n                            .style(\"opacity\", function () { return dimple._helpers.opacity(d, self.chart, d.series); })\n                            .style(\"shape-rendering\", \"crispEdges\");\n                        runningX += maxWidth;\n                    }\n                });\n\n            // Fade in the shapes if this is transitioning\n            theseShapes\n                .transition()\n                .delay(duration * 0.2)\n                .duration(duration * 0.8)\n                .attr(\"opacity\", 1);\n\n            // Assign them to the public property for modification by the user.\n            this.shapes = theseShapes;\n        };\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/legend/methods/_getEntries.js\n        // Get an array of elements to be displayed in the legend\n        this._getEntries = function () {\n            // Create an array of distinct series values\n            var entries = [];\n            // If there are some series\n            if (this.series !== null && this.series !== undefined) {\n                // Iterate all the associated series\n                this.series.forEach(function (series) {\n                    // Get the series data\n                    var data = series._positionData;\n                    // Iterate the aggregated data\n                    data.forEach(function (row) {\n                        // Check whether this element is new\n                        var index = -1,\n                            j;\n                        for (j = 0; j < entries.length; j += 1) {\n                            if (entries[j].key === row.aggField.slice(-1)[0]) {\n                                index = j;\n                                break;\n                            }\n                        }\n                        if (index === -1) {\n                            // If it's a new element create a new row in the return array\n                            entries.push({ key: row.aggField.slice(-1)[0], fill: row.fill, stroke: row.stroke, series: series, aggField: row.aggField });\n                            index = entries.length - 1;\n                        }\n                    });\n                }, this);\n            }\n            return entries;\n        };\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/legend/methods/_heightPixels.js\n        // Access the pixel value of the height of the legend area\n        this._heightPixels = function () {\n            return dimple._parseYPosition(this.height, this.chart.svg.node());\n        };\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/legend/methods/_widthPixels.js\n        // Access the pixel value of the width of the legend area\n        this._widthPixels = function () {\n            return dimple._parseXPosition(this.width, this.chart.svg.node());\n        };\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/legend/methods/_xPixels.js\n        // Access the pixel position of the x co-ordinate of the legend area\n        this._xPixels = function () {\n            return dimple._parseXPosition(this.x, this.chart.svg.node());\n        };\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/legend/methods/_yPixels.js\n        // Access the pixel position of the y co-ordinate of the legend area\n        this._yPixels = function () {\n            return dimple._parseYPosition(this.y, this.chart.svg.node());\n        };\n    };\n    // End dimple.legend\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/series/begin.js\n    // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series\n    dimple.series = function (chart, categoryFields, xAxis, yAxis, zAxis, colorAxis, plotFunction, aggregateFunction, stacked) {\n\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-chart\n        this.chart = chart;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-x\n        this.x = xAxis;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-y\n        this.y = yAxis;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-z\n        this.z = zAxis;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-c\n        this.c = colorAxis;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-plot\n        this.plot = plotFunction;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-categoryFields\n        this.categoryFields = categoryFields;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-aggregateFunction\n        this.aggregate = aggregateFunction;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-stacked\n        this.stacked = stacked;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-barGap\n        this.barGap = 0.2;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-clusterBarGap\n        this.clusterBarGap = 0.1;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-lineWeight\n        this.lineWeight = 2;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-lineMarkers\n        this.lineMarkers = false;\n\n        // Any event handlers joined to this series\n        this._eventHandlers = [];\n        // The series positioning information\n        this._positionData = [];\n        // The order definition array\n        this._orderRules = [];\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/series/methods/_axisBounds.js\n        this._axisBounds = function (position) {\n            var bounds = { min: 0, max: 0 },\n                // The primary axis for this comparison\n                primaryAxis = null,\n                // The secondary axis for this comparison\n                secondaryAxis = null,\n                // The running totals of the categories\n                categoryTotals = [],\n                // The maximum index of category totals\n                catCount = 0,\n                measureName,\n                fieldName,\n                distinctCats,\n                aggData = this._positionData;\n\n            // If the primary axis is x the secondary is y and vice versa, a z axis has no secondary\n            if (position === \"x\") {\n                primaryAxis = this.x;\n                secondaryAxis = this.y;\n            } else if (position === \"y\") {\n                primaryAxis = this.y;\n                secondaryAxis = this.x;\n            } else if (position === \"z\") {\n                primaryAxis = this.z;\n            } else if (position === \"c\") {\n                primaryAxis = this.c;\n            }\n\n            // If the corresponding axis is category axis\n            if (primaryAxis.showPercent) {\n                // Iterate the data\n                aggData.forEach(function (d) {\n                    if (d[primaryAxis.position + \"Bound\"] < bounds.min) {\n                        bounds.min = d[primaryAxis.position + \"Bound\"];\n                    }\n                    if (d[primaryAxis.position + \"Bound\"] > bounds.max) {\n                        bounds.max = d[primaryAxis.position + \"Bound\"];\n                    }\n                }, this);\n            } else if (secondaryAxis === null || secondaryAxis.categoryFields === null || secondaryAxis.categoryFields.length === 0) {\n                aggData.forEach(function (d) {\n                    // If the primary axis is stacked\n                    if (this.stacked && (primaryAxis.position === \"x\" || primaryAxis.position === \"y\")) {\n                        // We just need to push the bounds.  A stacked axis will always include 0 so I just need to push the min and max out from there\n                        if (d[primaryAxis.position + \"Value\"] < 0) {\n                            bounds.min = bounds.min + d[primaryAxis.position + \"Value\"];\n                        } else {\n                            bounds.max = bounds.max + d[primaryAxis.position + \"Value\"];\n                        }\n                    } else {\n                        // If it isn't stacked we need to catch the minimum and maximum values\n                        if (d[primaryAxis.position + \"Value\"] < bounds.min) {\n                            bounds.min = d[primaryAxis.position + \"Value\"];\n                        }\n                        if (d[primaryAxis.position + \"Value\"] > bounds.max) {\n                            bounds.max = d[primaryAxis.position + \"Value\"];\n                        }\n                    }\n                }, this);\n            } else {\n                // If this category value (or combination if multiple fields defined) is not already in the array of categories, add it.\n                measureName = primaryAxis.position + \"Value\";\n                fieldName = secondaryAxis.position + \"Field\";\n                // Get a list of distinct categories on the secondary axis\n                distinctCats = [];\n                aggData.forEach(function (d) {\n                    // Create a field for this row in the aggregated data\n                    var field = d[fieldName].join(\"/\"),\n                        index = distinctCats.indexOf(field);\n                    if (index === -1) {\n                        distinctCats.push(field);\n                        index = distinctCats.length - 1;\n                    }\n                    // Get the index of the field\n                    if (categoryTotals[index] === undefined) {\n                        categoryTotals[index] = { min: 0, max: 0 };\n                        if (index >= catCount) {\n                            catCount = index + 1;\n                        }\n                    }\n                    // The secondary axis is a category axis, we need to account\n                    // for distribution across categories\n                    if (this.stacked) {\n                        if (d[measureName] < 0) {\n                            categoryTotals[index].min = categoryTotals[index].min + d[measureName];\n                        } else {\n                            categoryTotals[index].max = categoryTotals[index].max + d[measureName];\n                        }\n                    } else {\n                        // If it isn't stacked we need to catch the minimum and maximum values\n                        if (d[measureName] < categoryTotals[index].min) {\n                            categoryTotals[index].min = d[measureName];\n                        }\n                        if (d[measureName] > categoryTotals[index].max) {\n                            categoryTotals[index].max = d[measureName];\n                        }\n                    }\n                }, this);\n                categoryTotals.forEach(function (catTot) {\n                    if (catTot !== undefined) {\n                        if (catTot.min < bounds.min) {\n                            bounds.min = catTot.min;\n                        }\n                        if (catTot.max > bounds.max) {\n                            bounds.max = catTot.max;\n                        }\n                    }\n                }, this);\n            }\n            return bounds;\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/series/methods/_dropLineOrigin.js\n        this._dropLineOrigin = function() {\n\n            // Get the origin co-ordinates for axis drop lines\n            var xIndex = 0,\n                yIndex = 0,\n                // This contains the drop line destinations\n                coord = {\n                    // The x co-ordinate for a y-axis drop line\n                    x: null,\n                    // The y co-ordinate for an x-axis drop line\n                    y: null\n                },\n                // The origin of the first axes\n                firstOrig = {\n                    x: null,\n                    y: null\n                };\n            // Get the first x and y first of all\n            this.chart.axes.forEach(function (axis) {\n                if (axis.position === \"x\" && firstOrig.x === null) {\n                    if (axis._hasTimeField()) {\n                        firstOrig.x = this.chart._xPixels();\n                    } else {\n                        firstOrig.x = axis._origin;\n                    }\n                } else if (axis.position === \"y\" && firstOrig.y === null) {\n                    if (axis._hasTimeField()) {\n                        firstOrig.y = this.chart._yPixels() + this.chart._heightPixels();\n                    } else {\n                        firstOrig.y = axis._origin;\n                    }\n                }\n            }, this);\n            // Get the axis position based on the axis index\n            this.chart.axes.forEach(function (axis) {\n                if (axis.position === \"x\" && !this.x.hidden) {\n                    if (axis === this.x) {\n                        // Set the y co-ordinate for the x axis \n                        if (xIndex === 0) {\n                            coord.y = firstOrig.y;\n                        } else if (xIndex === 1) {\n                            coord.y = this.chart._yPixels();\n                        }\n                    }\n                    xIndex += 1;\n                } else if (axis.position === \"y\" && !this.y.hidden) {\n                    if (axis === this.y) {\n                        // Set the x co-ordinate for the y axis \n                        if (yIndex === 0) {\n                            coord.x = firstOrig.x;\n                        } else if (yIndex === 1) {\n                            coord.x = this.chart._xPixels() + this.chart._widthPixels();\n                        }\n                    }\n                    yIndex += 1;\n                }\n            }, this);\n\n            // Return the co-ordinate\n            return coord;\n        };\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/series/methods/addEventHandler.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-addEventHandler\n        this.addEventHandler = function (event, handler) {\n            this._eventHandlers.push({ event: event, handler: handler });\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/series/methods/addOrderRule.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.series#wiki-addOrderRule\n        this.addOrderRule = function (ordering, desc) {\n            this._orderRules.push({ ordering : ordering, desc : desc });\n        };\n    };\n    // End dimple.series\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/storyboard/begin.js\n    // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.storyboard\n    dimple.storyboard = function (chart, categoryFields) {\n\n        // Handle an individual string as an array\n        if (categoryFields !== null && categoryFields !== undefined) {\n            categoryFields = [].concat(categoryFields);\n        }\n\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.storyboard#wiki-chart\n        this.chart = chart;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.storyboard#wiki-categoryFields\n        this.categoryFields = categoryFields;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.storyboard#wiki-autoplay\n        this.autoplay = true;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.storyboard#wiki-frameDuration\n        this.frameDuration = 3000;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.storyboard#wiki-storyLabel\n        this.storyLabel = null;\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.storyboard#wiki-onTick\n        this.onTick = null;\n\n        // The current frame index\n        this._frame = 0;\n        // The animation interval\n        this._animationTimer = null;\n        // The category values\n        this._categories = [];\n        // The category values when the last cache happened\n        this._cachedCategoryFields = [];\n        // The rules for ordering the storyboard\n        this._orderRules = [];\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/storyboard/methods/drawText.js\n        this._drawText = function (duration) {\n            if (this.storyLabel === null || this.storyLabel === undefined) {\n                var chart = this.chart,\n                    xCount = 0;\n                // Check for a secondary x axis\n                this.chart.axes.forEach(function (a) {\n                    if (a.position === \"x\") {\n                        xCount += 1;\n                    }\n                }, this);\n                this.storyLabel = this.chart._group.append(\"text\")\n                    .attr(\"x\", this.chart._xPixels() + this.chart._widthPixels() * 0.01)\n                    .attr(\"y\", this.chart._yPixels() + (this.chart._heightPixels() / 35 > 10 ? this.chart._heightPixels() / 35 : 10) * (xCount > 1 ? 1.25 : -1))\n                    .call(function () {\n                        if (!chart.noFormats) {\n                            this.style(\"font-family\", \"sans-serif\")\n                                .style(\"font-size\", (chart._heightPixels() / 35 > 10 ? chart._heightPixels() / 35 : 10) + \"px\");\n                        }\n                    });\n            }\n            this.storyLabel\n                .transition().duration(duration * 0.2)\n                .attr(\"opacity\", 0);\n            this.storyLabel\n                .transition().delay(duration * 0.2)\n                .text(this.categoryFields.join(\"\\\\\") + \": \" + this.getFrameValue())\n                .transition().duration(duration * 0.8)\n                .attr(\"opacity\", 1);\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/storyboard/methods/_getCategories.js\n        this._getCategories = function() {\n            if (this._categoryFields !== this._cachedCategoryFields) {\n                // Clear the array\n                this._categories = [];\n                // Iterate every row in the data\n                this.chart._getAllData().forEach(function (d) {\n                    // Initialise the index of the categories array matching the current row\n                    var index = -1,\n                        field = \"\";\n                    // If this is a category axis handle multiple category values by iterating the fields in the row and concatonate the values\n                    if (this.categoryFields !== null) {\n                        this.categoryFields.forEach(function (cat, i) {\n                            if (i > 0) {\n                                field += \"/\";\n                            }\n                            field += d[cat];\n                        }, this);\n                        index = this._categories.indexOf(field);\n                        if (index === -1) {\n                            this._categories.push(field);\n                            index = this._categories.length - 1;\n                        }\n                    }\n                }, this);\n                // Mark this as cached\n                this._cachedCategoryFields = this._categoryFields;\n            }\n            // Return the array\n            return this._categories;\n        };\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/storyboard/methods/_goToFrameIndex.js\n        this._goToFrameIndex = function (index) {\n            this._frame = index % this._getCategories().length;\n            // Draw it with half duration, we want the effect of a 50% animation 50% pause.\n            this.chart.draw(this.frameDuration / 2);\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/storyboard/methods/addOrderRule.js\n        // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple.storyboard#wiki-addOrderRule\n        this.addOrderRule = function (ordering, desc) {\n            this._orderRules.push({ ordering : ordering, desc : desc });\n        };\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/storyboard/methods/getFrameValue.js\n        this.getFrameValue = function () {\n            var returnValue = null;\n            if (this._frame >= 0 && this._getCategories().length > this._frame) {\n                returnValue = this._getCategories()[this._frame];\n            }\n            return returnValue;\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/storyboard/methods/goToFrame.js\n        this.goToFrame = function (frameText) {\n            if (this._getCategories().length > 0) {\n                var index = this._getCategories().indexOf(frameText);\n                this._goToFrameIndex(index);\n            }\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/storyboard/methods/pauseAnimation.js\n        this.pauseAnimation = function () {\n            if (this._animationTimer !== null) {\n                window.clearInterval(this._animationTimer);\n                this._animationTimer = null;\n            }\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/storyboard/methods/startAnimation.js\n        this.startAnimation = function () {\n            if (this._animationTimer === null) {\n                if (this.onTick !== null) { this.onTick(this.getFrameValue()); }\n                this._animationTimer = window.setInterval((function (storyboard) {\n                    return function () {\n                        storyboard._goToFrameIndex(storyboard._frame + 1);\n                        if (storyboard.onTick !== null) {\n                            storyboard.onTick(storyboard.getFrameValue());\n                        }\n                        storyboard._drawText(storyboard.frameDuration / 2);\n                    };\n                }(this)), this.frameDuration);\n            }\n        };\n\n\n        // Copyright: 2013 PMSI-AlignAlytics\n        // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n        // Source: /src/objects/storyboard/methods/stopAnimation.js\n        this.stopAnimation = function () {\n            if (this._animationTimer !== null) {\n                window.clearInterval(this._animationTimer);\n                this._animationTimer = null;\n                this._frame = 0;\n            }\n        };\n\n\n    };\n    // End dimple.storyboard\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/aggregateMethod/avg.js\n    dimple.aggregateMethod.avg = function (lhs, rhs) {\n        lhs.value = (lhs.value === null || lhs.value === undefined ? 0 : parseFloat(lhs.value));\n        lhs.count = (lhs.count === null || lhs.count === undefined ? 1 : parseFloat(lhs.count));\n        rhs.value = (rhs.value === null || rhs.value === undefined ? 0 : parseFloat(rhs.value));\n        rhs.count = (rhs.count === null || rhs.count === undefined ? 1 : parseFloat(rhs.count));\n        return ((lhs.value * lhs.count) + (rhs.value * rhs.count)) / (lhs.count + rhs.count);\n    };\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/aggregateMethod/count.js\n    dimple.aggregateMethod.count = function (lhs, rhs) {\n        lhs.count = (lhs.count === null || lhs.count === undefined ? 0 : parseFloat(lhs.count));\n        rhs.count = (rhs.count === null || rhs.count === undefined ? 0 : parseFloat(rhs.count));\n        return lhs.count + rhs.count;\n    };\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/aggregateMethod/max.js\n    dimple.aggregateMethod.max = function (lhs, rhs) {\n        lhs.value = (lhs.value === null || lhs.value === undefined ? 0 : parseFloat(lhs.value));\n        rhs.value = (rhs.value === null || rhs.value === undefined ? 0 : parseFloat(rhs.value));\n        return lhs.value > rhs.value ? lhs.value : rhs.value;\n    };\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/aggregateMethod/min.js\n    dimple.aggregateMethod.min = function (lhs, rhs) {\n        return (lhs.value === null ? parseFloat(rhs.value) : (parseFloat(lhs.value) < parseFloat(rhs.value) ? parseFloat(lhs.value) : parseFloat(rhs.value)));\n    };\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/aggregateMethod/sum.js\n    dimple.aggregateMethod.sum = function (lhs, rhs) {\n        lhs.value = (lhs.value === null || lhs.value === undefined ? 0 : parseFloat(lhs.value));\n        rhs.value = (rhs.value === null || rhs.value === undefined ? 0 : parseFloat(rhs.value));\n        return lhs.value + rhs.value;\n    };\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/plot/area.js\n    dimple.plot.area = {\n        stacked: true,\n\n        supportedAxes: [\"x\", \"y\", \"c\"],\n\n        draw: function (chart, series, duration) {\n            // Get self pointer for inner functions\n            var self = this,\n                data = series._positionData,\n                uniqueValues = [],\n                firstAgg = 1,\n                graded = false,\n                line,\n                catPoints = {},\n                markers,\n                markerBacks;\n\n            if (chart._tooltipGroup !== null && chart._tooltipGroup !== undefined) {\n                chart._tooltipGroup.remove();\n            }\n\n            // If there is a category axis we should draw a line for each aggField.  Otherwise\n            // the first aggField defines the points and the others define the line\n            if (series.x._hasCategories() || series.y._hasCategories()) {\n                firstAgg = 0;\n            }\n            data.forEach(function (d) {\n                var filter = [],\n                    match = false,\n                    k;\n                for (k = firstAgg; k < d.aggField.length; k += 1) {\n                    filter.push(d.aggField[k]);\n                }\n                uniqueValues.forEach(function (e) {\n                    match = match || (e === filter.join(\"/\"));\n                }, this);\n                if (!match) {\n                    uniqueValues.push(filter.join(\"/\"));\n                }\n            }, this);\n\n            if (series.c !== null && series.c !== undefined && ((series.x._hasCategories() && series.y._hasMeasure()) || (series.y._hasCategories() && series.x._hasMeasure()))) {\n                graded = true;\n                uniqueValues.forEach(function (seriesValue) {\n                    dimple._addGradient(seriesValue, \"fill-area-gradient-\" + seriesValue.join(\"_\").replace(\" \", \"\"), (series.x._hasCategories() ? series.x : series.y), data, chart, duration, \"fill\");\n                    dimple._addGradient(seriesValue, \"stroke-area-gradient-\" + seriesValue.join(\"_\").replace(\" \", \"\"), (series.x._hasCategories() ? series.x : series.y), data, chart, duration, \"stroke\");\n                }, this);\n            }\n\n            line = d3.svg.line()\n                    .x(function (d) { return dimple._helpers.cx(d, chart, series); })\n                    .y(function (d) { return dimple._helpers.cy(d, chart, series); });\n\n            if (series.shapes === null || series.shapes === undefined) {\n                series.shapes = chart._group.selectAll(\".area\")\n                    .data(uniqueValues)\n                    .enter()\n                        .append(\"svg:path\")\n                        .attr(\"opacity\", function(d) { return chart.getColor(d).opacity; });\n            }\n\n            series.shapes\n                .data(uniqueValues)\n                .transition()\n                .duration(duration)\n                .attr(\"class\", function (d) { return \"series area \" + d.split(\" \").join(\"_\"); })\n                .attr(\"d\", function (d) {\n                    var seriesData,\n                        baseline = [],\n                        max = 0,\n                        row,\n                        newObj,\n                        j,\n                        k,\n                        m,\n                        q,\n                        r;\n                    seriesData = dimple.filterData(data, \"aggField\", d);\n                    seriesData.sort(function (a, b) {\n                        var sortValue = 0;\n                        if (series.x._hasCategories()) {\n                            sortValue = (dimple._helpers.cx(a, chart, series) < dimple._helpers.cx(b, chart, series) ? -1 : 1);\n                        } else if (series.y._hasCategories()) {\n                            sortValue = (dimple._helpers.cy(a, chart, series) < dimple._helpers.cy(b, chart, series) ? -1 : 1);\n                        }\n                        return sortValue;\n                    });\n                    for (j = seriesData.length - 1; j >= 0; j -= 1) {\n                        row = seriesData[j];\n                        newObj = { cx: 0, cy: 0, height: 0, width: 0, xOffset: 0, yOffset: 0 };\n                        if (series.x._hasCategories()) {\n                            // Fix the x properties\n                            newObj.cx = row.cx;\n                            newObj.width = row.width;\n                            newObj.xOffset = row.xOffset;\n                            // Find the largest value for the xField less than this value\n                            if (catPoints[row.xField] === undefined) {\n                                catPoints[row.xField] = [];\n                            } else {\n                                max = 0;\n                                for (k = 0; k <= catPoints[row.xField].length; k += 1) {\n                                    q = catPoints[row.xField][k];\n                                    if ((row.cy >= 0 && q >= 0) || (row.cy <= 0 && q <= 0)) {\n                                        if (Math.abs(q) <= Math.abs(row.cy) && Math.abs(q) > Math.abs(max)) {\n                                            max = q;\n                                        }\n                                    }\n                                }\n                                newObj.cy = max;\n                            }\n                            baseline.push(newObj);\n                            catPoints[row.xField].push(row.cy);\n                        } else if (series.y._hasCategories()) {\n                            // Fix the y properties\n                            newObj.cy = row.cy;\n                            newObj.height = row.height;\n                            newObj.yOffset = row.yOffset;\n                            // Find the largest value for the xField less than this value\n                            if (catPoints[row.yField] === undefined) {\n                                catPoints[row.yField] = [];\n                            } else {\n                                max = 0;\n                                for (m = 0; m <= catPoints[row.yField].length; m += 1) {\n                                    r = catPoints[row.yField][m];\n                                    if ((row.cx >= 0 && r >= 0) || (row.cx <= 0 && r <= 0)) {\n                                        if (Math.abs(r) <= Math.abs(row.cx) && Math.abs(r) > Math.abs(max)) {\n                                            max = r;\n                                        }\n                                    }\n                                }\n                                newObj.cx = max;\n                            }\n                            baseline.push(newObj);\n                            catPoints[row.yField].push(row.cx);\n                        }\n                    }\n                    //return line(startPoint.concat(seriesData).concat(endPoint));\n                    return line(seriesData.concat(baseline).concat(seriesData[0]));\n                })\n                .call(function () {\n                    if (!chart.noFormats) {\n                        this.attr(\"fill\", function (d) { return (graded ? \"url(#fill-area-gradient-\" + d.join(\"_\").replace(\" \", \"\") + \")\" : chart.getColor(d).fill); })\n                            .attr(\"stroke\", function (d) { return (graded ? \"url(#stroke-area-gradient-\" + d.join(\"_\").replace(\" \", \"\") + \")\" : chart.getColor(d).stroke); })\n                            .attr(\"stroke-width\", series.lineWeight);\n                    }\n                });\n\n            if (series.lineMarkers) {\n                if (series._markerBacks === null || series._markerBacks === undefined) {\n                    markerBacks = chart._group.selectAll(\".markerBacks\").data(data);\n                } else {\n                    markerBacks = series._markerBacks.data(data, function (d) { return d.key; });\n                }\n                // Add\n                markerBacks\n                    .enter()\n                    .append(\"circle\")\n                    .attr(\"id\", function (d) { return d.key; })\n                    .attr(\"class\", \"markerBacks\")\n                    .attr(\"cx\", function (d) { return dimple._helpers.cx(d, chart, series); })\n                    .attr(\"cy\", function (d) { return dimple._helpers.cy(d, chart, series); })\n                    .attr(\"r\", 0)\n                    .attr(\"fill\", \"white\")\n                    .attr(\"stroke\", \"none\");\n\n                // Update\n                markerBacks\n                    .transition().duration(duration)\n                    .attr(\"cx\", function (d) { return dimple._helpers.cx(d, chart, series); })\n                    .attr(\"cy\", function (d) { return dimple._helpers.cy(d, chart, series); })\n                    .attr(\"r\", 2 + series.lineWeight);\n                // Remove\n                markerBacks\n                    .exit()\n                    .transition().duration(duration)\n                    .attr(\"r\", 0)\n                    .each(\"end\", function () {\n                        d3.select(this).remove();\n                    });\n                series._markerBacks = markerBacks;\n            }\n\n            // Deal with markers in the same way as main series to fix #28\n            if (series._markers === null || series._markers === undefined) {\n                markers = chart._group.selectAll(\".markers\").data(data);\n            } else {\n                markers = series._markers.data(data, function (d) { return d.key; });\n            }\n\n\n            // Add the actual marker. We need to do this even if we aren't displaying them because they\n            // catch hover events\n            markers\n                .enter()\n                .append(\"circle\")\n                .attr(\"id\", function (d) { return d.key; })\n                .attr(\"class\", \"markers\")\n                .on(\"mouseover\", function (e) {\n                    self.enterEventHandler(e, this, chart, series);\n                })\n                .on(\"mouseleave\", function (e) {\n                    self.leaveEventHandler(e, this, chart, series);\n                })\n                .attr(\"cx\", function (d) { return dimple._helpers.cx(d, chart, series); })\n                .attr(\"cy\", function (d) { return dimple._helpers.cy(d, chart, series); })\n                .attr(\"r\", 0)\n                .attr(\"opacity\", function (d) { return (series.lineMarkers ? chart.getColor(d).opacity : 0); })\n                .call(function () {\n                    if (!chart.noFormats) {\n                        this.attr(\"fill\", \"white\")\n                            .style(\"stroke-width\", series.lineWeight)\n                            .attr(\"stroke\", function (d) {\n                                return (graded ? dimple._helpers.fill(d, chart, series) : chart.getColor(d.aggField[d.aggField.length - 1]).stroke);\n                            });\n                    }\n                });\n\n            markers\n                .transition().duration(duration)\n                .attr(\"cx\", function (d) { return dimple._helpers.cx(d, chart, series); })\n                .attr(\"cy\", function (d) { return dimple._helpers.cy(d, chart, series); })\n                .attr(\"r\", 2 + series.lineWeight)\n                .call(function () {\n                    if (!chart.noFormats) {\n                        this.attr(\"fill\", \"white\")\n                            .style(\"stroke-width\", series.lineWeight)\n                            .attr(\"stroke\", function (d) {\n                                return (graded ? dimple._helpers.fill(d, chart, series) : chart.getColor(d.aggField[d.aggField.length - 1]).stroke);\n                            });\n                    }\n                });\n\n            markers\n                .exit()\n                .transition().duration(duration)\n                .attr(\"r\", 0)\n                .each(\"end\", function () {\n                    d3.select(this).remove();\n                });\n\n            // Save the shapes to the series array\n            series._markers = markers;\n        },\n\n        // Handle the mouse enter event\n        enterEventHandler: function (e, shape, chart, series) {\n\n            // The margin between the text and the box\n            var textMargin = 5,\n                // The margin between the ring and the popup\n                popupMargin = 10,\n                // The popup animation duration in ms\n                animDuration = 750,\n                // Collect some facts about the highlighted bubble\n                selectedShape = d3.select(shape),\n                cx = parseFloat(selectedShape.attr(\"cx\")),\n                cy = parseFloat(selectedShape.attr(\"cy\")),\n                r = parseFloat(selectedShape.attr(\"r\")),\n                opacity = dimple._helpers.opacity(e, chart, series),\n                fill = dimple._helpers.fill(e, chart, series),\n                dropDest = series._dropLineOrigin(),\n                // Fade the popup stroke mixing the shape fill with 60% white\n                popupStrokeColor = d3.rgb(\n                    d3.rgb(fill).r + 0.6 * (255 - d3.rgb(fill).r),\n                    d3.rgb(fill).g + 0.6 * (255 - d3.rgb(fill).g),\n                    d3.rgb(fill).b + 0.6 * (255 - d3.rgb(fill).b)\n                ),\n                // Fade the popup fill mixing the shape fill with 80% white\n                popupFillColor = d3.rgb(\n                    d3.rgb(fill).r + 0.8 * (255 - d3.rgb(fill).r),\n                    d3.rgb(fill).g + 0.8 * (255 - d3.rgb(fill).g),\n                    d3.rgb(fill).b + 0.8 * (255 - d3.rgb(fill).b)\n                ),\n                t,\n                y = 0,\n                w = 0,\n                h = 0,\n                box,\n                overlap,\n                rows = [];\n\n            if (chart._tooltipGroup !== null && chart._tooltipGroup !== undefined) {\n                chart._tooltipGroup.remove();\n            }\n            chart._tooltipGroup = chart.svg.append(\"g\");\n\n            // On hover make the line marker visible immediately\n            selectedShape.style(\"opacity\", 1);\n            // Add a ring around the data point\n            chart._tooltipGroup.append(\"circle\")\n                .attr(\"cx\", cx)\n                .attr(\"cy\", cy)\n                .attr(\"r\", r)\n                .attr(\"opacity\", 0)\n                .style(\"fill\", \"none\")\n                .style(\"stroke\", fill)\n                .style(\"stroke-width\", 1)\n                .transition()\n                .duration(animDuration / 2)\n                .ease(\"linear\")\n                    .attr(\"opacity\", 1)\n                    .attr(\"r\", r + 4)\n                    .style(\"stroke-width\", 2);\n\n            // Add a drop line to the x axis\n            if (dropDest.y !== null) {\n                chart._tooltipGroup.append(\"line\")\n                    .attr(\"x1\", cx)\n                    .attr(\"y1\", (cy < dropDest.y ? cy + r + 4 : cy - r - 4))\n                    .attr(\"x2\", cx)\n                    .attr(\"y2\", (cy < dropDest.y ? cy + r + 4 : cy - r - 4))\n                    .style(\"fill\", \"none\")\n                    .style(\"stroke\", fill)\n                    .style(\"stroke-width\", 2)\n                    .style(\"stroke-dasharray\", (\"3, 3\"))\n                    .style(\"opacity\", opacity)\n                    .transition()\n                        .delay(animDuration / 2)\n                        .duration(animDuration / 2)\n                        .ease(\"linear\")\n                        // Added 1px offset to cater for svg issue where a transparent\n                        // group overlapping a line can sometimes hide it in some browsers\n                        // Issue #10\n                        .attr(\"y2\", (cy < dropDest.y ? dropDest.y - 1 : dropDest.y + 1));\n            }\n\n            // Add a drop line to the y axis\n            if (dropDest.x !== null) {\n                chart._tooltipGroup.append(\"line\")\n                    .attr(\"x1\", (cx < dropDest.x ? cx + r + 4 : cx - r - 4))\n                    .attr(\"y1\", cy)\n                    .attr(\"x2\", (cx < dropDest.x ? cx + r + 4 : cx - r - 4))\n                    .attr(\"y2\", cy)\n                    .style(\"fill\", \"none\")\n                    .style(\"stroke\", fill)\n                    .style(\"stroke-width\", 2)\n                    .style(\"stroke-dasharray\", (\"3, 3\"))\n                    .style(\"opacity\", opacity)\n                    .transition()\n                        .delay(animDuration / 2)\n                        .duration(animDuration / 2)\n                        .ease(\"linear\")\n                        // Added 1px offset to cater for svg issue where a transparent\n                        // group overlapping a line can sometimes hide it in some browsers\n                        // Issue #10\n                        .attr(\"x2\", (cx < dropDest.x ? dropDest.x - 1 : dropDest.x + 1));\n            }\n\n            // Add a group for text\n            t = chart._tooltipGroup.append(\"g\");\n            // Create a box for the popup in the text group\n            box = t.append(\"rect\")\n                .attr(\"class\", \"tooltip\");\n\n            // Add the series categories\n            if (series.categoryFields !== null && series.categoryFields !== undefined && series.categoryFields.length > 0) {\n                series.categoryFields.forEach(function (c, i) {\n                    // If the category name and value match don't display the category name\n                    rows.push(c + (e.aggField[i] !== c ? \": \" + e.aggField[i] : \"\"));\n                }, this);\n            }\n\n            if (series.x._hasTimeField()) {\n                rows.push(series.x.timeField + \": \" + series.x._getFormat()(e.xField[0]));\n            } else if (series.x._hasCategories()) {\n                // Add the x axis categories\n                series.x.categoryFields.forEach(function (c, i) {\n                    // If the category name and value match don't display the category name\n                    rows.push(c + (e.xField[i] !== c ? \": \" + e.xField[i] : \"\"));\n                }, this);\n            } else {\n                // Add the axis measure value\n                rows.push(series.x.measure + \": \" + series.x._getFormat()(e.width));\n            }\n\n            if (series.y._hasTimeField()) {\n                rows.push(series.y.timeField + \": \" + series.y._getFormat()(e.yField[0]));\n            } else if (series.y._hasCategories()) {\n                // Add the y axis categories\n                series.y.categoryFields.forEach(function (c, i) {\n                    rows.push(c + (e.yField[i] !== c ? \": \" + e.yField[i] : \"\"));\n                }, this);\n            } else {\n                // Add the axis measure value\n                rows.push(series.y.measure + \": \" + series.y._getFormat()(e.height));\n            }\n\n            if (series.z !== null && series.z !== undefined) {\n                // Add the axis measure value\n                rows.push(series.z.measure + \": \" + series.z._getFormat()(e.zValue));\n            }\n\n            if (series.c !== null && series.c !== undefined) {\n                // Add the axis measure value\n                rows.push(series.c.measure + \": \" + series.c._getFormat()(e.cValue));\n            }\n\n            // Get distinct text rows to deal with cases where 2 axes have the same dimensionality\n            rows = rows.filter(function(elem, pos) {\n                return rows.indexOf(elem) === pos;\n            });\n\n            // Create a text object for every row in the popup\n            t.selectAll(\".textHoverShapes\").data(rows).enter()\n                .append(\"text\")\n                    .attr(\"class\", \"tooltip\")\n                    .text(function (d) { return d; })\n                    .style(\"font-family\", \"sans-serif\")\n                    .style(\"font-size\", \"10px\");\n\n            // Get the max height and width of the text items\n            t.each(function () {\n                w = (this.getBBox().width > w ? this.getBBox().width : w);\n                h = (this.getBBox().width > h ? this.getBBox().height : h);\n            });\n\n            // Position the text relatve to the bubble, the absolute positioning\n            // will be done by translating the group\n            t.selectAll(\"text\")\n                .attr(\"x\", 0)\n                .attr(\"y\", function () {\n                    // Increment the y position\n                    y += this.getBBox().height;\n                    // Position the text at the centre point\n                    return y - (this.getBBox().height / 2);\n                });\n\n            // Draw the box with a margin around the text\n            box.attr(\"x\", -textMargin)\n                .attr(\"y\", -textMargin)\n                .attr(\"height\", Math.floor(y + textMargin) - 0.5)\n                .attr(\"width\", w + 2 * textMargin)\n                .attr(\"rx\", 5)\n                .attr(\"ry\", 5)\n                .style(\"fill\", popupFillColor)\n                .style(\"stroke\", popupStrokeColor)\n                .style(\"stroke-width\", 2)\n                .style(\"opacity\", 0.95);\n\n            // Shift the ring margin left or right depending on whether it will overlap the edge\n            overlap = cx + r + textMargin + popupMargin + w > parseFloat(chart.svg.node().getBBox().width);\n\n            // Translate the shapes to the x position of the bubble (the x position of the shapes is handled)\n            t.attr(\"transform\", \"translate(\" +\n                   (overlap ? cx - (r + textMargin + popupMargin + w) : cx + r + textMargin + popupMargin) + \" , \" +\n                   (cy - ((y - (h - textMargin)) / 2)) +\n                \")\");\n        },\n\n        // Handle the mouse leave event\n        leaveEventHandler: function (e, shape, chart, series) {\n            // Return the opacity of the marker\n            d3.select(shape).style(\"opacity\", (series.lineMarkers ? dimple._helpers.opacity(e, chart, series) : 0));\n            if (chart._tooltipGroup !== null && chart._tooltipGroup !== undefined) {\n                chart._tooltipGroup.remove();\n            }\n        }\n    };\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/plot/bar.js\n    dimple.plot.bar = {\n\n        // By default the bar series is stacked if there are series categories\n        stacked: true,\n\n        // The axes which will affect the bar chart - not z\n        supportedAxes: [\"x\", \"y\", \"c\"],\n\n        // Draw the chart\n        draw: function (chart, series, duration) {\n\n            // Get self pointer for inner functions\n            var self = this,\n                // Get the series data\n                chartData = series._positionData,\n                // If the series is uninitialised create placeholders, otherwise use the existing shapes\n                theseShapes = null,\n                className = \"series\" + chart.series.indexOf(series);\n\n            if (chart._tooltipGroup !== null && chart._tooltipGroup !== undefined) {\n                chart._tooltipGroup.remove();\n            }\n\n            if (series.shapes === null || series.shapes === undefined) {\n                theseShapes = chart._group.selectAll(\".\" + className).data(chartData);\n            } else {\n                theseShapes = series.shapes.data(chartData, function (d) { return d.key; });\n            }\n\n            // Add\n            theseShapes\n                .enter()\n                .append(\"rect\")\n                .attr(\"id\", function (d) { return d.key; })\n                .attr(\"class\", function (d) {\n                    return className + \" bar \" +\n                        d.aggField.join(\" \").split(\" \").join(\"_\") + \" \" +\n                        d.xField.join(\" \").split(\" \").join(\"_\") + \" \" +\n                        d.yField.join(\" \").split(\" \").join(\"_\");\n                })\n                .attr(\"x\", function (d) { return dimple._helpers.x(d, chart, series); })\n                .attr(\"y\", function (d) { return dimple._helpers.y(d, chart, series) + dimple._helpers.height(d, chart, series); })\n                .attr(\"width\", function (d) {return (d.xField !== null && d.xField.length > 0 ? dimple._helpers.width(d, chart, series) : 0); })\n                .attr(\"height\", function (d) {return (d.yField !== null && d.yField.length > 0 ? dimple._helpers.height(d, chart, series) : 0); })\n                .attr(\"opacity\", function (d) { return dimple._helpers.opacity(d, chart, series); })\n                .on(\"mouseover\", function (e) {\n                    self.enterEventHandler(e, this, chart, series);\n                })\n                .on(\"mouseleave\", function () {\n                    self.leaveEventHandler(chart);\n                })\n                .call(function () {\n                    if (!chart.noFormats) {\n                        this.attr(\"fill\", function (d) { return dimple._helpers.fill(d, chart, series); })\n                            .attr(\"stroke\", function (d) { return dimple._helpers.stroke(d, chart, series); });\n                    }\n                });\n\n            // Update\n            theseShapes\n                .transition().duration(duration)\n                .attr(\"x\", function (d) { return dimple._helpers.x(d, chart, series); })\n                .attr(\"y\", function (d) { return dimple._helpers.y(d, chart, series); })\n                .attr(\"width\", function (d) { return dimple._helpers.width(d, chart, series); })\n                .attr(\"height\", function (d) { return dimple._helpers.height(d, chart, series); })\n                .call(function () {\n                    if (!chart.noFormats) {\n                        this.attr(\"fill\", function (d) { return dimple._helpers.fill(d, chart, series); })\n                            .attr(\"stroke\", function (d) { return dimple._helpers.stroke(d, chart, series); });\n                    }\n                });\n\n            // Remove\n            theseShapes\n                .exit()\n                .transition().duration(duration)\n                .attr(\"x\", function (d) { return dimple._helpers.x(d, chart, series); })\n                .attr(\"y\", function (d) { return dimple._helpers.y(d, chart, series); })\n                .attr(\"width\", function (d) { return dimple._helpers.width(d, chart, series); })\n                .attr(\"height\", function (d) { return dimple._helpers.height(d, chart, series); })\n                .each(\"end\", function () {\n                    d3.select(this).remove();\n                });\n\n            // Save the shapes to the series array\n            series.shapes = theseShapes;\n        },\n\n        // Handle the mouse enter event\n        enterEventHandler: function (e, shape, chart, series) {\n\n            // The margin between the text and the box\n            var textMargin = 5,\n                // The margin between the ring and the popup\n                popupMargin = 10,\n                // The popup animation duration in ms\n                animDuration = 750,\n                // Collect some facts about the highlighted bubble\n                selectedShape = d3.select(shape),\n                x = parseFloat(selectedShape.attr(\"x\")),\n                y = parseFloat(selectedShape.attr(\"y\")),\n                width = parseFloat(selectedShape.attr(\"width\")),\n                height = parseFloat(selectedShape.attr(\"height\")),\n                opacity = selectedShape.attr(\"opacity\"),\n                fill = selectedShape.attr(\"fill\"),\n                dropDest = series._dropLineOrigin(),\n                // Fade the popup stroke mixing the shape fill with 60% white\n                popupStrokeColor = d3.rgb(\n                    d3.rgb(fill).r + 0.6 * (255 - d3.rgb(fill).r),\n                    d3.rgb(fill).g + 0.6 * (255 - d3.rgb(fill).g),\n                    d3.rgb(fill).b + 0.6 * (255 - d3.rgb(fill).b)\n                ),\n                // Fade the popup fill mixing the shape fill with 80% white\n                popupFillColor = d3.rgb(\n                    d3.rgb(fill).r + 0.8 * (255 - d3.rgb(fill).r),\n                    d3.rgb(fill).g + 0.8 * (255 - d3.rgb(fill).g),\n                    d3.rgb(fill).b + 0.8 * (255 - d3.rgb(fill).b)\n                ),\n                t,\n                box,\n                rows = [],\n                // The running y value for the text elements\n                yRunning = 0,\n                // The maximum bounds of the text elements\n                w = 0,\n                h = 0,\n                // Values to shift the popup\n                translateX,\n                translateY;\n\n            if (chart._tooltipGroup !== null && chart._tooltipGroup !== undefined) {\n                chart._tooltipGroup.remove();\n            }\n            chart._tooltipGroup = chart.svg.append(\"g\");\n\n            // Add a drop line to the x axis\n            if (!series.x._hasCategories() && dropDest.y !== null) {\n                chart._tooltipGroup.append(\"line\")\n                    .attr(\"x1\", (x < series.x._origin ? x + 1 : x + width - 1))\n                    .attr(\"y1\", (y < dropDest.y ? y + height : y))\n                    .attr(\"x2\", (x < series.x._origin ? x + 1 : x + width - 1))\n                    .attr(\"y2\", (y < dropDest.y ? y + height : y))\n                    .style(\"fill\", \"none\")\n                    .style(\"stroke\", fill)\n                    .style(\"stroke-width\", 2)\n                    .style(\"stroke-dasharray\", (\"3, 3\"))\n                    .style(\"opacity\", opacity)\n                    .transition()\n                        .delay(animDuration / 2)\n                        .duration(animDuration / 2)\n                        .ease(\"linear\")\n                        // Added 1px offset to cater for svg issue where a transparent\n                        // group overlapping a line can sometimes hide it in some browsers\n                        // Issue #10\n                        .attr(\"y2\", (y < dropDest.y ? dropDest.y - 1 : dropDest.y + 1));\n            }\n\n            // Add a drop line to the y axis\n            if (!series.y._hasCategories() && dropDest.x !== null) {\n                chart._tooltipGroup.append(\"line\")\n                    .attr(\"x1\", (x < dropDest.x ? x + width : x))\n                    .attr(\"y1\", (y < series.y._origin ? y + 1 : y + height - 1))\n                    .attr(\"x2\", (x < dropDest.x ? x + width : x))\n                    .attr(\"y2\", (y < series.y._origin ? y + 1 : y + height - 1))\n                    .style(\"fill\", \"none\")\n                    .style(\"stroke\", fill)\n                    .style(\"stroke-width\", 2)\n                    .style(\"stroke-dasharray\", (\"3, 3\"))\n                    .style(\"opacity\", opacity)\n                    .transition()\n                        .delay(animDuration / 2)\n                        .duration(animDuration / 2)\n                        .ease(\"linear\")\n                        // Added 1px offset to cater for svg issue where a transparent\n                        // group overlapping a line can sometimes hide it in some browsers\n                        // Issue #10\n                        .attr(\"x2\", (x < dropDest.x ? dropDest.x - 1 : dropDest.x + 1));\n            }\n\n            // Add a group for text\n            t = chart._tooltipGroup.append(\"g\");\n            // Create a box for the popup in the text group\n            box = t.append(\"rect\")\n                .attr(\"class\", \"tooltip\");\n\n            // Add the series categories\n            if (series.categoryFields !== null && series.categoryFields !== undefined && series.categoryFields.length > 0) {\n                series.categoryFields.forEach(function (c, i) {\n                    // If the category name and value match don't display the category name\n                    rows.push(c + (e.aggField[i] !== c ? \": \" + e.aggField[i] : \"\"));\n                }, this);\n            }\n\n            if (series.x._hasTimeField()) {\n                rows.push(series.x.timeField + \": \" + series.x._getFormat()(e.xField[0]));\n            } else if (series.x._hasCategories()) {\n                // Add the x axis categories\n                series.x.categoryFields.forEach(function (c, i) {\n                    // If the category name and value match don't display the category name\n                    rows.push(c + (e.xField[i] !== c ? \": \" + e.xField[i] : \"\"));\n                }, this);\n            } else {\n                // Add the axis measure value\n                rows.push(series.x.measure + \": \" + series.x._getFormat()(e.width));\n            }\n\n            if (series.y._hasTimeField()) {\n                rows.push(series.y.timeField + \": \" + series.y._getFormat()(e.yField[0]));\n            } else if (series.y._hasCategories()) {\n                // Add the y axis categories\n                series.y.categoryFields.forEach(function (c, i) {\n                    rows.push(c + (e.yField[i] !== c ? \": \" + e.yField[i] : \"\"));\n                }, this);\n            } else {\n                // Add the axis measure value\n                rows.push(series.y.measure + \": \" + series.y._getFormat()(e.height));\n            }\n\n            if (series.c !== null && series.c !== undefined) {\n                // Add the axis measure value\n                rows.push(series.c.measure + \": \" + series.c._getFormat()(series.c.showPercent ? e.cPct : e.cValue));\n            }\n\n            // Get distinct text rows to deal with cases where 2 axes have the same dimensionality\n            rows = rows.filter(function(elem, pos) {\n                return rows.indexOf(elem) === pos;\n            });\n\n            // Create a text object for every row in the popup\n            t.selectAll(\".textHoverShapes\").data(rows).enter()\n                .append(\"text\")\n                    .attr(\"class\", \"tooltip\")\n                    .text(function (d) { return d; })\n                    .style(\"font-family\", \"sans-serif\")\n                    .style(\"font-size\", \"10px\");\n\n            // Get the max height and width of the text items\n            t.each(function () {\n                w = (this.getBBox().width > w ? this.getBBox().width : w);\n                h = (this.getBBox().width > h ? this.getBBox().height : h);\n            });\n\n            // Position the text relatve to the bubble, the absolute positioning\n            // will be done by translating the group\n            t.selectAll(\"text\")\n                .attr(\"x\", 0)\n                .attr(\"y\", function () {\n                    // Increment the y position\n                    yRunning += this.getBBox().height;\n                    // Position the text at the centre point\n                    return yRunning - (this.getBBox().height / 2);\n                });\n\n            // Draw the box with a margin around the text\n            box.attr(\"x\", -textMargin)\n                .attr(\"y\", -textMargin)\n                .attr(\"height\", Math.floor(yRunning + textMargin) - 0.5)\n                .attr(\"width\", w + 2 * textMargin)\n                .attr(\"rx\", 5)\n                .attr(\"ry\", 5)\n                .style(\"fill\", popupFillColor)\n                .style(\"stroke\", popupStrokeColor)\n                .style(\"stroke-width\", 2)\n                .style(\"opacity\", 0.95);\n\n            // Shift the popup around to avoid overlapping the svg edge\n            if (x + width + textMargin + popupMargin + w < parseFloat(chart.svg.node().getBBox().width)) {\n                // Draw centre right\n                translateX = (x + width + textMargin + popupMargin);\n                translateY = (y + (height / 2) - ((yRunning - (h - textMargin)) / 2));\n                t.attr(\"transform\", \"translate(\" + translateX + \" , \" + translateY + \")\");\n            } else if (x - (textMargin + popupMargin + w) > 0) {\n                // Draw centre left\n                translateX = (x - (textMargin + popupMargin + w));\n                translateY = (y + (height / 2) - ((yRunning - (h - textMargin)) / 2));\n                t.attr(\"transform\", \"translate(\" + translateX + \" , \" + translateY + \")\");\n            } else if (y + height + yRunning + popupMargin + textMargin < parseFloat(chart.svg.node().getBBox().height)) {\n                // Draw centre below\n                translateX = (x + (width / 2) - (2 * textMargin + w) / 2);\n                translateY = (y + height + 2 * textMargin);\n                t.attr(\"transform\", \"translate(\" +\n                    (translateX > 0 ? translateX : popupMargin) + \" , \" +\n                    translateY +\n                    \")\");\n            } else {\n                // Draw centre above\n                translateX = (x + (width / 2) - (2 * textMargin + w) / 2);\n                translateY = (y - yRunning - (h - textMargin));\n                t.attr(\"transform\", \"translate(\" +\n                    (translateX > 0 ? translateX : popupMargin) + \" , \" +\n                    translateY +\n                    \")\");\n            }\n        },\n\n        // Handle the mouse leave event\n        leaveEventHandler: function (chart) {\n            if (chart._tooltipGroup !== null && chart._tooltipGroup !== undefined) {\n                chart._tooltipGroup.remove();\n            }\n        }\n    };\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/plot/bubble.js\n    dimple.plot.bubble = {\n\n        // By default the bubble values are not stacked\n        stacked: false,\n\n        // The axis positions affecting the bubble series\n        supportedAxes: [\"x\", \"y\", \"z\", \"c\"],\n\n        // Draw the axis\n        draw: function (chart, series, duration) {\n\n            // Get self pointer for inner functions\n            var self = this,\n                // Get the series data\n                chartData = series._positionData,\n                // If the series is uninitialised create placeholders, otherwise use the existing shapes\n                theseShapes = null,\n                className = \"series\" + chart.series.indexOf(series);\n\n            if (chart._tooltipGroup !== null && chart._tooltipGroup !== undefined) {\n                chart._tooltipGroup.remove();\n            }\n\n            if (series.shapes === null || series.shapes === undefined) {\n                theseShapes = chart._group.selectAll(\".\" + className).data(chartData);\n            } else {\n                theseShapes = series.shapes.data(chartData, function (d) { return d.key; });\n            }\n\n            // Add\n            theseShapes\n                .enter()\n                .append(\"circle\")\n                .attr(\"id\", function (d) { return d.key; })\n                .attr(\"class\", function (d) {\n                    return className + \" bubble \" +\n                        d.aggField.join(\" \").split(\" \").join(\"_\") + \" \" +\n                        d.xField.join(\" \").split(\" \").join(\"_\") + \" \" +\n                        d.yField.join(\" \").split(\" \").join(\"_\") + \" \" +\n                        d.zField.join(\" \").split(\" \").join(\"_\");\n                })\n                .attr(\"cx\", function (d) {\n                    return (series.x._hasCategories() ? dimple._helpers.cx(d, chart, series) : series.x._origin);\n                })\n                .attr(\"cy\", function (d) {\n                    return (series.y._hasCategories() ? dimple._helpers.cy(d, chart, series) : series.y._origin);\n                })\n                .attr(\"r\", 0)\n                .attr(\"opacity\", function (d) { return dimple._helpers.opacity(d, chart, series); })\n                .on(\"mouseover\", function (e) {\n                    self.enterEventHandler(e, this, chart, series);\n                })\n                .on(\"mouseleave\", function () {\n                    self.leaveEventHandler(chart);\n                })\n                .call(function () {\n                    if (!chart.noFormats) {\n                        this.attr(\"fill\", function (d) { return dimple._helpers.fill(d, chart, series); })\n                            .attr(\"stroke\", function (d) { return dimple._helpers.stroke(d, chart, series); });\n                    }\n                });\n\n            // Update\n            theseShapes\n                .transition().duration(duration)\n                .attr(\"cx\", function (d) { return dimple._helpers.cx(d, chart, series); })\n                .attr(\"cy\", function (d) { return dimple._helpers.cy(d, chart, series); })\n                .attr(\"r\", function (d) { return dimple._helpers.r(d, chart, series); })\n                .call(function () {\n                    if (!chart.noFormats) {\n                        this.attr(\"fill\", function (d) { return dimple._helpers.fill(d, chart, series); })\n                            .attr(\"stroke\", function (d) { return dimple._helpers.stroke(d, chart, series); });\n                    }\n                });\n\n            // Remove\n            theseShapes\n                .exit()\n                .transition().duration(duration)\n                .attr(\"r\", 0)\n                .attr(\"cx\", function (d) {\n                    return (series.x._hasCategories() ? dimple._helpers.cx(d, chart, series) : series.x._origin);\n                })\n                .attr(\"cy\", function (d) {\n                    return (series.y._hasCategories() ? dimple._helpers.cy(d, chart, series) : series.y._origin);\n                })\n                .each(\"end\", function () {\n                    d3.select(this).remove();\n                });\n\n            // Save the shapes to the series array\n            series.shapes = theseShapes;\n        },\n\n        // Handle the mouse enter event\n        enterEventHandler: function (e, shape, chart, series) {\n\n            // The margin between the text and the box\n            var textMargin = 5,\n                // The margin between the ring and the popup\n                popupMargin = 10,\n                // The popup animation duration in ms\n                animDuration = 750,\n                // Collect some facts about the highlighted bubble\n                selectedShape = d3.select(shape),\n                cx = parseFloat(selectedShape.attr(\"cx\")),\n                cy = parseFloat(selectedShape.attr(\"cy\")),\n                r = parseFloat(selectedShape.attr(\"r\")),\n                opacity = selectedShape.attr(\"opacity\"),\n                fill = selectedShape.attr(\"fill\"),\n                dropDest = series._dropLineOrigin(),\n                // Fade the popup stroke mixing the shape fill with 60% white\n                popupStrokeColor = d3.rgb(\n                    d3.rgb(fill).r + 0.6 * (255 - d3.rgb(fill).r),\n                    d3.rgb(fill).g + 0.6 * (255 - d3.rgb(fill).g),\n                    d3.rgb(fill).b + 0.6 * (255 - d3.rgb(fill).b)\n                ),\n                // Fade the popup fill mixing the shape fill with 80% white\n                popupFillColor = d3.rgb(\n                    d3.rgb(fill).r + 0.8 * (255 - d3.rgb(fill).r),\n                    d3.rgb(fill).g + 0.8 * (255 - d3.rgb(fill).g),\n                    d3.rgb(fill).b + 0.8 * (255 - d3.rgb(fill).b)\n                ),\n                t,\n                box,\n                rows = [],\n                // The running y value for the text elements\n                y = 0,\n                // The maximum bounds of the text elements\n                w = 0,\n                h = 0,\n                overlap;\n\n            if (chart._tooltipGroup !== null && chart._tooltipGroup !== undefined) {\n                chart._tooltipGroup.remove();\n            }\n            chart._tooltipGroup = chart.svg.append(\"g\");\n\n            // Add a ring around the data point\n            chart._tooltipGroup.append(\"circle\")\n                .attr(\"cx\", cx)\n                .attr(\"cy\", cy)\n                .attr(\"r\", r)\n                .attr(\"opacity\", 0)\n                .style(\"fill\", \"none\")\n                .style(\"stroke\", fill)\n                .style(\"stroke-width\", 1)\n                .transition()\n                    .duration(animDuration / 2)\n                    .ease(\"linear\")\n                        .attr(\"opacity\", 1)\n                        .attr(\"r\", r + 4)\n                        .style(\"stroke-width\", 2);\n\n            // Add a drop line to the x axis\n            if (dropDest.y !== null) {\n                chart._tooltipGroup.append(\"line\")\n                    .attr(\"x1\", cx)\n                    .attr(\"y1\", (cy < dropDest.y ? cy + r + 4 : cy - r - 4))\n                    .attr(\"x2\", cx)\n                    .attr(\"y2\", (cy < dropDest.y ? cy + r + 4 : cy - r - 4))\n                    .style(\"fill\", \"none\")\n                    .style(\"stroke\", fill)\n                    .style(\"stroke-width\", 2)\n                    .style(\"stroke-dasharray\", (\"3, 3\"))\n                    .style(\"opacity\", opacity)\n                    .transition()\n                        .delay(animDuration / 2)\n                        .duration(animDuration / 2)\n                        .ease(\"linear\")\n                            // Added 1px offset to cater for svg issue where a transparent\n                            // group overlapping a line can sometimes hide it in some browsers\n                            // Issue #10\n                            .attr(\"y2\", (cy < dropDest.y ? dropDest.y - 1 : dropDest.y + 1));\n            }\n\n            // Add a drop line to the y axis\n            if (dropDest.x !== null) {\n                chart._tooltipGroup.append(\"line\")\n                    .attr(\"x1\", (cx < dropDest.x ? cx + r + 4 : cx - r - 4))\n                    .attr(\"y1\", cy)\n                    .attr(\"x2\", (cx < dropDest.x ? cx + r + 4 : cx - r - 4))\n                    .attr(\"y2\", cy)\n                    .style(\"fill\", \"none\")\n                    .style(\"stroke\", fill)\n                    .style(\"stroke-width\", 2)\n                    .style(\"stroke-dasharray\", (\"3, 3\"))\n                    .style(\"opacity\", opacity)\n                    .transition()\n                        .delay(animDuration / 2)\n                        .duration(animDuration / 2)\n                        .ease(\"linear\")\n                            // Added 1px offset to cater for svg issue where a transparent\n                            // group overlapping a line can sometimes hide it in some browsers\n                            // Issue #10\n                            .attr(\"x2\", (cx < dropDest.x ? dropDest.x - 1 : dropDest.x + 1));\n            }\n\n            // Add a group for text\n            t = chart._tooltipGroup.append(\"g\");\n            // Create a box for the popup in the text group\n            box = t.append(\"rect\")\n                .attr(\"class\", \"tooltip\");\n\n            // Add the series categories\n            if (series.categoryFields !== null && series.categoryFields !== undefined && series.categoryFields.length > 0) {\n                series.categoryFields.forEach(function (c, i) {\n                    // If the category name and value match don't display the category name\n                    rows.push(c + (e.aggField[i] !== c ? \": \" + e.aggField[i] : \"\"));\n                }, this);\n            }\n\n            if (series.x._hasTimeField()) {\n                rows.push(series.x.timeField + \": \" + series.x._getFormat()(e.xField[0]));\n            } else if (series.x._hasCategories()) {\n                // Add the x axis categories\n                series.x.categoryFields.forEach(function (c, i) {\n                    // If the category name and value match don't display the category name\n                    rows.push(c + (e.xField[i] !== c ? \": \" + e.xField[i] : \"\"));\n                }, this);\n            } else {\n                // Add the axis measure value\n                rows.push(series.x.measure + \": \" + series.x._getFormat()(e.cx));\n            }\n\n            if (series.y._hasTimeField()) {\n                rows.push(series.y.timeField + \": \" + series.y._getFormat()(e.yField[0]));\n            } else if (series.y._hasCategories()) {\n                // Add the y axis categories\n                series.y.categoryFields.forEach(function (c, i) {\n                    rows.push(c + (e.yField[i] !== c ? \": \" + e.yField[i] : \"\"));\n                }, this);\n            } else {\n                // Add the axis measure value\n                rows.push(series.y.measure + \": \" + series.y._getFormat()(e.cy));\n            }\n\n            if (series.z !== null && series.z !== undefined) {\n                // Add the axis measure value\n                rows.push(series.z.measure + \": \" + series.z._getFormat()(e.zValue));\n            }\n\n            if (series.c !== null && series.c !== undefined) {\n                // Add the axis measure value\n                rows.push(series.c.measure + \": \" + series.c._getFormat()(e.cValue));\n            }\n\n            // Get distinct text rows to deal with cases where 2 axes have the same dimensionality\n            rows = rows.filter(function(elem, pos) {\n                return rows.indexOf(elem) === pos;\n            });\n\n            // Create a text object for every row in the popup\n            t.selectAll(\".textHoverShapes\").data(rows).enter()\n                .append(\"text\")\n                    .attr(\"class\", \"tooltip\")\n                    .text(function (d) { return d; })\n                    .style(\"font-family\", \"sans-serif\")\n                    .style(\"font-size\", \"10px\");\n\n            // Get the max height and width of the text items\n            t.each(function () {\n                w = (this.getBBox().width > w ? this.getBBox().width : w);\n                h = (this.getBBox().width > h ? this.getBBox().height : h);\n            });\n\n            // Position the text relatve to the bubble, the absolute positioning\n            // will be done by translating the group\n            t.selectAll(\"text\")\n                .attr(\"x\", 0)\n                .attr(\"y\", function () {\n                    // Increment the y position\n                    y += this.getBBox().height;\n                    // Position the text at the centre point\n                    return y - (this.getBBox().height / 2);\n                });\n\n            // Draw the box with a margin around the text\n            box.attr(\"x\", -textMargin)\n                .attr(\"y\", -textMargin)\n                .attr(\"height\", Math.floor(y + textMargin) - 0.5)\n                .attr(\"width\", w + 2 * textMargin)\n                .attr(\"rx\", 5)\n                .attr(\"ry\", 5)\n                .style(\"fill\", popupFillColor)\n                .style(\"stroke\", popupStrokeColor)\n                .style(\"stroke-width\", 2)\n                .style(\"opacity\", 0.95);\n\n            // Shift the ring margin left or right depending on whether it will overlap the edge\n            overlap = cx + r + textMargin + popupMargin + w > parseFloat(chart.svg.node().getBBox().width);\n\n            // Translate the shapes to the x position of the bubble (the x position of the shapes is handled)\n            t.attr(\"transform\", \"translate(\" +\n                   (overlap ? cx - (r + textMargin + popupMargin + w) : cx + r + textMargin + popupMargin) + \" , \" +\n                   (cy - ((y - (h - textMargin)) / 2)) +\n                \")\");\n        },\n\n        // Handle the mouse leave event\n        leaveEventHandler: function (chart) {\n            if (chart._tooltipGroup !== null && chart._tooltipGroup !== undefined) {\n                chart._tooltipGroup.remove();\n            }\n        }\n    };\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/plot/line.js\n    dimple.plot.line = {\n        stacked: false,\n        supportedAxes: [\"x\", \"y\", \"c\"],\n        draw: function (chart, series, duration) {\n\n            // Get self pointer for inner functions\n            var self = this,\n                data = series._positionData,\n                fillIns = [],\n                uniqueValues = [],\n                // If there is a category axis we should draw a line for each aggField.  Otherwise\n                // the first aggField defines the points and the others define the line\n                firstAgg = 1,\n                graded = false,\n                line,\n                markers,\n                markerBacks;\n\n            if (chart._tooltipGroup !== null && chart._tooltipGroup !== undefined) {\n                chart._tooltipGroup.remove();\n            }\n\n            if (series.x._hasCategories() || series.y._hasCategories()) {\n                firstAgg = 0;\n            }\n\n            data.forEach(function (d) {\n                var filter = [],\n                    match = false,\n                    k;\n\n                for (k = firstAgg; k < d.aggField.length; k += 1) {\n                    filter.push(d.aggField[k]);\n                }\n\n                uniqueValues.forEach(function (d) {\n                    match = match || (d.join(\"/\") === filter.join(\"/\"));\n                }, this);\n\n                if (!match) {\n                    uniqueValues.push(filter);\n                }\n\n            }, this);\n\n            if (series.c !== null && series.c !== undefined && ((series.x._hasCategories() && series.y._hasMeasure()) || (series.y._hasCategories() && series.x._hasMeasure()))) {\n                graded = true;\n                uniqueValues.forEach(function (seriesValue) {\n                    dimple._addGradient(seriesValue, \"fill-line-gradient-\" + seriesValue.join(\"_\").replace(\" \", \"\"), (series.x._hasCategories() ? series.x : series.y), data, chart, duration, \"fill\");\n                }, this);\n            }\n\n            line = d3.svg.line()\n                .x(function (d) { return dimple._helpers.cx(d, chart, series); })\n                .y(function (d) { return dimple._helpers.cy(d, chart, series); });\n\n            if (series.shapes === null || series.shapes === undefined) {\n                series.shapes = chart._group.selectAll(\".line\")\n                    .data(uniqueValues)\n                    .enter()\n                        .append(\"svg:path\")\n                            .attr(\"opacity\", function(d) { return chart.getColor(d).opacity; });\n            }\n            series.shapes\n                .data(uniqueValues)\n                .transition().duration(duration)\n                .attr(\"class\", function (d) { return \"series line \" + d.join(\"_\").split(\" \").join(\"_\"); })\n                .attr(\"d\", function (d) {\n                    var seriesData = [];\n                    data.forEach(function (r) {\n                        var add = true,\n                            k;\n                        for (k = firstAgg; k < r.aggField.length; k += 1) {\n                            add = add && (d[k - firstAgg] === r.aggField[k]);\n                        }\n                        if (add) {\n                            seriesData.push(r);\n                        }\n                    }, this);\n                    seriesData.sort(function (a, b) {\n                        var sortValue = 0;\n                        if (series.x._hasCategories()) {\n                            sortValue = (dimple._helpers.cx(a, chart, series) < dimple._helpers.cx(b, chart, series) ? -1 : 1);\n                        } else if (series.y._hasCategories()) {\n                            sortValue = (dimple._helpers.cy(a, chart, series) < dimple._helpers.cy(b, chart, series) ? -1 : 1);\n                        }\n                        return sortValue;\n                    });\n                    if (seriesData.length === 1) {\n                        fillIns.push({\n                            cx: dimple._helpers.cx(seriesData[0], chart, series),\n                            cy: dimple._helpers.cy(seriesData[0], chart, series),\n                            opacity: chart.getColor(d[d.length - 1]).opacity,\n                            color: chart.getColor(d[d.length - 1]).stroke\n                        });\n                        d3.select(this).remove();\n                    }\n                    return line(seriesData);\n                })\n                .call(function () {\n                    if (!chart.noFormats) {\n                        this.attr(\"fill\", \"none\")\n                            .attr(\"stroke\", function (d) { return (graded ? \"url(#fill-line-gradient-\" + d.join(\"_\").replace(\" \", \"\") + \")\" : chart.getColor(d[d.length - 1]).stroke);    })\n                            .attr(\"stroke-width\", series.lineWeight);\n                    }\n                });\n\n            if (series.lineMarkers) {\n                if (series._markerBacks === null || series._markerBacks === undefined) {\n                    markerBacks = chart._group.selectAll(\".markerBacks\").data(data);\n                } else {\n                    markerBacks = series._markerBacks.data(data, function (d) { return d.key; });\n                }\n                // Add\n                markerBacks\n                    .enter()\n                    .append(\"circle\")\n                    .attr(\"id\", function (d) { return d.key; })\n                    .attr(\"class\", \"markerBacks\")\n                    .attr(\"cx\", function (d) { return dimple._helpers.cx(d, chart, series); })\n                    .attr(\"cy\", function (d) { return dimple._helpers.cy(d, chart, series); })\n                    .attr(\"r\", 0)\n                    .attr(\"fill\", \"white\")\n                    .attr(\"stroke\", \"none\");\n\n                // Update\n                markerBacks\n                    .transition().duration(duration)\n                    .attr(\"cx\", function (d) { return dimple._helpers.cx(d, chart, series); })\n                    .attr(\"cy\", function (d) { return dimple._helpers.cy(d, chart, series); })\n                    .attr(\"r\", 2 + series.lineWeight);\n                // Remove\n                markerBacks\n                    .exit()\n                    .transition().duration(duration)\n                    .attr(\"r\", 0)\n                    .each(\"end\", function () {\n                        d3.select(this).remove();\n                    });\n                series._markerBacks = markerBacks;\n            }\n\n            // Deal with markers in the same way as main series to fix #28\n            if (series._markers === null || series._markers === undefined) {\n                markers = chart._group.selectAll(\".markers\").data(data);\n            } else {\n                markers = series._markers.data(data, function (d) { return d.key; });\n            }\n\n\n            // Add the actual marker. We need to do this even if we aren't displaying them because they\n            // catch hover events\n            markers\n                .enter()\n                .append(\"circle\")\n                .attr(\"id\", function (d) { return d.key; })\n                .attr(\"class\", \"markers\")\n                .on(\"mouseover\", function (e) {\n                    self.enterEventHandler(e, this, chart, series);\n                })\n                .on(\"mouseleave\", function (e) {\n                    self.leaveEventHandler(e, this, chart, series);\n                })\n                .attr(\"cx\", function (d) { return dimple._helpers.cx(d, chart, series); })\n                .attr(\"cy\", function (d) { return dimple._helpers.cy(d, chart, series); })\n                .attr(\"r\", 0)\n                .attr(\"opacity\", function (d) { return (series.lineMarkers ? chart.getColor(d).opacity : 0); })\n                .call(function () {\n                    if (!chart.noFormats) {\n                        this.attr(\"fill\", \"white\")\n                            .style(\"stroke-width\", series.lineWeight)\n                            .attr(\"stroke\", function (d) {\n                                return (graded ? dimple._helpers.fill(d, chart, series) : chart.getColor(d.aggField[d.aggField.length - 1]).stroke);\n                            });\n                    }\n                });\n\n            markers\n                .transition().duration(duration)\n                .attr(\"cx\", function (d) { return dimple._helpers.cx(d, chart, series); })\n                .attr(\"cy\", function (d) { return dimple._helpers.cy(d, chart, series); })\n                .attr(\"r\", 2 + series.lineWeight)\n                .call(function () {\n                    if (!chart.noFormats) {\n                        this.attr(\"fill\", \"white\")\n                            .style(\"stroke-width\", series.lineWeight)\n                            .attr(\"stroke\", function (d) {\n                                return (graded ? dimple._helpers.fill(d, chart, series) : chart.getColor(d.aggField[d.aggField.length - 1]).stroke);\n                            });\n                    }\n                });\n\n            markers\n                .exit()\n                .transition().duration(duration)\n                .attr(\"r\", 0)\n                .each(\"end\", function () {\n                    d3.select(this).remove();\n                });\n\n            // Save the shapes to the series array\n            series._markers = markers;\n\n            // Deal with single point lines if there are no markers\n            if (!series.lineMarkers) {\n                chart._group.selectAll(\".fill\")\n                    .data(fillIns)\n                    .enter()\n                    .append(\"circle\")\n                    .attr(\"cx\", function (d) { return d.cx; })\n                    .attr(\"cy\", function (d) { return d.cy; })\n                    .attr(\"r\", series.lineWeight)\n                    .attr(\"opacity\", function (d) { return d.opacity; })\n                    .call(function () {\n                        if (!chart.noFormats) {\n                            this.attr(\"fill\", function (d) { return d.color; })\n                                .attr(\"stroke\", \"none\");\n                        }\n                    });\n            }\n        },\n\n        // Handle the mouse enter event\n        enterEventHandler: function (e, shape, chart, series) {\n\n            // The margin between the text and the box\n            var textMargin = 5,\n                // The margin between the ring and the popup\n                popupMargin = 10,\n                // The popup animation duration in ms\n                animDuration = 750,\n                // Collect some facts about the highlighted bubble\n                selectedShape = d3.select(shape),\n                cx = parseFloat(selectedShape.attr(\"cx\")),\n                cy = parseFloat(selectedShape.attr(\"cy\")),\n                r = parseFloat(selectedShape.attr(\"r\")),\n                opacity = dimple._helpers.opacity(e, chart, series),\n                fill = selectedShape.attr(\"stroke\"),\n                dropDest = series._dropLineOrigin(),\n                // Fade the popup stroke mixing the shape fill with 60% white\n                popupStrokeColor = d3.rgb(\n                    d3.rgb(fill).r + 0.6 * (255 - d3.rgb(fill).r),\n                    d3.rgb(fill).g + 0.6 * (255 - d3.rgb(fill).g),\n                    d3.rgb(fill).b + 0.6 * (255 - d3.rgb(fill).b)\n                ),\n                // Fade the popup fill mixing the shape fill with 80% white\n                popupFillColor = d3.rgb(\n                    d3.rgb(fill).r + 0.8 * (255 - d3.rgb(fill).r),\n                    d3.rgb(fill).g + 0.8 * (255 - d3.rgb(fill).g),\n                    d3.rgb(fill).b + 0.8 * (255 - d3.rgb(fill).b)\n                ),\n                // The running y value for the text elements\n                y = 0,\n                // The maximum bounds of the text elements\n                w = 0,\n                h = 0,\n                t,\n                box,\n                rows = [],\n                overlap;\n\n            if (chart._tooltipGroup !== null && chart._tooltipGroup !== undefined) {\n                chart._tooltipGroup.remove();\n            }\n            chart._tooltipGroup = chart.svg.append(\"g\");\n\n            // On hover make the line marker visible immediately\n            selectedShape.style(\"opacity\", 1);\n\n            // Add a ring around the data point\n            chart._tooltipGroup.append(\"circle\")\n                .attr(\"cx\", cx)\n                .attr(\"cy\", cy)\n                .attr(\"r\", r)\n                .attr(\"opacity\", 0)\n                .style(\"fill\", \"none\")\n                .style(\"stroke\", fill)\n                .style(\"stroke-width\", 1)\n                .transition()\n                    .duration(animDuration / 2)\n                    .ease(\"linear\")\n                        .attr(\"opacity\", 1)\n                        .attr(\"r\", r + series.lineWeight + 2)\n                        .style(\"stroke-width\", 2);\n\n            // Add a drop line to the x axis\n            if (dropDest.y !== null) {\n                chart._tooltipGroup.append(\"line\")\n                    .attr(\"x1\", cx)\n                    .attr(\"y1\", (cy < dropDest.y ? cy + r + series.lineWeight + 2 : cy - r - series.lineWeight - 2))\n                    .attr(\"x2\", cx)\n                    .attr(\"y2\", (cy < dropDest.y ? cy + r + series.lineWeight + 2 : cy - r - series.lineWeight - 2))\n                    .style(\"fill\", \"none\")\n                    .style(\"stroke\", fill)\n                    .style(\"stroke-width\", 2)\n                    .style(\"stroke-dasharray\", (\"3, 3\"))\n                    .style(\"opacity\", opacity)\n                    .transition()\n                        .delay(animDuration / 2)\n                        .duration(animDuration / 2)\n                        .ease(\"linear\")\n                            // Added 1px offset to cater for svg issue where a transparent\n                            // group overlapping a line can sometimes hide it in some browsers\n                            // Issue #10\n                            .attr(\"y2\", (cy < dropDest.y ? dropDest.y - 1 : dropDest.y + 1));\n            }\n\n            // Add a drop line to the y axis\n            if (dropDest.x !== null) {\n                chart._tooltipGroup.append(\"line\")\n                    .attr(\"x1\", (cx < dropDest.x ? cx + r + series.lineWeight + 2 : cx - r - series.lineWeight - 2))\n                    .attr(\"y1\", cy)\n                    .attr(\"x2\", (cx < dropDest.x ? cx + r + series.lineWeight + 2 : cx - r - series.lineWeight - 2))\n                    .attr(\"y2\", cy)\n                    .style(\"fill\", \"none\")\n                    .style(\"stroke\", fill)\n                    .style(\"stroke-width\", 2)\n                    .style(\"stroke-dasharray\", (\"3, 3\"))\n                    .style(\"opacity\", opacity)\n                    .transition()\n                        .delay(animDuration / 2)\n                        .duration(animDuration / 2)\n                        .ease(\"linear\")\n                            // Added 1px offset to cater for svg issue where a transparent\n                            // group overlapping a line can sometimes hide it in some browsers\n                            // Issue #10\n                            .attr(\"x2\", (cx < dropDest.x ? dropDest.x - 1 : dropDest.x + 1));\n            }\n\n            // Add a group for text\n            t = chart._tooltipGroup.append(\"g\");\n            // Create a box for the popup in the text group\n            box = t.append(\"rect\")\n                .attr(\"class\", \"tooltip\");\n\n            // Add the series categories\n            if (series.categoryFields !== null && series.categoryFields !== undefined && series.categoryFields.length > 0) {\n                series.categoryFields.forEach(function (c, i) {\n                    // If the category name and value match don't display the category name\n                    rows.push(c + (e.aggField[i] !== c ? \": \" + e.aggField[i] : \"\"));\n                }, this);\n            }\n\n            if (series.x._hasTimeField()) {\n                rows.push(series.x.timeField + \": \" + series.x._getFormat()(e.xField[0]));\n            } else if (series.x._hasCategories()) {\n                // Add the x axis categories\n                series.x.categoryFields.forEach(function (c, i) {\n                    // If the category name and value match don't display the category name\n                    rows.push(c + (e.xField[i] !== c ? \": \" + e.xField[i] : \"\"));\n                }, this);\n            } else if (series.x.useLog) {\n                // Add the y axis log\n                rows.push(series.x.measure + \": \" + e.cx);\n            } else {\n                // Add the axis measure value\n                rows.push(series.x.measure + \": \" + series.x._getFormat()(e.cx));\n            }\n\n            if (series.y._hasTimeField()) {\n                rows.push(series.y.timeField + \": \" + series.y._getFormat()(e.yField[0]));\n            } else if (series.y._hasCategories()) {\n                // Add the y axis categories\n                series.y.categoryFields.forEach(function (c, i) {\n                    rows.push(c + (e.yField[i] !== c ? \": \" + e.yField[i] : \"\"));\n                }, this);\n            } else if (series.y.useLog) {\n                // Add the y axis log\n                rows.push(series.y.measure + \": \" + e.cy);\n            } else {\n                // Add the axis measure value\n                rows.push(series.y.measure + \": \" + series.y._getFormat()(e.cy));\n            }\n\n            if (series.z !== null && series.z !== undefined) {\n                // Add the axis measure value\n                rows.push(series.z.measure + \": \" + series.z._getFormat()(e.zValue));\n            }\n\n            if (series.c !== null && series.c !== undefined) {\n                // Add the axis measure value\n                rows.push(series.c.measure + \": \" + series.c._getFormat()(e.cValue));\n            }\n\n            // Get distinct text rows to deal with cases where 2 axes have the same dimensionality\n            rows = rows.filter(function(elem, pos) {\n                return rows.indexOf(elem) === pos;\n            });\n\n            // Create a text object for every row in the popup\n            t.selectAll(\".textHoverShapes\").data(rows).enter()\n                .append(\"text\")\n                    .attr(\"class\", \"tooltip\")\n                    .text(function (d) { return d; })\n                    .style(\"font-family\", \"sans-serif\")\n                    .style(\"font-size\", \"10px\");\n\n            // Get the max height and width of the text items\n            t.each(function () {\n                w = (this.getBBox().width > w ? this.getBBox().width : w);\n                h = (this.getBBox().width > h ? this.getBBox().height : h);\n            });\n\n            // Position the text relatve to the bubble, the absolute positioning\n            // will be done by translating the group\n            t.selectAll(\"text\")\n                .attr(\"x\", 0)\n                .attr(\"y\", function () {\n                    // Increment the y position\n                    y += this.getBBox().height;\n                    // Position the text at the centre point\n                    return y - (this.getBBox().height / 2);\n                });\n\n            // Draw the box with a margin around the text\n            box.attr(\"x\", -textMargin)\n                .attr(\"y\", -textMargin)\n                .attr(\"height\", Math.floor(y + textMargin) - 0.5)\n                .attr(\"width\", w + 2 * textMargin)\n                .attr(\"rx\", 5)\n                .attr(\"ry\", 5)\n                .style(\"fill\", popupFillColor)\n                .style(\"stroke\", popupStrokeColor)\n                .style(\"stroke-width\", 2)\n                .style(\"opacity\", 0.95);\n\n            // Shift the ring margin left or right depending on whether it will overlap the edge\n            overlap = cx + r + textMargin + popupMargin + w > parseFloat(chart.svg.node().getBBox().width);\n\n            // Translate the shapes to the x position of the bubble (the x position of the shapes is handled)\n            t.attr(\"transform\", \"translate(\" +\n                   (overlap ? cx - (r + textMargin + popupMargin + w) : cx + r + textMargin + popupMargin) + \" , \" +\n                   (cy - ((y - (h - textMargin)) / 2)) +\n                \")\");\n        },\n\n        // Handle the mouse leave event\n        leaveEventHandler: function (e, shape, chart, series) {\n            // Return the opacity of the marker\n            d3.select(shape).style(\"opacity\", (series.lineMarkers ? dimple._helpers.opacity(e, chart, series) : 0));\n            if (chart._tooltipGroup !== null && chart._tooltipGroup !== undefined) {\n                chart._tooltipGroup.remove();\n            }\n        }\n    };\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/methods/_addGradient.js\n    dimple._addGradient = function (seriesValue, id, categoryAxis, data, chart, duration, colorProperty) {\n\n        var grad = chart._group.select(\"#\" + id),\n            cats = [],\n            field = categoryAxis.position + \"Field\",\n            transition = true,\n            colors = [];\n\n        data.forEach(function (d) {\n            if (cats.indexOf(d[field]) === -1) {\n                cats.push(d[field]);\n            }\n        }, this);\n\n        cats = cats.sort(function (a, b) { return categoryAxis._scale(a) - categoryAxis._scale(b); });\n\n        if (grad.node() === null) {\n            transition = false;\n            grad = chart._group.append(\"linearGradient\")\n                .attr(\"id\", id)\n                .attr(\"gradientUnits\", \"userSpaceOnUse\")\n                .attr(\"x1\", (categoryAxis.position === \"x\" ? categoryAxis._scale(cats[0]) + ((chart._widthPixels() / cats.length) / 2) : 0))\n                .attr(\"y1\", (categoryAxis.position === \"y\" ? categoryAxis._scale(cats[0]) - ((chart._heightPixels() / cats.length) / 2) : 0))\n                .attr(\"x2\", (categoryAxis.position === \"x\" ? categoryAxis._scale(cats[cats.length - 1]) + ((chart._widthPixels() / cats.length) / 2) : 0))\n                .attr(\"y2\", (categoryAxis.position === \"y\" ? categoryAxis._scale(cats[cats.length - 1]) - ((chart._heightPixels() / cats.length) / 2) : 0));\n        }\n\n        cats.forEach(function (cat, j) {\n\n            var row = {},\n                k = 0;\n\n            for (k = 0; k < data.length; k = k + 1) {\n                if (data[k].aggField.join(\"_\") === seriesValue.join(\"_\") && data[k][field].join(\"_\") === cat.join(\"_\")) {\n                    row = data[k];\n                    break;\n                }\n            }\n\n            colors.push({ offset: Math.round((j / (cats.length - 1)) * 100) + \"%\", color: row[colorProperty] });\n        }, this);\n\n        if (transition) {\n            grad.selectAll(\"stop\")\n                .data(colors)\n                .transition().duration(duration)\n                .attr(\"offset\", function(d) { return d.offset; })\n                .attr(\"stop-color\", function(d) { return d.color; });\n        } else {\n            grad.selectAll(\"stop\")\n                .data(colors)\n                .enter()\n                .append(\"stop\")\n                .attr(\"offset\", function(d) { return d.offset; })\n                .attr(\"stop-color\", function(d) { return d.color; });\n        }\n    };\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/objects/chart/methods/_getOrderedList.js\n    dimple._getOrderedList = function (data, mainField, levelDefinitions) {\n        var rollupData = [],\n            sortStack = [],\n            finalArray = [],\n            fields = [mainField],\n            defs = [];\n        // Force the level definitions into an array\n        if (levelDefinitions !== null && levelDefinitions !== undefined) {\n            defs = defs.concat(levelDefinitions);\n        }\n        // Add the base case\n        defs = defs.concat({ ordering: mainField, desc: false });\n        // Exclude fields if this does not contain a function\n        defs.forEach(function (def) {\n            var field;\n            if (typeof def.ordering === \"function\") {\n                for (field in data[0]) {\n                    if (data[0].hasOwnProperty(field) && fields.indexOf(field) === -1) {\n                        fields.push(field);\n                    }\n                }\n            } else if (!(def.ordering instanceof Array)) {\n                fields.push(def.ordering);\n            }\n        }, this);\n        rollupData = dimple._rollUp(data, mainField, fields);\n        // If we go below the leaf stop recursing\n        if (defs.length >= 1) {\n            // Build a stack of compare methods\n            // Iterate each level definition\n            defs.forEach(function (def) {\n                // Draw ascending by default\n                var desc = (def.desc === null || def.desc === undefined ? false : def.desc),\n                    ordering = def.ordering,\n                    orderArray = [],\n                    field = (typeof ordering === \"string\" ? ordering : null),\n                    sum = function (array) {\n                        var total = 0,\n                            i;\n                        for (i = 0; i < array.length; i += 1) {\n                            if (isNaN(array[i])) {\n                                total = 0;\n                                break;\n                            } else {\n                                total += parseFloat(array[i]);\n                            }\n                        }\n                        return total;\n                    },\n                    compare = function (a, b) {\n                        var result = 0,\n                            sumA = sum(a),\n                            sumB = sum(b);\n                        if (!isNaN(sumA) && sumA !== 0 && !isNaN(sumB) && sumB !== 0) {\n                            result = parseFloat(sumA) - parseFloat(sumB);\n                        } else if (!isNaN(Date.parse(a[0])) && !isNaN(Date.parse(b[0]))) {\n                            result = Date.parse(a[0]) - Date.parse(b[0]);\n                        } else if (a[0] < b[0]) {\n                            result = -1;\n                        } else if (a[0] > b[0]) {\n                            result = 1;\n                        }\n                        return result;\n                    };\n                // Handle the ordering based on the type set\n                if (typeof ordering === \"function\") {\n                    // Apply the sort predicate directly\n                    sortStack.push(function (a, b) {\n                        return (desc ? -1 : 1) * ordering(a, b);\n                    });\n                } else if (ordering instanceof Array) {\n                    // The order list may be an array of arrays\n                    // combine the values with pipe delimiters.\n                    // The delimiter is irrelevant as long as it is consistent\n                    // with the sort predicate below\n                    ordering.forEach(function (d) {\n                        orderArray.push(([].concat(d)).join(\"|\"));\n                    }, this);\n                    // Sort according to the axis position\n                    sortStack.push(function (a, b) {\n                        var aStr = \"\".concat(a[mainField]),\n                            bStr = \"\".concat(b[mainField]),\n                            aIx,\n                            bIx;\n                        // If the value is not found it should go to the end (if descending it\n                        // should go to the start so that it ends up at the back when reversed)\n                        aIx = orderArray.indexOf(aStr);\n                        bIx = orderArray.indexOf(bStr);\n                        aIx = (aIx < 0 ? (desc ? -1 : orderArray.length) : aIx);\n                        bIx = (bIx < 0 ? (desc ? -1 : orderArray.length) : bIx);\n                        return (desc ? -1 : 1) * (aIx - bIx);\n                    });\n                } else {\n                    // Sort the data\n                    sortStack.push(function (a, b) {\n                        // The result value\n                        var result = 0;\n                        // Find the field\n                        if (a[field] !== undefined && b[field] !== undefined) {\n                            // Compare just the first mapped value\n                            result = compare([].concat(a[field]), [].concat(b[field]));\n                        }\n                        return (desc ? -1 : 1) * result;\n                    });\n                }\n            });\n            rollupData.sort(function (a, b) {\n                var compareIx = 0,\n                    result = 0;\n                while (compareIx < sortStack.length && result === 0) {\n                    result = sortStack[compareIx](a, b);\n                    compareIx += 1;\n                }\n                return result;\n            });\n            // Return a simple array if only one field is being returned.\n            // for multiple fields remove extra fields but leave objects\n            rollupData.forEach(function (d) {\n                finalArray.push(d[mainField]);\n            }, this);\n        }\n        // Return the ordered list\n        return finalArray;\n    };\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/methods/_helpers.js\n    dimple._helpers = {\n\n        // Calculate the centre x position\n        cx: function (d, chart, series) {\n            var returnCx = 0;\n            if (series.x.measure !== null && series.x.measure !== undefined) {\n                returnCx = series.x._scale(d.cx);\n            } else if (series.x._hasCategories() && series.x.categoryFields.length >= 2) {\n                returnCx = series.x._scale(d.cx) + dimple._helpers.xGap(chart, series) + ((d.xOffset + 0.5) * (((chart._widthPixels() / series.x._max) - 2 * dimple._helpers.xGap(chart, series)) * d.width));\n            } else {\n                returnCx = series.x._scale(d.cx) + ((chart._widthPixels() / series.x._max) / 2);\n            }\n            return returnCx;\n        },\n\n        // Calculate the centre y position\n        cy: function (d, chart, series) {\n            var returnCy = 0;\n            if (series.y.measure !== null && series.y.measure !== undefined) {\n                returnCy = series.y._scale(d.cy);\n            } else if (series.y.categoryFields !== null && series.y.categoryFields !== undefined && series.y.categoryFields.length >= 2) {\n                returnCy = (series.y._scale(d.cy) - (chart._heightPixels() / series.y._max)) +  dimple._helpers.yGap(chart, series) + ((d.yOffset + 0.5) * (((chart._heightPixels() / series.y._max) - 2 * dimple._helpers.yGap(chart, series)) * d.height));\n            } else {\n                returnCy = series.y._scale(d.cy) - ((chart._heightPixels() / series.y._max) / 2);\n            }\n            return returnCy;\n        },\n\n        // Calculate the radius\n        r: function (d, chart, series) {\n            var returnR = 0;\n            if (series.z === null || series.z === undefined) {\n                returnR = 5;\n            } else if (series.z._hasMeasure()) {\n                returnR = series.z._scale(d.r);\n            } else {\n                returnR = series.z._scale(chart._heightPixels() / 100);\n            }\n            return returnR;\n        },\n\n        // Calculate the x gap for bar type charts\n        xGap: function (chart, series) {\n            var returnXGap = 0;\n            if ((series.x.measure === null || series.x.measure === undefined) && series.barGap > 0) {\n                returnXGap = ((chart._widthPixels() / series.x._max) * (series.barGap > 0.99 ? 0.99 : series.barGap)) / 2;\n            }\n            return returnXGap;\n        },\n\n        // Calculate the x gap for clusters within bar type charts\n        xClusterGap: function (d, chart, series) {\n            var returnXClusterGap = 0;\n            if (series.x.categoryFields !== null && series.x.categoryFields !== undefined && series.x.categoryFields.length >= 2 && series.clusterBarGap > 0 && !series.x._hasMeasure()) {\n                returnXClusterGap = (d.width * ((chart._widthPixels() / series.x._max) - (dimple._helpers.xGap(chart, series) * 2)) * (series.clusterBarGap > 0.99 ? 0.99 : series.clusterBarGap)) / 2;\n            }\n            return returnXClusterGap;\n        },\n\n        // Calculate the y gap for bar type charts\n        yGap: function (chart, series) {\n            var returnYGap = 0;\n            if ((series.y.measure === null || series.y.measure === undefined) && series.barGap > 0) {\n                returnYGap = ((chart._heightPixels() / series.y._max) * (series.barGap > 0.99 ? 0.99 : series.barGap)) / 2;\n            }\n            return returnYGap;\n        },\n\n        // Calculate the y gap for clusters within bar type charts\n        yClusterGap: function (d, chart, series) {\n            var returnYClusterGap = 0;\n            if (series.y.categoryFields !== null && series.y.categoryFields !== undefined && series.y.categoryFields.length >= 2 && series.clusterBarGap > 0 && !series.y._hasMeasure()) {\n                returnYClusterGap = (d.height * ((chart._heightPixels() / series.y._max) - (dimple._helpers.yGap(chart, series) * 2)) * (series.clusterBarGap > 0.99 ? 0.99 : series.clusterBarGap)) / 2;\n            }\n            return returnYClusterGap;\n        },\n\n        // Calculate the top left x position for bar type charts\n        x: function (d, chart, series) {\n            var returnX = 0;\n            if (series.x._hasTimeField()) {\n                returnX = series.x._scale(d.x) - (dimple._helpers.width(d, chart, series) / 2);\n            } else if (series.x.measure !== null && series.x.measure !== undefined) {\n                returnX = series.x._scale(d.x);\n            } else {\n                returnX = series.x._scale(d.x) + dimple._helpers.xGap(chart, series) + (d.xOffset * (dimple._helpers.width(d, chart, series) + 2 * dimple._helpers.xClusterGap(d, chart, series))) + dimple._helpers.xClusterGap(d, chart, series);\n            }\n            return returnX;\n        },\n\n        // Calculate the top left y position for bar type charts\n        y: function (d, chart, series) {\n            var returnY = 0;\n            if (series.y._hasTimeField()) {\n                returnY = series.y._scale(d.y) - (dimple._helpers.height(d, chart, series) / 2);\n            } else if (series.y.measure !== null && series.y.measure !== undefined) {\n                returnY = series.y._scale(d.y);\n            } else {\n                returnY = (series.y._scale(d.y) - (chart._heightPixels() / series.y._max)) + dimple._helpers.yGap(chart, series) + (d.yOffset * (dimple._helpers.height(d, chart, series) + 2 * dimple._helpers.yClusterGap(d, chart, series))) + dimple._helpers.yClusterGap(d, chart, series);\n            }\n            return returnY;\n        },\n\n        // Calculate the width for bar type charts\n        width: function (d, chart, series) {\n            var returnWidth = 0;\n            if (series.x.measure !== null && series.x.measure !== undefined) {\n                returnWidth = Math.abs(series.x._scale((d.x < 0 ? d.x - d.width : d.x + d.width)) - series.x._scale(d.x));\n            } else if (series.x._hasTimeField()) {\n                returnWidth = series.x.floatingBarWidth;\n            } else {\n                returnWidth = d.width * ((chart._widthPixels() / series.x._max) - (dimple._helpers.xGap(chart, series) * 2)) - (dimple._helpers.xClusterGap(d, chart, series) * 2);\n            }\n            return returnWidth;\n        },\n\n        // Calculate the height for bar type charts\n        height: function (d, chart, series) {\n            var returnHeight = 0;\n            if (series.y._hasTimeField()) {\n                returnHeight = series.y.floatingBarWidth;\n            } else if (series.y.measure !== null && series.y.measure !== undefined) {\n                returnHeight = Math.abs(series.y._scale(d.y) - series.y._scale((d.y <= 0 ? d.y + d.height : d.y - d.height)));\n            } else {\n                returnHeight = d.height * ((chart._heightPixels() / series.y._max) - (dimple._helpers.yGap(chart, series) * 2)) - (dimple._helpers.yClusterGap(d, chart, series) * 2);\n            }\n            return returnHeight;\n        },\n\n        // Calculate the opacity for series\n        opacity: function (d, chart, series) {\n            var returnOpacity = 0;\n            if (series.c !== null && series.c !== undefined) {\n                returnOpacity = d.opacity;\n            } else {\n                returnOpacity = chart.getColor(d.aggField.slice(-1)[0]).opacity;\n            }\n            return returnOpacity;\n        },\n\n        // Calculate the fill coloring for series\n        fill: function (d, chart, series) {\n            var returnFill = 0;\n            if (series.c !== null && series.c !== undefined) {\n                returnFill = d.fill;\n            } else {\n                returnFill = chart.getColor(d.aggField.slice(-1)[0]).fill;\n            }\n            return returnFill;\n        },\n\n        // Calculate the stroke coloring for series\n        stroke: function (d, chart, series) {\n            var stroke = 0;\n            if (series.c !== null && series.c !== undefined) {\n                stroke = d.stroke;\n            } else {\n                stroke = chart.getColor(d.aggField.slice(-1)[0]).stroke;\n            }\n            return stroke;\n        }\n\n    };\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/methods/_parentHeight.js\n    dimple._parentHeight = function (parent) {\n        // This one seems to work in Chrome - good old Chrome!\n        var returnValue = parent.offsetHeight;\n        // This does it for IE\n        if (returnValue <= 0 || returnValue === null || returnValue === undefined) {\n            returnValue = parent.clientHeight;\n        }\n        // FireFox is the hard one this time.  See this bug report:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=649285//\n        // It's dealt with by trying to recurse up the dom until we find something\n        // we can get a size for.  Usually the parent of the SVG.  It's a bit costly\n        // but I don't know of any other way.\n        if (returnValue <= 0 || returnValue === null || returnValue === undefined) {\n            if (parent.parentNode === null || parent.parentNode === undefined) {\n                // Give up - Recursion Exit Point\n                returnValue = 0;\n            } else {\n                // Get the size from the parent recursively\n                returnValue = dimple._parseYPosition(d3.select(parent).attr(\"height\"), parent.parentNode);\n            }\n        }\n        return returnValue;\n    };\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/methods/_parentWidth.js\n    dimple._parentWidth = function (parent) {\n        // This one seems to work in Chrome - good old Chrome!\n        var returnValue = parent.offsetWidth;\n        // This does it for IE\n        if (returnValue <= 0 || returnValue === null || returnValue === undefined) {\n            returnValue = parent.clientWidth;\n        }\n        // FireFox is the hard one this time.  See this bug report:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=649285//\n        // It's dealt with by trying to recurse up the dom until we find something\n        // we can get a size for.  Usually the parent of the SVG.  It's a bit costly\n        // but I don't know of any other way.\n        if (returnValue <= 0 || returnValue === null || returnValue === undefined) {\n            if (parent.parentNode === null || parent.parentNode === undefined) {\n                // Give up - Recursion Exit Point\n                returnValue = 0;\n            } else {\n                // Get the size from the parent recursively\n                returnValue = dimple._parseXPosition(d3.select(parent).attr(\"width\"), parent.parentNode);\n            }\n        }\n        return returnValue;\n    };\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/methods/_parseXPosition.js\n    dimple._parseXPosition = function (value, parent) {\n        var returnValue = 0,\n            values = value.toString().split(\",\");\n        values.forEach(function (v) {\n            if (v !== undefined && v !== null) {\n                if (!isNaN(v)) {\n                    returnValue += parseFloat(v);\n                } else if (v.slice(-1) === \"%\") {\n                    returnValue += dimple._parentWidth(parent) * (parseFloat(v.slice(0, v.length - 1)) / 100);\n                } else if (v.slice(-2) === \"px\") {\n                    returnValue += parseFloat(v.slice(0, v.length - 2));\n                } else {\n                    returnValue = value;\n                }\n            }\n        }, this);\n        return returnValue;\n    };\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/methods/_parseYPosition.js\n    dimple._parseYPosition = function (value, parent) {\n        var returnValue = 0,\n            values = value.toString().split(\",\");\n        values.forEach(function (v) {\n            if (v !== undefined && v !== null) {\n                if (!isNaN(v)) {\n                    returnValue += parseFloat(v);\n                } else if (v.slice(-1) === \"%\") {\n                    returnValue += dimple._parentHeight(parent) * (parseFloat(v.slice(0, v.length - 1)) / 100);\n                } else if (v.slice(-2) === \"px\") {\n                    returnValue += parseFloat(v.slice(0, v.length - 2));\n                } else {\n                    returnValue = value;\n                }\n            }\n        }, this);\n        return returnValue;\n    };\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/methods/_rollUp.js\n    dimple._rollUp = function (data, fields, includeFields) {\n\n        var returnList = [];\n        // Put single values into single value arrays\n        if (fields !== null && fields !== undefined) {\n            fields = [].concat(fields);\n        } else {\n            fields = [];\n        }\n        // Iterate every row in the data\n        data.forEach(function (d) {\n            // The index of the corresponding row in the return list\n            var index = -1,\n                newRow = {},\n                match = true;\n            // Find the corresponding value in the return list\n            returnList.forEach(function (r, j) {\n                if (index === -1) {\n                    // Indicates a match\n                    match = true;\n                    // Iterate the passed fields and compare\n                    fields.forEach(function (f) {\n                        match = match && d[f] === r[f];\n                    }, this);\n                    // If this is a match get the index\n                    if (match) {\n                        index = j;\n                    }\n                }\n            }, this);\n            // Pick up the matched row, or add a new one\n            if (index !== -1) {\n                newRow = returnList[index];\n            } else {\n                // Iterate the passed fields and add to the new row\n                fields.forEach(function (f) {\n                    newRow[f] = d[f];\n                }, this);\n                returnList.push(newRow);\n                index = returnList.length - 1;\n            }\n            // Iterate all the fields in the data\n            includeFields.forEach(function (field) {\n                if (fields.indexOf(field) === -1) {\n                    if (newRow[field] === undefined) {\n                        newRow[field] = [];\n                    }\n                    newRow[field] = newRow[field].concat(d[field]);\n                }\n            }, this);\n            // Update the return list\n            returnList[index] = newRow;\n        }, this);\n        // Return the flattened list\n        return returnList;\n    };\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/methods/filterData.js\n    // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple#wiki-filterData\n    dimple.filterData = function (data, field, filterValues) {\n        var returnData = data;\n        if (field !== null && filterValues !== null) {\n            // Build an array from a single filter value or use the array\n            if (filterValues !== null && filterValues !== undefined) { filterValues = [].concat(filterValues); }\n            // The data to return\n            returnData = [];\n            // Iterate all the data\n            data.forEach(function (d) {\n                // If an invalid field is passed, just pass the data\n                if (d[field] === null) {\n                    returnData.push(d);\n                } else {\n                    if (filterValues.indexOf([].concat(d[field]).join(\"/\")) > -1) {\n                        returnData.push(d);\n                    }\n                }\n            }, this);\n        }\n        // Return the filtered data\n        return returnData;\n    };\n\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/methods/getUniqueValues.js\n    // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple#wiki-getUniqueValues\n    dimple.getUniqueValues = function (data, fields) {\n        var returnlist = [];\n        // Put single values into single value arrays\n        if (fields !== null && fields !== undefined) {\n            fields = [].concat(fields);\n            // Iterate every row in the data\n            data.forEach(function (d) {\n                // Handle multiple category values by iterating the fields in the row and concatonate the values\n                var field = \"\";\n                fields.forEach(function (f, i) {\n                    if (i > 0) {\n                        field += \"/\";\n                    }\n                    field += d[f];\n                }, this);\n                // If the field was not found, add it to the end of the categories array\n                if (returnlist.indexOf(field) === -1) {\n                    returnlist.push(field);\n                }\n            }, this);\n        }\n        return returnlist;\n    };\n\n    // Copyright: 2013 PMSI-AlignAlytics\n    // License: \"https://github.com/PMSI-AlignAlytics/dimple/blob/master/MIT-LICENSE.txt\"\n    // Source: /src/methods/newSvg.js\n    // Help: http://github.com/PMSI-AlignAlytics/dimple/wiki/dimple#wiki-newSvg\n    dimple.newSvg = function (parentSelector, width, height) {\n        var selectedShape = null;\n        if (parentSelector === null || parentSelector === undefined) {\n            parentSelector = \"body\";\n        }\n        selectedShape = d3.select(parentSelector);\n        if (selectedShape.empty()) {\n            throw \"The '\" + parentSelector + \"' selector did not match any elements.  Please prefix with '#' to select by id or '.' to select by class\";\n        }\n        return selectedShape.append(\"svg\").attr(\"width\", width).attr(\"height\", height);\n    };\n\n\n}());\n// End dimple\n"]}